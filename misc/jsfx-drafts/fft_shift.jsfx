desc: fractional circular FFT delay

import _core.jsfx-inc

@init

// test of https://dsp.stackexchange.com/questions/10250/how-to-circularly-shift-a-signal-by-a-fraction-of-a-sample
// and https://dsp.stackexchange.com/questions/60476/how-to-do-fft-fractional-time-delay-solved
// to see if it can be use to shift minphase kernels

FFT_SIZE = 32;
FFT_MASK = FFT_SIZE - 1;
DELAY_SPLS = 0.5;

inbuff.array_init (FFT_SIZE * 2);
outbuff.array_init (FFT_SIZE);
n.array_init (FFT_SIZE);

i = 0;
loop (FFT_SIZE,
  inbuff.ptr[i * 2] = i + 1;
  n.ptr[i] = i + ((i < FFT_SIZE / 2) ? 0 : -FFT_SIZE);
  i += 1;
);

fft (inbuff.ptr, FFT_SIZE);
fft_permute (inbuff.ptr, FFT_SIZE);

// Shift zero-frequency component to center of spectrum as:
// https://numpy.org/doc/stable/reference/generated/numpy.fft.fftshift.html

i = 0;
loop (FFT_SIZE,
    // exp (j * 2pi * (n - 1) / M * d)
    v = (2 * $pi * DELAY_SPLS * n.ptr[i] / FFT_SIZE); // + ($pi * DELAY_SPLS);
    s_re = cos (v);
    s_im = sin (v);

    re = inbuff.ptr[i * 2];
    im = inbuff.ptr[i * 2 + 1];

    // complex mul
    inbuff.ptr[i * 2] = re * s_re - im * s_im;
    inbuff.ptr[i * 2 + 1] = re * s_im + s_re * im;

    i += 1;
);

fft_ipermute (inbuff.ptr, FFT_SIZE);
ifft (inbuff.ptr, FFT_SIZE);
ifft_rescale (inbuff.ptr, FFT_SIZE);

i = 0;
loop (FFT_SIZE,
  outbuff.ptr[i] = inbuff.ptr[i * 2];
  i += 1;
);

result.debug_32 (outbuff);

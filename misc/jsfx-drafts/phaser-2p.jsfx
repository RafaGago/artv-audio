desc:Artv phaser 2p (ZDF)

slider1:f_center=0.4<0, 1, 0.001>Freq Center(%)
slider2:f_width=0.5<0, 1, 0.001>Freq Width(%)
slider3:depth=0.5<0, 1, 0.001>Depth(%)
slider4:f_detune=0.9<0, 1, 0.001>Freq Detune(%)
slider5:f_mode=2<0, 10, 1>Range Curve

slider10:lfo_freq=0.25<0, 1, 0.001>Lfo Freq(%)
slider11:lfo_depth=0.85<0, 1, 0.001>Lfo Depth(%)
slider12:lfo_phase_diff=0<0, 1, 0.001>Lfo St Diff(%)

slider20:feedback=0.9<-1, 1, 0.001>Feedback(%)
slider21:hp=0.05<0, 1, 0.001>Feedback HP(%)
slider22:lp=0.1<0, 1, 0.001>Feedback LP(%)
slider23:bp=0.15<0, 1, 0.001>Feedback BP(%)
slider23:hardness=0.15<0, 15, 0.001>Hardness

slider33:n_stages=6<1, 16, 1>N Stages
slider36:mix=0.5<0, 1, 0.0001>Mix
slider37:trim_db=0<0, 30, 0.1>Trim(dB)
slider38:dc_block=0<0, 1, 1>DC blocker
slider39:onepole=0<0, 1, 1>Single Pole

in_pin:left input
in_pin:right input
out_pin:left output
out_pin:right output

import _delay-line.jsfx-inc
import _lfo.jsfx-inc
import _filters.jsfx-inc

@init

k.n_stages = 16;
k.n_channels = 2;

lfo.lfo_bank_init (k.n_channels, 1);
lfov.array_init (k.n_channels);

l_ap.ap_2p_cascade_init (16);
r_ap.ap_2p_cascade_init (16);

l_ap1.ap_1p_cascade_init (16);
r_ap1.ap_1p_cascade_init (16);

GS.array_init((k.n_stages + 3) * k.n_channels);
GS.array_init((k.n_stages + 3) * k.n_channels);

l_dc.tpt_1p_reset (20., srate);
r_dc.tpt_1p_reset (20., srate);

function get_zdf_sample(
  in, ap2*, ap1*, lshelf*, hshelf*, dc*, zdf*, k, h, dc_block, onepole, n_stages
  ) local (i, j, stages) global (GS.ptr)
(
  (dc_block == 1) ? (
    GS.ptr[0] = dc.tpt_1p_get_g_hp();
    GS.ptr[1] = dc.tpt_1p_get_s_hp();
  );
  i = 0;
  j = dc_block * 2;
  (onepole == 1) ? (
    loop(n_stages,
        GS.ptr[j]     = ap1.ap_1p_cascade_get_g (i);
        GS.ptr[j + 1] = ap1.ap_1p_cascade_get_s (i);
        j += 2;
        i += 1;
    );
  ) : (
    loop(n_stages,
        GS.ptr[j]     = ap2.ap_2p_cascade_get_g (i);
        GS.ptr[j + 1] = ap2.ap_2p_cascade_get_s (i);
        j += 2;
        i += 1;
    );
  ); 
  GS.ptr[j + 0] = lshelf.lshelf_1p_get_g();
  GS.ptr[j + 1] = lshelf.lshelf_1p_get_s();
  GS.ptr[j + 2] = hshelf.hshelf_1p_get_g();
  GS.ptr[j + 3] = hshelf.hshelf_1p_get_s();
  zdf.get_zdf_sqrt_sigmoid_before_fb_junction(
    in, k * 0.995, h, GS.ptr, n_stages + 2 + dc_block
    );
);

@slider 

lfo_hz = lfo_freq * lfo_freq * lfo_freq * 10;
lfo.lfo_bank_reset_freq (0, lfo_hz, srate);

lfo_phase_diff != lfo_phase_diff_prev ? (
  lfo_phase_diff_prev = lfo_phase_diff;
  lfo.lfo_bank_reset_phase (0, 0, 0);
  lfo.lfo_bank_reset_phase (0, 1, lfo_phase_diff);
);

norm_center = f_center * f_center * f_center * f_center;
loop(f_mode,
  norm_center *= f_center;
);

freq_hz = 40 + 20000 * norm_center;
// spread of 4 octaves maximum
freq_hi = exp (log(2) * 2 * f_width);
freq_lo = 1 / freq_hi;
freq_lo *= freq_hz;
freq_hi *= freq_hz;

factor = pow (freq_hi / freq_lo, 1. / n_stages);
trim = exp(-trim_db * log(10)/20);

fb_scaled = sqrt (abs (feedback));
lim_hardness = 1 / sqrt (hardness);
// the sigmoid is applying gain reduction. Compensate
g_hardness = (fb_scaled > lim_hardness) ? fb_scaled / lim_hardness : 1;
fb_scaled = (feedback < 0) ? -fb_scaled : fb_scaled;

s_depth = 0.008 + depth * depth * 10;
@sample

out0 = spl0;
out1 = spl1;

lfo.lfo_bank_tick_tri (lfov.ptr, 0);

lfov.ptr[0] = exp (lfov.ptr[0] * lfo_depth * 3.);
lfov.ptr[1] = exp (lfov.ptr[1] * lfo_depth * 3.);
lfo_l = lfov.ptr[0];
lfo_r = lfov.ptr[1];

detune = 0.3444 * f_detune;
detune_mul = -1 - 0.09 * f_detune;
freq = freq_lo;

out0 = get_zdf_sample(
  out0,
  l_ap,
  l_ap1,
  l_lshelf,
  l_hshelf,
  l_dc,
  l_zdf,
  fb_scaled,
  hardness,
  dc_block,
  onepole,
  n_stages);

out1 = get_zdf_sample(
  out1,
  r_ap,
  r_ap1,
  r_lshelf,
  r_hshelf,
  r_dc,
  r_zdf,
  fb_scaled,
  hardness,
  dc_block,
  onepole,  
  n_stages);

(dc_block == 1) ? (
  out0 = l_dc.tpt_1p_tick_hp (out0);
  out1 = l_dc.tpt_1p_tick_hp (out1);
);

i = 0;
loop (n_stages,
  freql = freq * lfo_l;
  freql *= 1 + detune;
  freql = max(freql, 1);
  freql = min(freql, 20000);
  freqr = freq * lfo_r;
  freqr *= 1 + detune;
  freqr = max(freqr, 1);
  freqr = min(freqr, 20000);
  freq *= factor;
  detune *= detune_mul;

  (onepole == 1) ? (
    l_ap1.ap_1p_cascade_reset_no_prewarp (i, freql, srate);
    r_ap1.ap_1p_cascade_reset_no_prewarp (i, freqr, srate);
    out0 = l_ap1.ap_1p_cascade_tick (i, out0);
    out1 = r_ap1.ap_1p_cascade_tick (i, out1);
  ) : (
    l_ap.ap_2p_cascade_reset_no_prewarp (i, freql, s_depth, srate);
    r_ap.ap_2p_cascade_reset_no_prewarp (i, freqr, s_depth, srate);
    out0 = l_ap.ap_2p_cascade_tick (i, out0);
    out1 = r_ap.ap_2p_cascade_tick (i, out1);
  );
  i += 1;
);

// modulate shelves on the feedback path
g_db = hp * -8;
fshelf = max (freq_lo, 160);
l_lshelf.lshelf_1p_reset_no_prewarp (fshelf, g_db, srate);
r_lshelf.lshelf_1p_reset_no_prewarp (fshelf, g_db, srate);

g_db = lp * -1.3;
fshelf = max (freq_hi * 2, 3700);
l_hshelf.hshelf_1p_reset_no_prewarp (fshelf, g_db, srate);
r_hshelf.hshelf_1p_reset_no_prewarp (fshelf, g_db, srate);

// tick shelves on the feedback path to update the states.
l_hshelf.hshelf_1p_tick (l_lshelf.lshelf_1p_tick (out0));
r_hshelf.hshelf_1p_tick (r_lshelf.lshelf_1p_tick (out1)); 

g_wet = mix * g_hardness;
g_dry = (1 - mix) * (1 + abs (fb_scaled));

spl0 = out0 * g_wet + spl0 * g_dry;
spl1 = out1 * g_wet + spl1 * g_dry;
spl0 *= trim;
spl1 *= trim;

spl0 = min (spl0, 6);
spl1 = min (spl1, 6);
spl0 = max (spl0, -6);
spl1 = max (spl1, -6);

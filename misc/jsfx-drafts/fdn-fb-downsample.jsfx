df  <desc:Downsampled FDN draft
//slider1:enable_impulse= 0   <0 ,2, 1{Off,Impulse,White noise}> Test
//slider2:mute=           0   <0, 1{Off,On}>    Reverb mute
slider3:rt60_msec=     3300 <10 ,12000 ,0.1>  RT60 (msec)
slider4:size_m=       22.09 <0.1, 70, 0.001>  Size1 (m)
//slider5:er_mix=          0  <0, 1, 0.01>      ER(%)
//slider6:er_2_late=      0.3 <0, 1, 0.01>      ER to late(%)
//slider7:late_mix=       0.6 <0, 1, 0.01>      late(%)
//slider8:chorus_freq=    0.3 <0, 5, 0.001>     Chorus Freq(Hz)
//slider9:chorus_depth=     0 <0, 1, 0.001>     Chorus Depth
//slider10:chorus_mix=      0 <-1, 1, 0.001>    Chorus Amt
//slider11:hf_absortion=  0.5 <0.0, 1, 0.001>   Damping
//slider12:n_density=       0 <0, 4, 1>         Density Inc
//slider13:n_diffusers=     0 <0, 8, 1>         Diffusors
//slider14:tilt=            0 <-0.5, 0.5, 0.01> Tilt
slider15:angle1=      0.5 <0.01, 0.99, 0.001> Angle1
slider16:angle2=      0.5 <0.01, 0.99, 0.001> Angle2
slider17:angle3=      0.5 <0.01, 0.99, 0.001> Angle3
slider18:angle4=      0.5 <0.01, 0.99, 0.001> Angle4

in_pin:left input
in_pin:right input
out_pin:left output
out_pin:right output

import _core.jsfx-inc
import _delay-line.jsfx-inc
import _filters.jsfx-inc
import _reverb.jsfx-inc
import _dynamics.jsfx-inc
import _lfo.jsfx-inc
import _fir.jsfx-inc

@init

GOLDEN_RATIO = (1 + sqrt(5)) / 2;
// -----------------------------------------------------------------------------
// Resource initialization
// -----------------------------------------------------------------------------

// Sample rate conversion ------------------------------------------------------

k.src.kaiser_att_db = 120;
k.src.taps_branch = 64;
k.src.cutoff = 9000;
src.ratio = (srate / 44100) | 0;
src.ratio *= 2;
src.ratio_mask = src.ratio - 1;
src.srate = srate / src.ratio;

get_kaiser_lp_kernel(
  src.kernel,
  k.src.cutoff,
  srate,
  src.ratio * k.src.taps_branch,
  k.src.kaiser_att_db,
  0,
  1
  );

src.down.fir_2ch_decimator_init (src.kernel, src.ratio);
src.up.fir_2ch_interpolator_init (src.kernel, src.ratio);

src.ins.array_init (src.ratio * 2); // interleaved ins
src.outs.array_init (src.ratio * 2); // interleaved outs
src.spls.array_init (2);

src.ins.array_clear();
src.outs.array_clear();
src.spls.array_clear();

// Late feedback ---------------------------------------------------------------
k.late.n_channels = 16;
k.late.delay.prime_idx = 15;
k.late.delay.rounding_factor = 1;
k.late.delay.span_factor = GOLDEN_RATIO * 2   ;

late.delay_spls.array_init (k.late.n_channels);
late.rt60_att.array_init (k.late.n_channels);
late.signal.array_init (k.late.n_channels);
late.feedback.array_init (k.late.n_channels);

late.delay.delay_line_init(
  round_next_pow2 (src.srate), late.signal.size
  );
late.delay.delay_line_thiran2_add (src.srate); // disable thiran resync

late.k.delay_preset.array2d_init (1, k.late.n_channels);

late.k.delay_preset.array2d_ptr(0)[0] = 829;
late.k.delay_preset.array2d_ptr(0)[1] = 947;
late.k.delay_preset.array2d_ptr(0)[2] = 1051;
late.k.delay_preset.array2d_ptr(0)[3] = 1171;
late.k.delay_preset.array2d_ptr(0)[4] = 1289;
late.k.delay_preset.array2d_ptr(0)[5] = 1427;
late.k.delay_preset.array2d_ptr(0)[6] = 1523;
late.k.delay_preset.array2d_ptr(0)[7] = 1621;
late.k.delay_preset.array2d_ptr(0)[8] = 1753;
late.k.delay_preset.array2d_ptr(0)[9] = 1879;
late.k.delay_preset.array2d_ptr(0)[10] = 2011;
late.k.delay_preset.array2d_ptr(0)[11] = 2131;
late.k.delay_preset.array2d_ptr(0)[12] = 2269;
late.k.delay_preset.array2d_ptr(0)[13] = 2381;
late.k.delay_preset.array2d_ptr(0)[14] = 2521;
late.k.delay_preset.array2d_ptr(0)[15] = 2659;

freembuf (_memtop_ptr); // tell the Host how much memory we need.

// DC blockers -----------------------------------------------------------------
k.dc.cutoff_freq = 5;

dc.a.dc_blocker_init (k.dc.cutoff_freq, src.srate);
dc.b.dc_blocker_init (k.dc.cutoff_freq, src.srate);
dc.c.dc_blocker_init (k.dc.cutoff_freq, src.srate);
dc.d.dc_blocker_init (k.dc.cutoff_freq, src.srate);
dc.e.dc_blocker_init (k.dc.cutoff_freq, src.srate);
dc.f.dc_blocker_init (k.dc.cutoff_freq, src.srate);
dc.g.dc_blocker_init (k.dc.cutoff_freq, src.srate);
dc.h.dc_blocker_init (k.dc.cutoff_freq, src.srate);

dc.i.dc_blocker_init (k.dc.cutoff_freq, src.srate);
dc.j.dc_blocker_init (k.dc.cutoff_freq, src.srate);
dc.k.dc_blocker_init (k.dc.cutoff_freq, src.srate);
dc.l.dc_blocker_init (k.dc.cutoff_freq, src.srate);
dc.m.dc_blocker_init (k.dc.cutoff_freq, src.srate);
dc.n.dc_blocker_init (k.dc.cutoff_freq, src.srate);
dc.o.dc_blocker_init (k.dc.cutoff_freq, src.srate);
dc.p.dc_blocker_init (k.dc.cutoff_freq, src.srate);

@slider //----------------------------------------------------------------------
get_delay_length_samples(
  late.delay_spls.ptr,
  k.late.n_channels,
  size_m,
  size_m * k.late.delay.span_factor,
  k.late.delay.prime_idx ,
  k.late.delay.rounding_factor,
  src.srate
  );

(1) ? ( 
// using a preset
memcpy (late.delay_spls.ptr, late.k.delay_preset.array2d_ptr(0), k.late.n_channels);
);

get_rt60_gain(
  late.rt60_att.ptr,
  late.delay_spls.ptr,
  rt60_msec * 0.001,
  0 ,
  k.late.n_channels,
  src.srate
  );

late.mtx.w1_a = cos (2 * angle1 * $pi * 0.25);
late.mtx.w2_a = sin (2 * angle1 * $pi * 0.25);
late.mtx.w1_b = cos (2 * angle2 * $pi * 0.25);
late.mtx.w2_b = sin (2 * angle2 * $pi * 0.25);
late.mtx.w1_c = cos (2 * angle3 * $pi * 0.25);
late.mtx.w2_c = sin (2 * angle3 * $pi * 0.25);
late.mtx.w1_d = cos (2 * angle4 * $pi * 0.25);
late.mtx.w2_d = sin (2 * angle4 * $pi * 0.25);

@block //-----------------------------------------------------------------------

@sample //----------------------------------------------------------------------

function dc_blockers_x16_tick (dc*, sig*)
  global ()(
  sig.ptr[0] = dc.a.dc_blocker_tick (sig.ptr[0]);
  sig.ptr[1] = dc.b.dc_blocker_tick (sig.ptr[1]);
  sig.ptr[2] = dc.c.dc_blocker_tick (sig.ptr[2]);
  sig.ptr[3] = dc.d.dc_blocker_tick (sig.ptr[3]);
  sig.ptr[4] = dc.e.dc_blocker_tick (sig.ptr[4]);
  sig.ptr[5] = dc.f.dc_blocker_tick (sig.ptr[5]);
  sig.ptr[6] = dc.g.dc_blocker_tick (sig.ptr[6]);
  sig.ptr[7] = dc.h.dc_blocker_tick (sig.ptr[7]);

  sig.ptr[8]  = dc.i.dc_blocker_tick (sig.ptr[8]);
  sig.ptr[9]  = dc.j.dc_blocker_tick (sig.ptr[9]);
  sig.ptr[10] = dc.k.dc_blocker_tick (sig.ptr[10]);
  sig.ptr[11] = dc.l.dc_blocker_tick (sig.ptr[11]);
  sig.ptr[12] = dc.m.dc_blocker_tick (sig.ptr[12]);
  sig.ptr[13] = dc.n.dc_blocker_tick (sig.ptr[13]);
  sig.ptr[14] = dc.o.dc_blocker_tick (sig.ptr[14]);
  sig.ptr[15] = dc.p.dc_blocker_tick (sig.ptr[15]);
);

src.pos = spl.counter & src.ratio_mask;

src.offset = src.pos * 2;

src.ins.ptr[src.offset] = spl0;
src.ins.ptr[src.offset + 1] = spl1;

spl0 = src.outs.ptr[src.offset];
spl1 = src.outs.ptr[src.offset + 1];

// enough samples to proceed downsampling and running an iteration
src.pos == src.ratio_mask ? (

  src.down.fir_2ch_decimator_tick (src.spls.ptr, src.ins.ptr);

  in.l = src.spls.ptr[0];
  in.r = src.spls.ptr[1];

  in.m = (in.l + in.r) * 0.5;
  in.s = (in.l - in.r) * 0.5;

  late.signal.array_clear();
  late.signal.ptr[3]  = in.m * 0.5;
  late.signal.ptr[4]  = in.m * 0.5;
  late.signal.ptr[2]  = ins.s;

  range_add(
    late.signal.ptr, late.signal.ptr, late.feedback.ptr, late.signal.size
    );

  tmp.sig_cp.array_init (late.signal.size);
  memcpy (tmp.sig_cp.ptr, late.signal.ptr, late.signal.size);
  rot_matrix_16(
    late.signal.ptr,
    tmp.sig_cp.ptr,
    late.mtx.w1_a,
    late.mtx.w2_a,
    late.mtx.w1_b,
    late.mtx.w2_b,
    late.mtx.w1_c,
    late.mtx.w2_c,
    late.mtx.w1_d,
    late.mtx.w2_d
    );
  tmp.sig_cp.array_shrink(0); // return memory (used as a stack).

  memcpy (late.feedback.ptr, late.signal.ptr, late.signal.size);

  late.delay.delay_line_advance();
  late.delay.delay_line_set_all (late.feedback.ptr, 0);
  late.delay.delay_line_get_all (late.feedback.ptr, late.delay_spls.ptr);
  dc_blockers_x16_tick (dc, late.feedback.ptr);
  range_mul(
    late.feedback.ptr, late.feedback.ptr, late.rt60_att.ptr, late.feedback.size
  );

  debug_16 (late.delay_spls.ptr);

  late.r = late.signal.ptr[6];
  late.l = late.signal.ptr[7];

  out.l = late.l;
  out.r = late.r;

  src.up.fir_2ch_interpolator_tick (src.outs.ptr, out.l, out.r);
  spl.op_rate_counter += 1; // operating rate counter
);
spl.counter += 1; // plugin rate counter

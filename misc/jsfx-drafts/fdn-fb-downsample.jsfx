 desc:Downsampled FDN draft
//slider1:enable_impulse= 0   <0 ,2, 1{Off,Impulse,White noise}> Test
//slider2:mute=           0   <0, 1{Off,On}>    Reverb mute
slider3:rt60_msec=     3300 <10 ,12000 ,0.1>  RT60 (msec)
slider4:size_m=       22.09 <1.2, 70, 0.001>  Size1 (m)
//slider5:er_mix=          0  <0, 1, 0.01>      ER(%)
//slider6:er_2_late=      0.3 <0, 1, 0.01>      ER to late(%)
//slider7:late_mix=       0.6 <0, 1, 0.01>      late(%)
//slider8:chorus_freq=    0.3 <0, 5, 0.001>     Chorus Freq(Hz)
//slider9:chorus_depth=     0 <0, 1, 0.001>     Chorus Depth
//slider10:chorus_mix=      0 <-1, 1, 0.001>    Chorus Amt
//slider12:n_density=       0 <0, 4, 1>         Density Inc
//slider13:n_diffusers=     0 <0, 8, 1>         Diffusors
//slider14:tilt=            0 <-0.5, 0.5, 0.01> Tilt
slider15:angle1=      0.5 <0.1, 0.9, 0.001> L Angle
slider16:angle2=      0.5 <0.1, 0.9, 0.001> R Angle
slider17:angle3=      0.5 <0.1, 0.9, 0.001> L-R Angle
slider19:diffusion=   0.6 <0, 0.77, 0.001> Diffusion
slider20:width=       0.5 <0, 1, 0.01> Width
slider21:damp=        0.5 <0.0, 0.90, 0.001> Damping

in_pin:left input
in_pin:right input
out_pin:left output
out_pin:right output

import _core.jsfx-inc
import _delay-line.jsfx-inc
import _filters.jsfx-inc
import _reverb.jsfx-inc
import _dynamics.jsfx-inc
import _lfo.jsfx-inc
import _fir.jsfx-inc

@init


GOLDEN_RATIO = (1 + sqrt(5)) / 2;
// -----------------------------------------------------------------------------
// Resource initialization
// -----------------------------------------------------------------------------

// Sample rate conversion ------------------------------------------------------

// gcd of 44100 and 48000 is 300. Choosing a target samplerate multiple of 300
// will minimize the memory requirements for the fractional resampler on both.
// 30000 seems a good candidate samplerate for a reverb, 15KHz BW should be
// enough for a reverb.
//
// 36000 is more friendly to 44100 multiples though. 27000 seems good too, but
// 13.5K might start being dark.

k.src.kaiser_att_db = 210;
k.src.taps_branch = 32;
k.src.taps_branch_frac = 16;
k.src.cutoff = 9000;
k.src.srate = 27000;

BYPASS_SRC = 0;

src.down.resampler_2c_init(
  k.src.srate,
  srate,
  k.src.taps_branch,
  k.src.taps_branch_frac,
  k.src.cutoff,
  k.src.kaiser_att_db,
  1
  );

src.up.resampler_2c_init(
  srate,
  k.src.srate,
  k.src.taps_branch,
  k.src.taps_branch_frac,
  k.src.cutoff,
  k.src.kaiser_att_db,
  1
  );

src.out_q.deque_init(
  src.up.resampler_2c_max_n_out_samples() * 2
  );

src.ins.array_init (src.down.resampler_2c_max_n_out_samples() * 2);
src.outs.array_init (src.up.resampler_2c_max_n_out_samples() * 2);

src.ins.array_clear();
src.outs.array_clear();

// TODO how many?
loop(floor (srate / 44100) * 2,
  src.out_q.deque_push(0);
  src.out_q.deque_push(0);
);

// Freeverb diffussor ----------------------------------------------------------

BYPASS_FREEVERB_DIFFUSOR = 1;

k.combs.n_diffusors = 8;

combs.l.delay_line_init (round_next_pow2 (k.src.srate), k.combs.n_diffusors);
combs.l.delay_line_lp_comb_add();

combs.r.delay_line_init (round_next_pow2 (k.src.srate), k.combs.n_diffusors);
combs.r.delay_line_lp_comb_add();

k.combs.n_spls.array_init (k.combs.n_diffusors);
k.combs.n_spls.ptr[0] = ((1116 * k.src.srate) / 44100) | 0;
k.combs.n_spls.ptr[1] = ((1188 * k.src.srate) / 44100) | 0;
k.combs.n_spls.ptr[2] = ((1277 * k.src.srate) / 44100) | 0;
k.combs.n_spls.ptr[3] = ((1356 * k.src.srate) / 44100) | 0;
k.combs.n_spls.ptr[4] = ((1422 * k.src.srate) / 44100) | 0;
k.combs.n_spls.ptr[5] = ((1491 * k.src.srate) / 44100) | 0;
k.combs.n_spls.ptr[6] = ((1557 * k.src.srate) / 44100) | 0;
k.combs.n_spls.ptr[7] = ((1617 * k.src.srate) / 44100) | 0;

combs.l_spls.array_init (k.combs.n_diffusors);
combs.r_spls.array_init (k.combs.n_diffusors);

// Late/Tail feedback ----------------------------------------------------------

function late_delay_spls_reorder (spls_ptr, spls_size) global()(
  // from ascending order to an U shape ordering.

  this.tmp.array_init (spls_size);
  memcpy (this.tmp.ptr, spls_ptr, spls_size);

  spls_ptr[0]  = this.tmp.ptr[15];
  spls_ptr[1]  = this.tmp.ptr[13];
  spls_ptr[2]  = this.tmp.ptr[11];
  spls_ptr[3]  = this.tmp.ptr[9];
  spls_ptr[4]  = this.tmp.ptr[7];
  spls_ptr[5]  = this.tmp.ptr[5];
  spls_ptr[6]  = this.tmp.ptr[3];
  spls_ptr[7]  = this.tmp.ptr[1];
  spls_ptr[8]  = this.tmp.ptr[0];
  spls_ptr[9]  = this.tmp.ptr[2];
  spls_ptr[10] = this.tmp.ptr[4];
  spls_ptr[11] = this.tmp.ptr[6];
  spls_ptr[12] = this.tmp.ptr[8];
  spls_ptr[13] = this.tmp.ptr[10];
  spls_ptr[14] = this.tmp.ptr[12];
  spls_ptr[15] = this.tmp.ptr[14];

  this.tmp.array_size_drop_to (0);
);

BYPASS_TAIL = 0;

k.late.n_channels = 16;
k.late.delay.prime_idx = 15;
k.late.delay.rounding_factor = 1;
k.late.delay.span_factor = GOLDEN_RATIO * 1.5;

late.delay_spls.array_init (k.late.n_channels);
late.rt60_att.array_init (k.late.n_channels);
late.signal.array_init (k.late.n_channels);
late.feedback.array_init (k.late.n_channels);

late.delay.delay_line_init(
  round_next_pow2 (k.src.srate), k.late.n_channels
  );
late.delay.delay_line_thiran2_add (k.src.srate); // disable thiran resync

late.k.delay_preset.array2d_init (1, k.late.n_channels);

late.k.delay_preset.array2d_ptr(0)[0]  = 911;
late.k.delay_preset.array2d_ptr(0)[1]  = 967;
late.k.delay_preset.array2d_ptr(0)[2]  = 1181;
late.k.delay_preset.array2d_ptr(0)[3]  = 1103;
late.k.delay_preset.array2d_ptr(0)[4]  = 1289;
late.k.delay_preset.array2d_ptr(0)[5]  = 1307;
late.k.delay_preset.array2d_ptr(0)[6]  = 1669;
late.k.delay_preset.array2d_ptr(0)[7]  = 1553;
late.k.delay_preset.array2d_ptr(0)[8]  = 1753;
late.k.delay_preset.array2d_ptr(0)[9]  = 1877;
late.k.delay_preset.array2d_ptr(0)[10] = 2131;
late.k.delay_preset.array2d_ptr(0)[11] = 2017;
late.k.delay_preset.array2d_ptr(0)[12] = 2647;
late.k.delay_preset.array2d_ptr(0)[13] = 2411;
late.k.delay_preset.array2d_ptr(0)[14] = 2957;
late.k.delay_preset.array2d_ptr(0)[15] = 2837;

late_delay_spls_reorder (late.k.delay_preset.array2d_ptr(0), k.late.n_channels);

// Output Diffusion ------------------------------------------------------------

BYPASS_DIFFUSOR = 0;

k.dif.n_diffusors = 4;

k.dif.n_spls.array2d_init (2, k.dif.n_diffusors);

k.dif.n_spls.array2d_ptr(0)[0] = 137;
k.dif.n_spls.array2d_ptr(0)[1] = 337;
k.dif.n_spls.array2d_ptr(0)[2] = 272;
k.dif.n_spls.array2d_ptr(0)[3] = 207;
k.dif.n_spls.array2d_ptr(1)[0] = 137;
k.dif.n_spls.array2d_ptr(1)[1] = 337;
k.dif.n_spls.array2d_ptr(1)[2] = 271;
k.dif.n_spls.array2d_ptr(1)[3] = 207;

dif.l.delay_line_init (round_next_pow2 (k.src.srate), k.dif.n_diffusors);
dif.l.delay_line_allpass_add();

dif.r.delay_line_init (round_next_pow2 (k.src.srate), k.dif.n_diffusors);
dif.r.delay_line_allpass_add();

k.dif.g.array2d_init (2, k.dif.n_diffusors);

// DC blockers -----------------------------------------------------------------
k.dc.cutoff_freq = 5;

dc.a.dc_blocker_init (k.dc.cutoff_freq, k.src.srate);
dc.b.dc_blocker_init (k.dc.cutoff_freq, k.src.srate);
dc.c.dc_blocker_init (k.dc.cutoff_freq, k.src.srate);
dc.d.dc_blocker_init (k.dc.cutoff_freq, k.src.srate);
dc.e.dc_blocker_init (k.dc.cutoff_freq, k.src.srate);
dc.f.dc_blocker_init (k.dc.cutoff_freq, k.src.srate);
dc.g.dc_blocker_init (k.dc.cutoff_freq, k.src.srate);
dc.h.dc_blocker_init (k.dc.cutoff_freq, k.src.srate);

dc.i.dc_blocker_init (k.dc.cutoff_freq, k.src.srate);
dc.j.dc_blocker_init (k.dc.cutoff_freq, k.src.srate);
dc.k.dc_blocker_init (k.dc.cutoff_freq, k.src.srate);
dc.l.dc_blocker_init (k.dc.cutoff_freq, k.src.srate);
dc.m.dc_blocker_init (k.dc.cutoff_freq, k.src.srate);
dc.n.dc_blocker_init (k.dc.cutoff_freq, k.src.srate);
dc.o.dc_blocker_init (k.dc.cutoff_freq, k.src.srate);
dc.p.dc_blocker_init (k.dc.cutoff_freq, k.src.srate);

@slider //----------------------------------------------------------------------
get_delay_length_samples(
  late.delay_spls.ptr,
  k.late.n_channels,
  size_m,
  size_m * k.late.delay.span_factor,
  k.late.delay.prime_idx ,
  k.late.delay.rounding_factor,
  k.src.srate
  );

late_delay_spls_reorder (late.delay_spls.ptr, late.delay_spls.size);
(1) ? (
// using a preset
  memcpy(
    late.delay_spls.ptr,
    late.k.delay_preset.array2d_ptr(0),
    k.late.n_channels
    );
);

get_rt60_gain(
  late.rt60_att.ptr,
  late.delay_spls.ptr,
  rt60_msec * 0.001,
  0,
  k.late.n_channels,
  k.src.srate
  );

G = diffusion *  0.9;
k.dif.g.array2d_ptr(0)[0] = G;
k.dif.g.array2d_ptr(0)[1] = G - 0.4;
k.dif.g.array2d_ptr(0)[2] = G - 0.2;
k.dif.g.array2d_ptr(0)[3] = G;
dif.l.delay_line_allpass_set_g_all (k.dif.g.array2d_ptr (0));

k.dif.g.array2d_ptr(1)[0] = G;
k.dif.g.array2d_ptr(1)[1] = G - 0.4;
k.dif.g.array2d_ptr(1)[2] = G - 0.2;
k.dif.g.array2d_ptr(1)[3] = G;
dif.r.delay_line_allpass_set_g_all (k.dif.g.array2d_ptr (1));

i = 0;
combs.l_spls.array_copy (k.combs.n_spls);
combs.r_spls.array_copy (k.combs.n_spls);
loop (k.combs.n_diffusors,
  tmp.fact = i / k.combs.n_diffusors;
  combs.l.delay_line_lp_comb_set_damp (damp * damp + 0.07 * tmp.fact, i);
  combs.r.delay_line_lp_comb_set_damp (damp * damp + 0.05 * tmp.fact, i);
  combs.l.delay_line_lp_comb_set_g (sqrt (diffusion), i);
  combs.r.delay_line_lp_comb_set_g (sqrt (diffusion), i);
  combs.r_spls.ptr[i] += primes.ptr[i % 4] * width * i < 4 ? -4 : 4;
  combs.r_spls.ptr[i] |= 0;
  i += 1;
);

late.mtx.w1_a = cos (2 * angle1 * $pi * 0.25);
late.mtx.w2_a = sin (2 * angle1 * $pi * 0.25);
late.mtx.w1_b = cos (2 * angle2 * $pi * 0.25);
late.mtx.w2_b = sin (2 * angle2 * $pi * 0.25);
late.mtx.w1_c = cos (2 * angle3 * $pi * 0.25);
late.mtx.w2_c = sin (2 * angle3 * $pi * 0.25);

@block //-----------------------------------------------------------------------

@sample //----------------------------------------------------------------------

function dc_blockers_x16_tick (dc*, sig*)
  global ()(
  sig.ptr[0] = dc.a.dc_blocker_tick (sig.ptr[0]);
  sig.ptr[1] = dc.b.dc_blocker_tick (sig.ptr[1]);
  sig.ptr[2] = dc.c.dc_blocker_tick (sig.ptr[2]);
  sig.ptr[3] = dc.d.dc_blocker_tick (sig.ptr[3]);
  sig.ptr[4] = dc.e.dc_blocker_tick (sig.ptr[4]);
  sig.ptr[5] = dc.f.dc_blocker_tick (sig.ptr[5]);
  sig.ptr[6] = dc.g.dc_blocker_tick (sig.ptr[6]);
  sig.ptr[7] = dc.h.dc_blocker_tick (sig.ptr[7]);

  sig.ptr[8]  = dc.i.dc_blocker_tick (sig.ptr[8]);
  sig.ptr[9]  = dc.j.dc_blocker_tick (sig.ptr[9]);
  sig.ptr[10] = dc.k.dc_blocker_tick (sig.ptr[10]);
  sig.ptr[11] = dc.l.dc_blocker_tick (sig.ptr[11]);
  sig.ptr[12] = dc.m.dc_blocker_tick (sig.ptr[12]);
  sig.ptr[13] = dc.n.dc_blocker_tick (sig.ptr[13]);
  sig.ptr[14] = dc.o.dc_blocker_tick (sig.ptr[14]);
  sig.ptr[15] = dc.p.dc_blocker_tick (sig.ptr[15]);
);

BYPASS_SRC == 0 ? (
  n_spls_down = src.down.resampler_2c_tick (src.ins.ptr, spl0, spl1);
) : (
  n_spls_down = 1;
  src.ins.ptr[0] = spl0;
  src.ins.ptr[1] = spl1;
);

(n_spls_down) ? (
  // time to run DSP at operating SR, we know that "src.frac_down" is a
  // downsampler, so "n_spls_down" will always be 0 or 1

  in.l = src.ins.ptr[0];
  in.r = src.ins.ptr[1];

  in.m = (in.l + in.r) * 0.5;
  in.s = (in.l - in.r) * 0.5;

  dif.l = in.l;
  dif.r = in.r;

  BYPASS_FREEVERB_DIFFUSOR == 0 ? (
    dif.l = combs.l.delay_line_lp_comb_tick_tapped_parallel_all(
      dif.l, 2, combs.l_spls.ptr
      );
    dif.r = combs.r.delay_line_lp_comb_tick_tapped_parallel_all(
      dif.r, 2, combs.r_spls.ptr
    );
  );

  combs.l_spls_v.debug_8(combs.l_spls);

  late.signal.array_clear();
  late.signal.ptr[0] = dif.r;
  late.signal.ptr[15] = dif.l;

  range_add(
    late.signal.ptr, late.signal.ptr, late.feedback.ptr, late.signal.size
    );

  tmp.sig_cp1.array_duplicate (late.signal);
  // L
  rot_matrix_8(
    late.signal.ptr,
    tmp.sig_cp1.ptr,
    late.mtx.w1_a,
    late.mtx.w2_a
  );
  // R
  rot_matrix_8(
    late.signal.ptr + 8,
    tmp.sig_cp1.ptr + 8,
    late.mtx.w1_b,
    late.mtx.w2_b
  );
  // Cross
  tmp.sig_cp1.array_copy (late.signal);
  rot_matrix_8 (
    late.signal.ptr + 4, tmp.sig_cp1.ptr + 4, late.mtx.w1_c, late.mtx.w2_c
    );

  tmp.sig_cp1.array_size_drop_to(0); // return memory (used as a stack).

  late.feedback.array_copy (late.signal);

  late.delay.delay_line_advance();
  late.delay.delay_line_set_all (late.feedback.ptr, 0);
  late.delay.delay_line_get_all (late.feedback.ptr, late.delay_spls.ptr);
  dc_blockers_x16_tick (dc, late.feedback);
  range_mul(
    late.feedback.ptr, late.feedback.ptr, late.rt60_att.ptr, late.feedback.size
  );

  // invert l and r, one taken from a long delay, the other from a short
  late.l = late.signal.ptr[11];
  late.r = late.signal.ptr[4];

  BYPASS_TAIL == 0 ? (
    out.l = late.l;
    out.r = late.r;
  ) : (
    out.l = dif.l;
    out.r = dif.r;
  );
  
  // modulate this fella...
  BYPASS_DIFFUSOR == 0 ? (
    out.l += dif.l.delay_line_allpass_tick_cascade_all(
       out.l, k.dif.n_diffusors, k.dif.n_spls.array2d_ptr (0)
       ) * (0.7 * diffusion + 0.01);
     out.r -= dif.r.delay_line_allpass_tick_cascade_all(
       out.r, k.dif.n_diffusors, k.dif.n_spls.array2d_ptr (1)
     ) * (0.7 * diffusion + 0.01);
  );

  spl_op_rate_counter += 1; // operating rate counter

  BYPASS_SRC == 0 ? (
    // upsampling
    n_spls_up = src.up.resampler_2c_tick (src.outs.ptr, out.l, out.r);
    i = 0;
    loop (n_spls_up * 2, // *2 : two channels
      src.out_q.deque_push (src.outs.ptr[i]);
      i += 1;
    );
  ):(
    src.out_q.deque_push (out.l);
    src.out_q.deque_push (out.r);
  );
);

spl0 = src.out_q.deque_pop();
spl1 = src.out_q.deque_pop();

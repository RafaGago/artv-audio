desc:Resampler test

slider1:ratio=1.75<0.25,2.,0.25>Ratio
slider2:taps=64<4,1024,1>Taps
slider3:att=100.<0,300,1>Att
slider4:cutoff=0.95<0.8,1,0.01>Cutoff

import _core.jsfx-inc
import _fir.jsfx-inc

@init

// hack to not consume extra memory, normally these filters have fixed
// parameters and are intialized on @init (setting)

realloc_memtop = _memtop_ptr;

@slider

_memtop_ptr = realloc_memtop;

norm_cutoff = cutoff * 0.5;
tgt_process_rate = srate * ratio;

// cutoff at the target rate when downsampling
stage1.sinc_resampler_2c_init(
  tgt_process_rate,
  srate,
  taps,
  norm_cutoff,
  kaiser_beta_estimate (att)
  );
// cutoff near nyquist when upsampling
stage2.sinc_resampler_2c_init(
  srate,
  tgt_process_rate,
  taps,
  norm_cutoff,
  kaiser_beta_estimate (att)
  );

// N * 2 (channels)
max_spls_stage_1 = stage1.sinc_resampler_2c_max_n_out_samples() * 2;
max_spls_stage_2 = stage2.sinc_resampler_2c_max_n_out_samples() * 2;

//  2 because we start with N zero samples, as fractional rates
// may have a 1 sample jitter on the count of number of samples returned.
outs.deque_init (max (max_spls_stage_2, max_spls_stage_1) * 2);
//loop (max (max_spls_stage_1, max_spls_stage_2),
//  outs.deque_push (0);
//);

// 2: N channels
stage1_buff.array_init (max_spls_stage_1);
stage2_buff.array_init (max_spls_stage_2);

(1 && ratio == 0.5) ? (
  oversmpl = 2;

  frac = taps % 2 == 0 ? 1 / pow (2, oversmpl  * 4) : 0.;
  //frac = taps % 2 == 0 ? -0.5 : 0.;
  get_kaiser_lp_kernel(
    os_kernel, srate * cutoff * 0.25, srate, taps, att, frac, 0
    );
  fir_down.fir_2ch_decimator_init (os_kernel, oversmpl);
  fir_up.fir_2ch_interpolator_init (os_kernel, oversmpl);
  fir_down_in.array_init (2 * 2);
);

@sample

(0 && ratio == 0.5) ? (
  // debug FIR
  ((spl_count & 1) == 0) ? (
    fir_down_in.ptr[2] = spl0;
    fir_down_in.ptr[3] = spl1;
    fir_down.fir_2ch_decimator_tick (stage1_buff.ptr, fir_down_in.ptr);
    fir_up.fir_2ch_interpolator_tick(
      stage2_buff.ptr, stage1_buff.ptr[0], stage1_buff.ptr[1]
      );
    outs.deque_push (stage2_buff.ptr[0]);
    outs.deque_push (stage2_buff.ptr[1]);
    outs.deque_push (stage2_buff.ptr[2]);
    outs.deque_push (stage2_buff.ptr[3]);
  ) : (
    fir_down_in.ptr[0] = spl0;
    fir_down_in.ptr[1] = spl1;
  );
  n_spls_1 = 0;
) : (
  stage1_buff.array_clear();
  n_spls_1 = stage1.sinc_resampler_2c_tick (stage1_buff.ptr, spl0, spl1);
);

spl_idx = 0;
loop (n_spls_1,
  stage2_buff.array_clear();
  n_spls_2 = stage2.sinc_resampler_2c_tick(
    stage2_buff.ptr, stage1_buff.ptr[spl_idx], stage1_buff.ptr[spl_idx + 1]
    );
  i = 0;
  loop (n_spls_2 * 2, // *2 : two channels
    outs.deque_push (stage2_buff.ptr[i]);
    i += 1;
  );
  n_spls_2 = 0;
  spl_idx += 2;
);

spl0 = outs.deque_pop();
spl1 = outs.deque_pop();

spl_count += 1;

desc:Artv phaser 1p (ZDF)

slider1:f_center=0.4<0, 1, 0.001>Freq Center(%)
slider2:f_width=0.5<0, 1, 0.001>Freq Width(%)
slider4:f_detune=0.9<0, 1, 0.001>Freq Detune(%)
slider5:f_mode=2<0, 10, 1>Range Curve

slider10:lfo_freq=0.25<0, 1, 0.001>Lfo Freq(%)
slider11:lfo_depth=0.85<0, 1, 0.001>Lfo Depth(%)
slider12:lfo_phase_diff=0<0, 1, 0.001>Lfo St Diff(%)

slider20:feedback=0.9<-1, 1, 0.001>Feedback(%)
slider21:hp=0.05<0, 1, 0.001>Feedback HP(%)
slider22:lp=0.1<0, 1, 0.001>Feedback LP(%)
slider23:bp=0.15<0, 1, 0.001>Feedback BP(%)
slider23:hardness=0.18<0, 15, 0.001>Hardness (%)

slider33:n_stages=6<1, 16, 1>N Stages
slider36:mix=0.5<0, 1, 0.0001>Mix
slider37:trim_db=0<0, 30, 0.1>Trim(dB)

in_pin:left input
in_pin:right input
out_pin:left output
out_pin:right output

import _delay-line.jsfx-inc
import _lfo.jsfx-inc
import _filters.jsfx-inc

@init

k.n_stages = 16;
k.n_channels = 2;

lfo.lfo_bank_init (k.n_channels, 1);
lfov.array_init (k.n_channels);

l_ap.ap_1p_cascade_init (16);
r_ap.ap_1p_cascade_init (16);

GS.array_init((k.n_stages + 2) * k.n_channels);

@slider

lfo_hz = lfo_freq * lfo_freq * lfo_freq * 10;
lfo.lfo_bank_reset_freq (0, lfo_hz, srate);

lfo_phase_diff != lfo_phase_diff_prev ? (
  lfo_phase_diff_prev = lfo_phase_diff;
  lfo.lfo_bank_reset_phase (0, 0, 0);
  lfo.lfo_bank_reset_phase (0, 1, lfo_phase_diff);
);

norm_center = f_center * f_center * f_center * f_center;
loop(f_mode,
  norm_center *= f_center;
);

freq_hz = 40 + 20000 * norm_center;
// spread of 4 octaves maximum
freq_hi = exp (log(2) * 2 * f_width);
freq_lo = 1 / freq_hi;
freq_lo *= freq_hz;
freq_hi *= freq_hz;

factor = pow (freq_hi / freq_lo, 1. / n_stages);
trim = exp(-trim_db * log(10)/20);

fb_scaled = sqrt (abs (feedback));
lim_hardness = 1 / sqrt (hardness);
// the sigmoid is applying gain reduction. Compensate
g_hardness = (fb_scaled > lim_hardness) ? fb_scaled / lim_hardness : 1;
fb_scaled = (feedback < 0) ? -fb_scaled : fb_scaled;

@sample

out0 = spl0;
out1 = spl1;

lfo.lfo_bank_tick_tri (lfov.ptr, 0);

lfov.ptr[0] = exp (lfov.ptr[0] * lfo_depth * 3.);
lfov.ptr[1] = exp (lfov.ptr[1] * lfo_depth * 3.);
lfo_l = lfov.ptr[0];
lfo_r = lfov.ptr[1];

detune = 0.3444 * f_detune;
detune_mul = -1 - 0.09 * f_detune;
freq = freq_lo;

//n_stages = 0;

// Compute feedback loop L
i = 0;
j = 0;
loop(n_stages,
    GS.ptr[j]     = l_ap.ap_1p_cascade_get_g (i);
    GS.ptr[j + 1] = l_ap.ap_1p_cascade_get_s (i);
    j += 2;
    i += 1;
);

GS.ptr[n_stages * 2 + 0] = l_lshelf.lshelf_1p_get_g();
GS.ptr[n_stages * 2 + 1] = l_lshelf.lshelf_1p_get_s();
GS.ptr[n_stages * 2 + 2] = l_hshelf.hshelf_1p_get_g();
GS.ptr[n_stages * 2 + 3] = l_hshelf.hshelf_1p_get_s();
out0 = l_zdf.get_zdf_sqrt_sigmoid_before_fb_junction(
  out0, fb_scaled * 0.995, hardness, GS.ptr, n_stages + 2
  );

// Compute feedback loop R
i = 0;
j = 0;
loop(n_stages,
    GS.ptr[j]     = r_ap.ap_1p_cascade_get_g (i);
    GS.ptr[j + 1] = r_ap.ap_1p_cascade_get_s (i);
    j += 2;
    i += 1;
);
GS.ptr[n_stages * 2 + 0] = r_lshelf.lshelf_1p_get_g();
GS.ptr[n_stages * 2 + 1] = r_lshelf.lshelf_1p_get_s();
GS.ptr[n_stages * 2 + 2] = r_hshelf.hshelf_1p_get_g();
GS.ptr[n_stages * 2 + 3] = r_hshelf.hshelf_1p_get_s();
out1 = r_zdf.get_zdf_sqrt_sigmoid_before_fb_junction(
  out1, fb_scaled * 0.995, hardness, GS.ptr, n_stages + 2
  );

i = 0;
loop (n_stages,
  freql = freq * lfo_l;
  freql *= 1 + detune;
  freql = max(freql, 1);
  freql = min(freql, 20000);
  freqr = freq * lfo_r;
  freqr *= 1 + detune;
  freqr = max(freqr, 1);
  freqr = min(freqr, 20000);
  freq *= factor;
  detune *= detune_mul;

  l_ap.ap_1p_cascade_reset_no_prewarp (i, freql, srate);
  r_ap.ap_1p_cascade_reset_no_prewarp (i, freqr, srate);
  out0 = l_ap.ap_1p_cascade_tick (i, out0);
  out1 = r_ap.ap_1p_cascade_tick (i, out1);
  i += 1;
);

(1) ? (
// modulate shelves on the feedback path
g_db = hp * -8;
fshelf = max (freq_lo, 160);
l_lshelf.lshelf_1p_reset_no_prewarp (fshelf, g_db, srate);
r_lshelf.lshelf_1p_reset_no_prewarp (fshelf, g_db, srate);

g_db = lp * -1.3;
fshelf = max (freq_hi * 2, 3700);
l_hshelf.hshelf_1p_reset_no_prewarp (fshelf, g_db, srate);
r_hshelf.hshelf_1p_reset_no_prewarp (fshelf, g_db, srate);

// tick shelves on the feedback path to update the states.
l_hshelf.hshelf_1p_tick (l_lshelf.lshelf_1p_tick (out0));
r_hshelf.hshelf_1p_tick (r_lshelf.lshelf_1p_tick (out1));

// TODO: BP?
);

g_wet = mix * g_hardness;
g_dry = (1 - mix) * (1 + abs (fb_scaled));

spl0 = out0 * g_wet + spl0 * g_dry;
spl1 = out1 * g_wet + spl1 * g_dry;
spl0 *= trim;
spl1 *= trim;

spl0 = min (spl0, 6);
spl1 = min (spl1, 6);
spl0 = max (spl0, -6);
spl1 = max (spl1, -6);

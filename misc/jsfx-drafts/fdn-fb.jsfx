desc:fdn diffusor with er_feedback  draft
slider1:enable_impulse= 0 <0 ,2, 1{Off,Impulse,White noise}> Test
slider2:mute=           0 <0, 1{Off,On}>     Reverb mute
slider3:rt60_msec=      300 <10 ,12000 ,0.1> RT60 (msec)
slider4:size_m=         3 <0.1, 70, 0.001>   Size1 (m)
slider5:er_mix=         0.3 <0, 1, 0.01>     ER(%)
slider6:er_2_late=      0.3 <0, 1, 0.01>     ER to late(%)
slider7:late_mix=       0.3 <0, 1, 0.01>     late(%)
slider8:chorus_freq=    0.3 <0, 5, 0.001>    Chorus Freq(Hz)
slider9:chorus_depth=   0.3 <0, 1, 0.001>    Chorus Depth
slider10:chorus_mix=    0   <-1, 1, 0.001>   Chorus Amt
slider11:hf_absortion=  0.5 <0.0, 1, 0.001>  Damping
slider12:n_density=     0. <0, 4, 1>         Density Inc
slider13:n_diffusers=   0. <0, 8, 1>         Diffusors
slider14:tilt=          0. <-1, 1, 0.01>     Tilt
slider15:base_angle=    0. <0, 0.7853981633974483, 0.00000001> Angle

in_pin:left input
in_pin:right input
out_pin:left output
out_pin:right output

import _core.jsfx-inc
import _delay-line.jsfx-inc
import _filters.jsfx-inc
import _reverb.jsfx-inc
import _lfo.jsfx-inc

/*
To try:

-Notch EQ on the feedback loop (modulation?).
-Nested FDN
-Time reversed allpasses
-Depending on the algo, the range of the LFO AMT might change.
-Diferent algos can have diferent matrices.
-rs-met kronecker matrices.
 https://www.kvraudio.com/forum/viewtopic.php?t=123095&start=45
-With the size parameter, make some channels lose weight and others to win.
-Multiband reverb (Allows lower frequencies at lower sr).
-Input crossover (remove more LF).
-Bigger matrices.
-Chorus interpolation, catmull-ROM will sound different at another SR.

-Wow factor stereo.
-Tweak the schroeder allpasses in series increase decrease density.
-Fix now-broken ER. Add constants.
 
*/
@init

GOLDEN_RATIO = (1 + sqrt(5)) / 2;

// memory areas for free usage -------------------------------------------------
SCRATCH_MEM_AREA_SIZE = 32;

scratch1.array_init (SCRATCH_MEM_AREA_SIZE);
scratch2.array_init (SCRATCH_MEM_AREA_SIZE);
scratch3.array_init (SCRATCH_MEM_AREA_SIZE);
scratch4.array_init (SCRATCH_MEM_AREA_SIZE);

// -----------------------------------------------------------------------------
// Resource initialization
// -----------------------------------------------------------------------------
N_ER_CHNLS = 16;
N_LATE_CHNLS = 8;
N_DENSITY_STAGES = 4;
N_CHNLS_LATE_DENSITY = 4;

DC_BLOCKER_FREQ = 4;

// parameter/setting ideas:
// ER pan/width

// per algorithm params (Future)
ER_DECAY_SEC = 0.5;
ER_SIZE_MIN = 3.5;
ER_SIZE_MAX = 69;
ER_DELAY_PRIME_IDX = 0;
ER_DELAY_ROUNDING_FACTOR = 1;

LFO_DEPTH_MAX = 0.05;

LATE_DENSITY_1_RATIO = 1 / 3;
LATE_DENSITY_2_RATIO = 1 / 7;
LATE_DENSITY_3_RATIO = 1 / 5;
LATE_DENSITY_4_RATIO = 1 / 11;

LATE_N_DIFFUSERS = 8;
LATE_DIFFUSERS_TO_MAIN_RATIO = 1 / 100;
LATE_DIFFUSERS_START_FREQ = 2460;
LATE_DIFFUSERS_FREQ_FACTOR = pow (2, 0.02/12);

// every 64 samples att 44100
CONTROL_RATE_MASK = (((srate / 44100) | 0) * 64) - 1;
CONTROL_RATE_FACT = (CONTROL_RATE_MASK  + 1);

LATE_DELAY_RATIO = 1.8;
LATE_DELAY_PRIME_IDX = 23;
LATE_DELAY_ROUNDING_FACTOR = 100;

LATE_RND_LFO_FREQ = 5;

LATE_MATRIX_LFO_FREQ = 0.11;
LATE_MATRIX_LFO_DEPTH = 0.02;

LATE_SUB_MATRIX_LFO_FREQ = 0.1;
LATE_SUB_MATRIX_LFO_DEPTH = 0.03;

LATE_CHORUS_TO_FB = 1;
loop(1,
  LATE_HSHELF1_FREQ = 1200;
  LATE_HSHELF2_FREQ = 1400;
  LATE_HSHELF3_FREQ = 1800;
  LATE_HSHELF4_FREQ = 2100;
  LATE_HSHELF5_FREQ = 2500;
  LATE_HSHELF6_FREQ = 3134;
  LATE_HSHELF7_FREQ = 4698;
  LATE_HSHELF8_FREQ = 8000;

  LATE_HSHELF1_Q = 0.4;
  LATE_HSHELF2_Q = 0.4;
  LATE_HSHELF3_Q = 0.5;
  LATE_HSHELF4_Q = 0.5;
  LATE_HSHELF5_Q = 0.6;
  LATE_HSHELF6_Q = 0.6;
  LATE_HSHELF7_Q = 0.7;
  LATE_HSHELF8_Q = 0.8;

  LATE_HSHELF1_GAIN_FACT = 0.1;
  LATE_HSHELF2_GAIN_FACT = 0.14;
  LATE_HSHELF3_GAIN_FACT = 0.35;
  LATE_HSHELF4_GAIN_FACT = 0.5;
  LATE_HSHELF5_GAIN_FACT = 0.7;
  LATE_HSHELF6_GAIN_FACT = 0.8;
  LATE_HSHELF7_GAIN_FACT = 0.85;
  LATE_HSHELF8_GAIN_FACT = 1;
);
LATE_TILT_FREQ = 400;
LATE_TILT_BW = 6;
LATE_TILT_ORDER = 8;

//LATE_MATRIX_ANGLE = ($pi / 4) - 0.18;
//LATE_COS_PHI = cos (LATE_MATRIX_ANGLE);
//LATE_SIN_PHI = sin (LATE_MATRIX_ANGLE);

// ER
er_chnls.array_init (N_ER_CHNLS);
er_feedback.array_init (er_chnls.size);
er_rt60_att.array_init (er_chnls.size);
er_delay_spls.array_init (er_chnls.size);

get_delay_length_samples(
    er_delay_spls.ptr,
    er_chnls.size,
    ER_SIZE_MIN,
    ER_SIZE_MAX,
    ER_DELAY_PRIME_IDX,
    ER_DELAY_ROUNDING_FACTOR
    );

max_er_delay_spl = range_get_max (er_delay_spls.ptr, er_chnls.size);
er_delay.delay_line_init (round_next_pow2 (max_er_delay_spl), er_chnls.size);

get_rt60_gain(
    er_rt60_att.ptr, er_delay_spls.ptr, ER_DECAY_SEC, 0.3, er_chnls.size
    );

// Late
chnls.array_init (N_LATE_CHNLS);
chorus.array_init (chnls.size);
feedback.array_init (chnls.size);
rt60_att.array_init (chnls.size);
delay_spls.array_init (chnls.size);
density_spls.array2d_init (N_CHNLS_LATE_DENSITY, N_DENSITY_STAGES);
diffusor_spls.array_init (LATE_N_DIFFUSERS);
mod_spls.array_init (chnls.size);


lfos.lfo_bank_init (chnls.size, chnls.size);
lfos.lfo_bank_reset_phase (0);
// 1 sec max. It will have to be computed from the maximum sizes on the final
// impl.
delay.delay_line_init (round_next_pow2 (srate), chnls.size);
delay.delay_line_thiran2_add (srate); // disable thiran resync

diffusor_l.delay_line_init (round_next_pow2 (srate), diffusor_spls.size);
diffusor_l.delay_line_schroeder_ap_add();

diffusor_r.delay_line_init (round_next_pow2 (srate), diffusor_spls.size);
diffusor_r.delay_line_schroeder_ap_add();

density1.delay_line_init (
  round_next_pow2 (srate * LATE_DENSITY_1_RATIO), N_CHNLS_LATE_DENSITY
  );
density1.delay_line_thiran2_add (srate); // disable thiran resync

density2.delay_line_init(
  round_next_pow2 (srate * LATE_DENSITY_2_RATIO), N_CHNLS_LATE_DENSITY
  );
density2.delay_line_thiran2_add (srate); // disable thiran resync

density3.delay_line_init (
  round_next_pow2 (srate * LATE_DENSITY_3_RATIO), N_CHNLS_LATE_DENSITY
  );
density3.delay_line_thiran2_add (srate); // disable thiran resync

density4.delay_line_init(
  round_next_pow2 (srate * LATE_DENSITY_4_RATIO), N_CHNLS_LATE_DENSITY
  );
density4.delay_line_thiran2_add (srate); // disable thiran resync

// 1P allpasses (will cause cancellations on the matrix)
ap_freq.array_init (chnls.size);
ap_freq.ptr[0] = 7902.133;
ap_freq.ptr[1] = 7458.620;
ap_freq.ptr[2] = 7040.000;
ap_freq.ptr[3] = 6644.875;
ap_freq.ptr[4] = 5587.652;
ap_freq.ptr[5] = 5274.041;
ap_freq.ptr[6] = 5919.911;
ap_freq.ptr[7] = 6271.927;
ap_1.tpt_1p_reset (ap_freq.ptr[0], srate);
ap_2.tpt_1p_reset (ap_freq.ptr[1], srate);
ap_3.tpt_1p_reset (ap_freq.ptr[2], srate);
ap_4.tpt_1p_reset (ap_freq.ptr[3], srate);
ap_5.tpt_1p_reset (ap_freq.ptr[4], srate);
ap_6.tpt_1p_reset (ap_freq.ptr[5], srate);
ap_7.tpt_1p_reset (ap_freq.ptr[6], srate);
ap_8.tpt_1p_reset (ap_freq.ptr[7], srate);

rnd_lfo_1.lfo_filt_noise_init (LATE_RND_LFO_FREQ * 2 / N_LATE_CHNLS, srate);
rnd_lfo_2.lfo_filt_noise_init(
  (LATE_RND_LFO_FREQ * GOLDEN_RATIO * 2) / N_LATE_CHNLS, srate
  );
matrix_lfo.lfo_filt_noise_init (LATE_MATRIX_LFO_FREQ, srate);
submatrix_lfo.lfo_filt_noise_init (LATE_SUBMATRIX_LFO_FREQ, srate);

dc1.dc_blocker_init (DC_BLOCKER_FREQ, srate);
dc2.dc_blocker_init (DC_BLOCKER_FREQ, srate);
dc3.dc_blocker_init (DC_BLOCKER_FREQ, srate);
dc4.dc_blocker_init (DC_BLOCKER_FREQ, srate);
dc5.dc_blocker_init (DC_BLOCKER_FREQ, srate);
dc6.dc_blocker_init (DC_BLOCKER_FREQ, srate);
dc7.dc_blocker_init (DC_BLOCKER_FREQ, srate);
dc8.dc_blocker_init (DC_BLOCKER_FREQ, srate);

dc9.dc_blocker_init (DC_BLOCKER_FREQ, srate);
dc10.dc_blocker_init (DC_BLOCKER_FREQ, srate);
dc11.dc_blocker_init (DC_BLOCKER_FREQ, srate);
dc12.dc_blocker_init (DC_BLOCKER_FREQ, srate);
dc13.dc_blocker_init (DC_BLOCKER_FREQ, srate);
dc14.dc_blocker_init (DC_BLOCKER_FREQ, srate);
dc15.dc_blocker_init (DC_BLOCKER_FREQ, srate);
dc16.dc_blocker_init (DC_BLOCKER_FREQ, srate);

loop(1,
  hshelf_freq.array_init (chnls.size);
  hshelf_db.array_init (chnls.size);
  hshelf_freq.ptr[0] = LATE_HSHELF1_FREQ;
  hshelf_freq.ptr[1] = LATE_HSHELF2_FREQ;
  hshelf_freq.ptr[2] = LATE_HSHELF3_FREQ;
  hshelf_freq.ptr[3] = LATE_HSHELF4_FREQ;
  hshelf_freq.ptr[4] = LATE_HSHELF5_FREQ;
  hshelf_freq.ptr[5] = LATE_HSHELF6_FREQ;
  hshelf_freq.ptr[6] = LATE_HSHELF7_FREQ;
  hshelf_freq.ptr[7] = LATE_HSHELF8_FREQ;

  hshelf1.svf_hshelf (200, 1, 0, srate);
  hshelf2.svf_hshelf (200, 1, 0, srate);
  hshelf3.svf_hshelf (200, 1, 0, srate);
  hshelf4.svf_hshelf (200, 1, 0, srate);
  hshelf5.svf_hshelf (200, 1, 0, srate);
  hshelf6.svf_hshelf (200, 1, 0, srate);
  hshelf7.svf_hshelf (200, 1, 0, srate);
  hshelf8.svf_hshelf (200, 1, 0, srate);
);
loop(0,
  LATE_DAMP_ORDER = 4;
  damp1a.sptilt_init (LATE_DAMP_ORDER);
  damp2a.sptilt_init (LATE_DAMP_ORDER);
  damp1b.sptilt_init (LATE_DAMP_ORDER);
  damp2b.sptilt_init (LATE_DAMP_ORDER);
);


tilt1.sptilt_init (LATE_TILT_ORDER);
tilt2.sptilt_init (LATE_TILT_ORDER);

// trigger signals
test_next = counter + 1;

freembuf (_memtop_ptr); // tell the Host how much memory we need.

@slider //----------------------------------------------------------------------

get_delay_length_samples(
  delay_spls.ptr,
  delay_spls.size,
  size_m,
  size_m * LATE_DELAY_RATIO,
  LATE_DELAY_PRIME_IDX,
  LATE_DELAY_ROUNDING_FACTOR
  );

get_delay_length_samples(
  density_spls.array2d_ptr(0),
  density_spls.size_a,
  size_m * LATE_DENSITY_1_RATIO,
  size_m * LATE_DELAY_RATIO * LATE_DENSITY_1_RATIO,
  LATE_DELAY_PRIME_IDX,
  LATE_DELAY_ROUNDING_FACTOR
  );

get_delay_length_samples(
  density_spls.array2d_ptr(1),
  density_spls.size_a,
  size_m * LATE_DENSITY_2_RATIO,
  size_m * LATE_DELAY_RATIO * LATE_DENSITY_2_RATIO,
  LATE_DELAY_PRIME_IDX,
  LATE_DELAY_ROUNDING_FACTOR
  );

get_delay_length_samples(
  density_spls.array2d_ptr(2),
  density_spls.size_a,
  size_m * LATE_DENSITY_3_RATIO,
  size_m * LATE_DELAY_RATIO * LATE_DENSITY_1_RATIO,
  LATE_DELAY_PRIME_IDX,
  LATE_DELAY_ROUNDING_FACTOR
  );

get_delay_length_samples(
  density_spls.array2d_ptr(3),
  density_spls.size_a,
  size_m * LATE_DENSITY_4_RATIO,
  size_m * LATE_DELAY_RATIO * LATE_DENSITY_2_RATIO,
  LATE_DELAY_PRIME_IDX,
  LATE_DELAY_ROUNDING_FACTOR
  );

i = 0;
loop (delay_spls.size / 2,
    mem_swap (delay_spls.ptr, i, i + (delay_spls.size / 2));
    i += 1;
);

mem_swap (density_spls.array2d_ptr(0), 1, 2);
mem_swap (density_spls.array2d_ptr(1), 1, 2);
mem_swap (density_spls.array2d_ptr(2), 1, 2);
mem_swap (density_spls.array2d_ptr(3), 1, 2);

get_delay_length_samples(
  diffusor_spls.ptr,
  diffusor_spls.size,
  size_m * LATE_DIFFUSERS_TO_MAIN_RATIO,
  size_m * LATE_DELAY_RATIO * LATE_DIFFUSERS_TO_MAIN_RATIO,
  0,
  LATE_DELAY_ROUNDING_FACTOR * 1000000
  );

i = 0;
f = LATE_DIFFUSERS_START_FREQ;
loop (diffusor_spls.size,
    coeff = freq_to_schroeder_coeff (f, srate);
    diffusor_l.delay_line_schroeder_set_coeff (coeff, i);
    diffusor_r.delay_line_schroeder_set_coeff (coeff * 0.9, i);
    f *= LATE_DIFFUSERS_FREQ_FACTOR;
    i += 1;
);

// readjust total size

i = 0;
loop (n_density,
    dst_ptr = delay_spls.ptr + 4 * (i & 1);
    range_sub(
      dst_ptr, dst_ptr, density_spls.array2d_ptr (i), density_spls.size_a
      );
    i += 1;
);


range_clamp (delay_spls.ptr, delay_spls.size, 0, delay.mask);

// YOLO linear empirical/perceptual correction. TODO: adjust channel-wise
rt60_corr = (rt60_msec * 0.001) * (1 + (hf_absortion * 0.85));

get_rt60_gain(
  rt60_att.ptr, delay_spls.ptr, rt60_corr, 0.1, chnls.size
  );
range_mul_k(
  mod_spls.ptr,
  delay_spls.ptr,
  chorus_depth * chorus_depth * LFO_DEPTH_MAX,
  chnls.size
  );

i = 0;
loop (chnls.size,
    lfos.lfo_bank_reset_freq (0, i, chorus_freq + chorus_freq * i * 0.0001);
    i += 1;
);

loop(1,
  // Hiself decays
  hshelf_db_raw = -5 * hf_absortion;

  hshelf_db.ptr[0] = LATE_HSHELF1_GAIN_FACT * hshelf_db_raw;
  hshelf_db.ptr[1] = LATE_HSHELF2_GAIN_FACT * hshelf_db_raw;
  hshelf_db.ptr[2] = LATE_HSHELF3_GAIN_FACT * hshelf_db_raw;
  hshelf_db.ptr[3] = LATE_HSHELF4_GAIN_FACT * hshelf_db_raw;
  hshelf_db.ptr[4] = LATE_HSHELF5_GAIN_FACT * hshelf_db_raw;
  hshelf_db.ptr[5] = LATE_HSHELF6_GAIN_FACT * hshelf_db_raw;
  hshelf_db.ptr[6] = LATE_HSHELF7_GAIN_FACT * hshelf_db_raw;
  hshelf_db.ptr[7] = LATE_HSHELF8_GAIN_FACT * hshelf_db_raw;
);
loop(0,
  LATE_DAMP1_FREQ = 20;
  LATE_DAMP1_BW = 7.82;
  LATE_DAMP2_FREQ = 300;
  LATE_DAMP2_BW = 4.33;

  damp1a.sptilt_reset (LATE_DAMP1_FREQ, LATE_DAMP1_BW, -hf_absortion * 0.05, srate);
  damp1b.sptilt_reset (LATE_DAMP1_FREQ, LATE_DAMP1_BW, -hf_absortion * 0.05, srate);
  damp2a.sptilt_reset (LATE_DAMP2_FREQ, LATE_DAMP2_BW, -hf_absortion * 0.05, srate);
  damp2b.sptilt_reset (LATE_DAMP2_FREQ, LATE_DAMP2_BW, -hf_absortion * 0.05, srate);
);


chorus_fact = chorus_mix * chorus_mix * sign (chorus_mix);

tilt1.sptilt_reset_as_tilt_eq (LATE_TILT_FREQ, LATE_TILT_BW, tilt, srate);
tilt2.sptilt_reset_as_tilt_eq (LATE_TILT_FREQ, LATE_TILT_BW, tilt, srate);

// TODO: make a constant
matrix_cos_phi = cos (base_angle);
matrix_sin_phi = sin (base_angle);

@block //-----------------------------------------------------------------------

@sample //----------------------------------------------------------------------

// autogenerate a periodic impulse.
counter >= test_next ? (
   enable_impulse == 1 ? (spl0 = spl1 = 1.);
   enable_impulse == 2 ? (
    on_noise = 1;
    test_off = counter + srate * 0.2;
   );
   test_next += rt60_msec * 0.001 * srate;
);

(on_noise != 0) ? (
  spl0 = spl1 = (rand (2) - 1) * 0.1;
  on_noise = (counter < test_off) ? 1 : 0;
);


l = spl0;
r = spl1;
m = (l + r) * 0.5;
s = (l - r) * 0.5;

transients = transient.transient_gate_tick (spl0, spl1) * 0.05;

// ER ------------------------
er_chnls.ptr[0] =  -l;
er_chnls.ptr[1] =   r;
er_chnls.ptr[2] =  -m;
er_chnls.ptr[3] =   s * 8;
er_chnls.ptr[4] =   l;
er_chnls.ptr[5] =  -r;
er_chnls.ptr[6] =   m;
er_chnls.ptr[7] =  -s * 8;
er_chnls.ptr[8] =  -l;
er_chnls.ptr[9] =   r;
er_chnls.ptr[10] = -m;
er_chnls.ptr[11] =  s * 8;
er_chnls.ptr[12] =  l;
er_chnls.ptr[13] = -r;
er_chnls.ptr[14] =  m;
er_chnls.ptr[15] = -s * 8;

range_add (er_chnls.ptr, er_chnls.ptr, er_feedback.ptr, er_chnls.size);

er_delay.delay_line_advance();
er_delay.delay_line_set_all (er_chnls.ptr, 0);
er_delay.delay_line_get_all (er_chnls.ptr, er_delay_spls.ptr);

// mix the faster channels, leave the ones with longer delays more separate.
hadamard_4 (er_feedback.ptr, er_chnls.ptr);
hadamard_4 (er_feedback.ptr + 4, er_chnls.ptr + 4);
memcpy (scratch1.ptr, er_feedback.ptr, er_chnls.size);
householder (er_feedback.ptr, scratch1.ptr, er_chnls.size);
range_mul (er_feedback.ptr, er_feedback.ptr, er_rt60_att.ptr, er_chnls.size);

er_sig_l = er_chnls.ptr[0] + er_chnls.ptr[5] + er_chnls.ptr[9]  + er_chnls.ptr[12];
er_sig_r = er_chnls.ptr[1] + er_chnls.ptr[4] + er_chnls.ptr[8]  + er_chnls.ptr[13];
er_sig_l *= (1 / 4);
er_sig_r *= (1 / 4);

er_l = er_sig_l * er_mix;
er_r = er_sig_r * er_mix;

er_tail = (er_sig_l + er_sig_r) * 0.5 * er_2_late;

// Tail ------------------------
m_s = m + s;

m_s = diffusor_l.delay_line_schroeder_tick_tapped_cascade(
  m_s, n_diffusers, diffusor_spls.ptr
  );
er_tail = diffusor_r.delay_line_schroeder_tick_tapped_cascade(
  er_tail, n_diffusers, diffusor_spls.ptr
  );

m_s = tilt1.sptilt_tick (m_s);
er_tail = tilt2.sptilt_tick (er_tail);


chnls.ptr[0] =  0;
chnls.ptr[1] =  0;
chnls.ptr[2] =  m * 0.5;
chnls.ptr[3] =  m * 0.5;
chnls.ptr[4] =  s;
chnls.ptr[5] =  0;
chnls.ptr[6] =  er_tail * 0.5;
chnls.ptr[7] =  er_tail * 0.5;

range_add (chnls.ptr, chnls.ptr, feedback.ptr, chnls.size);

density_l = 0;
density_r = 0;

smlfo_val = matrix_lfo.lfo_filt_noise_tick();
((counter & CONTROL_RATE_MASK) == 0) ? ( 
  sangle = base_angle * (1 + smlfo_val * LATE_SUBMATRIX_LFO_DEPTH);
  smatrix_cos_phi = cos (angle);
  smatrix_sin_phi = sin (angle);
);

// Density stages
n_density >= 1 ? (
  density1_io.array_alias (scratch1);
  memcpy (density1_io.ptr, chnls.ptr, density_spls.size_a);
  density1.delay_line_advance();
  density1.delay_line_set_all (density1_io.ptr, 0);
  density1.delay_line_thiran2_get_all (density1_io.ptr, density_spls.array2d_ptr(0));
  unitary_matrix_4 (chnls.ptr, density1_io.ptr, smatrix_cos_phi, smatrix_sin_phi);
);

n_density >= 2 ? (
  density2_io.array_alias (scratch1);
  memcpy (density2_io.ptr, chnls.ptr + 4, density_spls.size_a);
  density2.delay_line_advance();
  density2.delay_line_set_all (density2_io.ptr, 0);
  density2.delay_line_thiran2_get_all (density2_io.ptr, density_spls.array2d_ptr(1));
  hadamard_4 (chnls.ptr + 4, density2_io.ptr);
);

n_density >= 3 ? (
  density3_io.array_alias (scratch1);
  memcpy (density3_io.ptr, chnls.ptr, density_spls.size_a);
  density3.delay_line_advance();
  density3.delay_line_set_all (density3_io.ptr, 0);
  density3.delay_line_thiran2_get_all (density3_io.ptr, density_spls.array2d_ptr(2));
  unitary_matrix_4 (chnls.ptr, density3_io.ptr, smatrix_cos_phi, smatrix_sin_phi);
);

n_density >= 4 ? (
  density4_io.array_alias (scratch1);
  memcpy (density4_io.ptr, chnls.ptr + 4, density_spls.size_a);
  density4.delay_line_advance();
  density4.delay_line_set_all (density4_io.ptr, 0);
  density4.delay_line_thiran2_get_all (density4_io.ptr, density_spls.array2d_ptr(3));
  hadamard_4 (chnls.ptr + 4, density4_io.ptr);
);

// LFO
mod_delay_spls.array_alias (scratch4);
lfo_out.array_alias (scratch3);

// Delay line + chorus
lfos.lfo_bank_tick_sin (lfo_out.ptr, 0);
range_mul (mod_delay_spls.ptr, lfo_out.ptr, mod_spls.ptr, chnls.size);
range_add (mod_delay_spls.ptr, mod_delay_spls.ptr, delay_spls.ptr, chnls.size);
delay.delay_line_advance();
delay.delay_line_set_all (chnls.ptr, 0);

//delay.delay_line_thiran2_get_all (chorus.ptr, mod_delay_spls.ptr);
delay.delay_line_get_catmull_rom_interp_all (chorus.ptr, mod_delay_spls.ptr);

mlfo_val = matrix_lfo.lfo_filt_noise_tick();
((counter & CONTROL_RATE_MASK) == 0) ? ( 
  angle = base_angle * (1 + mlfo_val * LATE_MATRIX_LFO_DEPTH);
  matrix_cos_phi = cos (angle);
  matrix_sin_phi = sin (angle);
);

//unitary_matrix_8 (scratch2.ptr, chorus.ptr, matrix_cos_phi, matrix_sin_phi);
rochebois_8 (scratch2.ptr, chorus.ptr);
memcpy (chorus.ptr, scratch2.ptr, chnls.size);

loop(1,
  chorus.ptr[0] = dc1.dc_blocker_tick (chorus.ptr[0]);
  chorus.ptr[1] = dc2.dc_blocker_tick (chorus.ptr[1]);
  chorus.ptr[2] = dc3.dc_blocker_tick (chorus.ptr[2]);
  chorus.ptr[3] = dc4.dc_blocker_tick (chorus.ptr[3]);
  chorus.ptr[4] = dc5.dc_blocker_tick (chorus.ptr[4]);
  chorus.ptr[5] = dc6.dc_blocker_tick (chorus.ptr[5]);
  chorus.ptr[6] = dc7.dc_blocker_tick (chorus.ptr[6]);
  chorus.ptr[7] = dc8.dc_blocker_tick (chorus.ptr[7]);
);

LATE_CHORUS_TO_FB ? (
  memcpy (chnls.ptr, chorus.ptr, chnls.size);
) : (
  delay.delay_line_thiran2_get_all  (chnls.ptr, delay_spls.ptr);
  rochebois_8 (scratch2.ptr, chnls.ptr);
  memcpy (chnls.ptr, scratch2.ptr, chnls.size);
);

loop (1, // just to be able to comment out fast...
  // These will still cause cancellations on the matrix when the damping
  // is at 0.
  mod_ap_freq.array_alias (scratch2);
  ((counter & CONTROL_RATE_MASK) == 0) ? (
    i = 0;
    loop (chnls.size,
      lfoval = i & 1 ?
        rnd_lfo_1.lfo_filt_noise_tick() : rnd_lfo_2.lfo_filt_noise_tick();
      mod_ap_freq.ptr[i] = exp (lfoval * 0.001) * ap_freq.ptr[i];
      i += 1;
    );
    ap_1.tpt_1p_reset (mod_ap_freq.ptr[0], srate);
    ap_2.tpt_1p_reset (mod_ap_freq.ptr[1], srate);
    ap_3.tpt_1p_reset (mod_ap_freq.ptr[2], srate);
    ap_4.tpt_1p_reset (mod_ap_freq.ptr[3], srate);
    ap_5.tpt_1p_reset (mod_ap_freq.ptr[4], srate);
    ap_6.tpt_1p_reset (mod_ap_freq.ptr[5], srate);
    ap_7.tpt_1p_reset (mod_ap_freq.ptr[6], srate);
    ap_8.tpt_1p_reset (mod_ap_freq.ptr[7], srate);
  );

  chnls.ptr[0] = ap_1.tpt_1p_tick_ap (chnls.ptr[0]);
  chnls.ptr[1] = ap_2.tpt_1p_tick_ap (chnls.ptr[1]);
  chnls.ptr[2] = ap_3.tpt_1p_tick_ap (chnls.ptr[2]);
  chnls.ptr[3] = ap_4.tpt_1p_tick_ap (chnls.ptr[3]);
  chnls.ptr[4] = ap_5.tpt_1p_tick_ap (chnls.ptr[4]);
  chnls.ptr[5] = ap_6.tpt_1p_tick_ap (chnls.ptr[5]);
  chnls.ptr[6] = ap_7.tpt_1p_tick_ap (chnls.ptr[6]);
  chnls.ptr[7] = ap_8.tpt_1p_tick_ap (chnls.ptr[7]);

  loop (0,
    // AM at constant power. This ads an echoy tremolo and resonances, 
    // probably needs its own lfo.
    left = exp (lfoval  *  0.005);
    right = exp (lfoval * -0.005);
    chnls.ptr[0] *= right;
    chnls.ptr[1] *= left;
    chnls.ptr[2] *= right;
    chnls.ptr[3] *= left;
    chnls.ptr[4] *= right;
    chnls.ptr[5] *= left;
    chnls.ptr[6] *= right;
    chnls.ptr[7] *= left;
  );
);

loop(1, // just to be able to comment fast...
  mod_lshf_freq.array_alias (scratch2);
  ((counter & CONTROL_RATE_MASK) == 0) ? (
    i = 0;
    loop (chnls.size,
      lfoval = i & 1 ?
        rnd_lfo_1.lfo_filt_noise_tick() : rnd_lfo_2.lfo_filt_noise_tick();
      mod_lshf_freq.ptr[i] = exp (lfoval * 0.01) * hshelf_freq.ptr[i];
      i += 1;
    );
    hshelf1.svf_hshelf(
      mod_lshf_freq.ptr[0], LATE_HSHELF1_Q, hshelf_db.ptr[0], srate
      );
    hshelf2.svf_hshelf(
      mod_lshf_freq.ptr[1], LATE_HSHELF2_Q, hshelf_db.ptr[1], srate
      );
    hshelf3.svf_hshelf(
      mod_lshf_freq.ptr[2], LATE_HSHELF3_Q, hshelf_db.ptr[2], srate
      );
    hshelf4.svf_hshelf(
      mod_lshf_freq.ptr[3], LATE_HSHELF4_Q, hshelf_db.ptr[3], srate
      );
    hshelf5.svf_hshelf(
      mod_lshf_freq.ptr[4], LATE_HSHELF5_Q, hshelf_db.ptr[4], srate
      );
    hshelf6.svf_hshelf(
      mod_lshf_freq.ptr[5], LATE_HSHELF6_Q, hshelf_db.ptr[5], srate
      );
    hshelf7.svf_hshelf(
      mod_lshf_freq.ptr[6], LATE_HSHELF7_Q, hshelf_db.ptr[6], srate
      );
    hshelf8.svf_hshelf(
      mod_lshf_freq.ptr[7], LATE_HSHELF8_Q, hshelf_db.ptr[7], srate
      );
  );

  chnls.ptr[0] = hshelf1.svf_tick (chnls.ptr[0]);
  chnls.ptr[1] = hshelf2.svf_tick (chnls.ptr[1]);
  chnls.ptr[2] = hshelf3.svf_tick (chnls.ptr[2]);
  chnls.ptr[3] = hshelf4.svf_tick (chnls.ptr[3]);
  chnls.ptr[4] = hshelf5.svf_tick (chnls.ptr[4]);
  chnls.ptr[5] = hshelf6.svf_tick (chnls.ptr[5]);
  chnls.ptr[6] = hshelf7.svf_tick (chnls.ptr[6]);
  chnls.ptr[7] = hshelf8.svf_tick (chnls.ptr[7]);
);
loop(0,
  chnls.ptr[2] = damp1a.sptilt_tick (chnls.ptr[2]);
  chnls.ptr[3] = damp1b.sptilt_tick (chnls.ptr[3]);

  chnls.ptr[0] = damp2a.sptilt_tick (chnls.ptr[0]);
  chnls.ptr[1] = damp2b.sptilt_tick (chnls.ptr[1]);
);

loop(0,
  chnls.ptr[0] = dc9.dc_blocker_tick (chnls.ptr[0]);
  chnls.ptr[1] = dc10.dc_blocker_tick (chnls.ptr[1]);
  chnls.ptr[2] = dc11.dc_blocker_tick (chnls.ptr[2]);
  chnls.ptr[3] = dc12.dc_blocker_tick (chnls.ptr[3]);
  chnls.ptr[4] = dc13.dc_blocker_tick (chnls.ptr[4]);
  chnls.ptr[5] = dc14.dc_blocker_tick (chnls.ptr[5]);
  chnls.ptr[6] = dc15.dc_blocker_tick (chnls.ptr[6]);
  chnls.ptr[7] = dc16.dc_blocker_tick (chnls.ptr[7]);
);

range_mul (feedback.ptr, chnls.ptr, rt60_att.ptr, chnls.size);

// Reminder: Chorus outside of the feedback loop, unpredictable signal level doesn't
// play well with decaytimes. Just feeding back a very tiny amount.
//range_mul_k (scratch1.ptr, chorus.ptr, 0.04, chorus.size);
//range_add (feedback.ptr, feedback.ptr, scratch1.ptr, chorus.size);

chorus_l = chorus.ptr[0] - chorus.ptr[3] + chorus.ptr[4] - chorus.ptr[6];
chorus_r = chorus.ptr[1] - chorus.ptr[2] + chorus.ptr[5] - chorus.ptr[7];

late_l = chnls.ptr[2];
late_r = chnls.ptr[4];

cho_comp = chorus_fact * (5 - abs (chorus_fact) * 4) * (1 / 5);

late_l += chorus_l * cho_comp;
late_r += chorus_r * cho_comp;

late_l *= late_mix;
late_r *= late_mix;

loop(0,
  // Cheat by removing some nasty resonances. TODO: where do they come from?
  late_l = posteq1l.svf_tick (posteq2l.svf_tick (posteq3l.svf_tick (late_l)));
  late_r = posteq1r.svf_tick (posteq2r.svf_tick (posteq3r.svf_tick (late_r)));
);


(mute == 0) ?(
  spl0 = er_l + late_l;
  spl1 = er_r + late_r;
);

counter += 1;

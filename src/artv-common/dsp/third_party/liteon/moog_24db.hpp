// Ported from https://github.com/Rcomian/jsfx-vcv
// commit sha: 65bfa7896480f3de7d424e42a6ef2b3737b43a20

#pragma once
// Generated by jsfx2cpp.py. To be manually corrected.
// includes for environment function calls
#include <algorithm>
#include <cmath>

#include <juce_audio_processors/juce_audio_processors.h>

#include "artv-common/dsp/own/classes/plugin_context.hpp"
#include "artv-common/dsp/types.hpp"
#include "artv-common/juce/parameter_definitions.hpp"
#include "artv-common/juce/parameter_types.hpp"
#include "artv-common/misc/misc.hpp"
#include "artv-common/misc/mp11.hpp"
#include "artv-common/misc/short_ints.hpp"
#include "artv-common/misc/xspan.hpp"

namespace artv { namespace liteon {

struct moog24 {
public:
  //----------------------------------------------------------------------------
  static constexpr dsp_types dsp_type  = dsp_types::filter;
  static constexpr bus_types bus_type  = bus_types::stereo;
  static constexpr uint      n_inputs  = 1;
  static constexpr uint      n_outputs = 1;
  //----------------------------------------------------------------------------
private:
  //----------------------------------------------------------------------------
#if 0
  /* "mempool" emulates the JSFX per instance memory pool.
  It can be removed if unused. On most cases the length of this array can be
  reduced. It is set to a very conservative (high) value matching what JSFX
  provides. */
  double mempool[8 * 1024 * 1024] = {};
#endif
  //----------------------------------------------------------------------------
  // definitions for environment function calls
  static double eel2_eq (double lhs, double rhs)
  {
    return (double) (std::abs (lhs - rhs) < 0.00001);
  }
  static double eel2_pow (double lhs, double rhs)
  {
    return std::pow (lhs, rhs);
  }
  //----------------------------------------------------------------------------
  // stubs for sliders
public:
  // slider1:0<0,1,1{Stereo,Mono}>Processing
  constexpr double get_slider_slider1()
  {
    // TODO: stub, add code for getting "slider1"
    // Range: min:0.0, max:1.0, default: 0.0, step: 1.0
    return 0.;
  }
  //----------------------------------------------------------------------------
  // slider2:0<0,2,1{LP (24dB/oct),HP (6dB/oct),BP (6dB/oct)}>Filter Type
  double get_slider_slider2()
  {
    // TODO: stub, add code for getting "slider2"
    // Range: min:0.0, max:2.0, default: 0.0, step: 1.0
    return filtype;
  }
  int filtype = 0;

  struct type_tag {};
  void set (type_tag, int v)
  {
    if (v == filtype) {
      return;
    }
    filtype = v;
    slider();
  }
  static constexpr auto get_parameter (type_tag)
  {
    return choice_param (
      0, make_cstr_array ("Lowpass 24dB", "Highpass 6dB", "Bandpass 6dB"));
  }
  //----------------------------------------------------------------------------
  // slider3:100<0,100,0.05>Cutoff (Scale)
  double get_slider_slider3()
  {
    // TODO: stub, add code for getting "slider3"
    // Range: min:0.0, max:100.0, default: 100.0, step: 0.05
    return cutoff_p;
  }
  float cutoff_p = 100.;

  struct cutoff_tag {};
  void set (cutoff_tag, float v)
  {
    if (v == cutoff_p) {
      return;
    }
    cutoff_p = v;
    slider();
  }

  static constexpr auto get_parameter (cutoff_tag)
  {
    return float_param ("", 0.f, 100.f, 100.f, 0.05f);
  }
  //----------------------------------------------------------------------------
  // slider4:0<0,0.85,0.001>Res (Min/Max)
  double get_slider_slider4()
  {
    // Range: min:0.0, max:0.85, default: 0.0, step: 0.001
    return resonance_p;
  }
  float resonance_p = 0.f;

  struct resonance_tag {};
  void set (resonance_tag, float v)
  {
    if (v == resonance_p) {
      return;
    }
    resonance_p = v;
    slider();
  }

  static constexpr auto get_parameter (resonance_tag)
  {
    return float_param ("", 0.f, 0.85f, 0.f, 0.001f);
  }
  //----------------------------------------------------------------------------
  // slider5:0<0,100,0.05>Drive (%)
  double get_slider_slider5()
  {
    // Range: min:0.0, max:100.0, default: 0.0, step: 0.05
    return drive_p;
  }
  float drive_p = 0.f;

  struct drive_tag {};
  void set (drive_tag, float v)
  {
    if (v == drive_p) {
      return;
    }
    drive_p = v;
    slider();
  }

  static constexpr auto get_parameter (drive_tag)
  {
    return float_param ("%", 0.f, 100.f, 0.f, 0.05f);
  }
  //----------------------------------------------------------------------------
  // slider6:0<-25,25,0.05>Output (dB)
  double get_slider_slider6()
  {
    // TODO: stub, add code for getting "slider6"
    // Range: min:-25.0, max:25.0, default: 0.0, step: 0.05
    return -(drive * 10);
  }
  //----------------------------------------------------------------------------
  // slider7:0<0,1,1{On,Off}>Limiter
  constexpr double get_slider_slider7()
  {
    // TODO: stub, add code for getting "slider7"
    // Range: min:0.0, max:1.0, default: 0.0, step: 1.0
    return 0.;
  }
  //----------------------------------------------------------------------------
  // slider8:0<0,1,1{Off,On}>Oversample (x2)
  constexpr double get_slider_slider8()
  {
    // TODO: stub, add code for getting "slider8"
    // Range: min:0.0, max:1.0, default: 0.0, step: 1.0
    return 1.;
  }
  //----------------------------------------------------------------------------
  using parameters = mp_list<type_tag, cutoff_tag, resonance_tag, drive_tag>;

private:
  //----------------------------------------------------------------------------
  // global/stateful variables for section "init"
  double bl_c1;
  double bl_c2;
  double bl_c3;
  double c1;
  double c2;
  double c3;
  double cdenorm;
  double fgain;
  double fs;
  double mv;
  //----------------------------------------------------------------------------
  void init_init_variables()
  {
    bl_c1   = 0;
    bl_c2   = 0;
    bl_c3   = 0;
    c1      = 0;
    c2      = 0;
    c3      = 0;
    cdenorm = 0;
    fgain   = 0;
    fs      = 0;
    mv      = 0;
  }
  //----------------------------------------------------------------------------
  // global/stateful variables for section "slider"
  double drive;
  double drvc;
  double ftype;
  double limiter;
  double mono;
  double os;
  double outgain;
  double tgt_k;
  double tgt_p;
  double tgt_r;
  //----------------------------------------------------------------------------
  void init_slider_variables()
  {
    drive   = 0;
    drvc    = 0;
    ftype   = 0;
    limiter = 0;
    mono    = 0;
    os      = 0;
    outgain = 0;
    tgt_k   = 0;
    tgt_p   = 0;
    tgt_r   = 0;
  }
  //----------------------------------------------------------------------------
  // global/stateful variables for section "block"
  double bl1_1;
  double bl1_2;
  double bl1_l1;
  double bl1_l2;
  double bl1_r1;
  double bl1_r2;
  double bl2_1;
  double bl2_2;
  double bl2_l1;
  double bl2_l2;
  double bl2_r1;
  double bl2_r2;
  double o_in12;
  double o_out2l;
  double o_out2r;
  double oldx;
  double oldxl;
  double oldxr;
  double oldy1;
  double oldy1l;
  double oldy1r;
  double oldy2;
  double oldy2l;
  double oldy2r;
  double oldy3;
  double oldy3l;
  double oldy3r;
  double ps_out2l;
  double ps_out2r;
  double s1l;
  double s1r;
  double s2l;
  double s2r;
  double src_k;
  double src_p;
  double src_r;
  double y1;
  double y1l;
  double y1r;
  double y2;
  double y2l;
  double y2r;
  double y3;
  double y3l;
  double y3r;
  double y4;
  double y4l;
  double y4r;
  //----------------------------------------------------------------------------
  void init_block_variables()
  {
    bl1_1    = 0;
    bl1_2    = 0;
    bl1_l1   = 0;
    bl1_l2   = 0;
    bl1_r1   = 0;
    bl1_r2   = 0;
    bl2_1    = 0;
    bl2_2    = 0;
    bl2_l1   = 0;
    bl2_l2   = 0;
    bl2_r1   = 0;
    bl2_r2   = 0;
    o_in12   = 0;
    o_out2l  = 0;
    o_out2r  = 0;
    oldx     = 0;
    oldxl    = 0;
    oldxr    = 0;
    oldy1    = 0;
    oldy1l   = 0;
    oldy1r   = 0;
    oldy2    = 0;
    oldy2l   = 0;
    oldy2r   = 0;
    oldy3    = 0;
    oldy3l   = 0;
    oldy3r   = 0;
    ps_out2l = 0;
    ps_out2r = 0;
    s1l      = 0;
    s1r      = 0;
    s2l      = 0;
    s2r      = 0;
    src_k    = 0;
    src_p    = 0;
    src_r    = 0;
    y1       = 0;
    y1l      = 0;
    y1r      = 0;
    y2       = 0;
    y2l      = 0;
    y2r      = 0;
    y3       = 0;
    y3l      = 0;
    y3r      = 0;
    y4       = 0;
    y4l      = 0;
    y4r      = 0;
  }
  //----------------------------------------------------------------------------
public:
  void reset (plugin_context& pc)
  {
    init_init_variables();
    init_slider_variables();
    init_block_variables();
    cdenorm = eel2_pow (10., -30.);
    mv      = eel2_pow (2., (-0.2 / 6.));
    fs      = pc.get_sample_rate();
    c1      = 1.;
    c2      = -0.75;
    c3      = 0.17;
    fgain   = 5.;
    bl_c1   = 0.52;
    bl_c2   = 0.54;
    bl_c3   = -0.02;
    slider();
  }
  //----------------------------------------------------------------------------
private:
  void slider()
  {
    double cutoff = 0.;
    double f      = 0.;
    double res    = 0.;
    double scale  = 0.;
    double sx     = 0.;
    os            = get_slider_slider8();
    mono          = get_slider_slider1();
    ftype         = get_slider_slider2();
    res           = get_slider_slider4();
    drive         = 1. + get_slider_slider5() / 100.;
    drvc          = 1.2;
    outgain       = eel2_pow (10., (get_slider_slider6() / 20.));
    limiter       = get_slider_slider7();
    sx            = 16. + get_slider_slider3() * 1.20103;
    cutoff        = std::floor (std::exp (sx * std::log (1.059)) * 8.17742);
    f             = 2. * cutoff / fs;
    tgt_k         = 3.6 * f - 1.6 * f * f - 1.;
    tgt_p         = (tgt_k + 1.) * 0.5;
    scale         = eel2_pow (2.718281828459045, ((1. - tgt_p) * 1.386249));
    tgt_r         = res * scale;
    ;
  }
  //----------------------------------------------------------------------------
public:
  template <class T>
  void process (xspan<T*> outs, xspan<T const*> ins, uint samples)
  {
    assert (outs.size() >= (n_outputs * (uint) bus_type));
    assert (ins.size() >= (n_inputs * (uint) bus_type));

    double bl3_1    = 0.;
    double bl3_2    = 0.;
    double bl3_l1   = 0.;
    double bl3_l2   = 0.;
    double bl3_r1   = 0.;
    double bl3_r2   = 0.;
    double bl_out1  = 0.;
    double bl_out1l = 0.;
    double bl_out1r = 0.;
    double bl_out2  = 0.;
    double bl_out2l = 0.;
    double bl_out2r = 0.;
    double d_k      = 0.;
    double d_p      = 0.;
    double d_r      = 0.;
    double in       = 0.;
    double inl      = 0.;
    double input    = 0.;
    double inputl   = 0.;
    double inputr   = 0.;
    double inr      = 0.;
    double o_in1l   = 0.;
    double o_in1r   = 0.;
    double o_in2l   = 0.;
    double o_in2r   = 0.;
    double o_out1l  = 0.;
    double o_out1r  = 0.;
    double out      = 0.;
    double outl     = 0.;
    double outr     = 0.;
    double ps_out1l = 0.;
    double ps_out1r = 0.;
    double s3l      = 0.;
    double s3r      = 0.;
    double tk       = 0.;
    double tp       = 0.;
    double tr       = 0.;
    double x        = 0.;
    double xl       = 0.;
    double xr       = 0.;
    d_p             = (tgt_p - src_p) / samples;
    tp              = src_p;
    src_p           = tgt_p;
    d_k             = (tgt_k - src_k) / samples;
    tk              = src_k;
    src_k           = tgt_k;
    d_r             = (tgt_r - src_r) / samples;
    tr              = src_r;
    src_r           = tgt_r;
    for (uint i = 0; i < samples; ++i) {
      auto& spl0 = outs[0][i];
      auto& spl1 = outs[1][i];
      spl0       = ins[0][i];
      spl1       = ins[1][i];

      tk += d_k;
      tp += d_p;
      tr += d_r;
      if (eel2_eq (mono, 0.)) {
        if (drive > 1.) {
          inl = spl0;
          inr = spl1;
          if (eel2_eq (os, 1.)) {
            ps_out1l = 0.5 * (inl + ps_out2l);
            ps_out2l = 0.5 * ps_out1l;
            ps_out1r = 0.5 * (inr + ps_out2r);
            ps_out2r = 0.5 * ps_out1r;
            o_in1l   = ps_out1l * (std::abs (ps_out1l) + drive)
              / (eel2_pow (ps_out1l, 2.) + (drive - 1.) * std::abs (ps_out1l)
                 + 1.)
              * (drive / drvc);
            o_in2l = ps_out2l * (std::abs (ps_out2l) + drive)
              / (eel2_pow (ps_out2l, 2.) + (drive - 1.) * std::abs (ps_out2l)
                 + 1.)
              * (drive / drvc);
            o_in1r = ps_out1r * (std::abs (ps_out1r) + drive)
              / (eel2_pow (ps_out1r, 2.) + (drive - 1.) * std::abs (ps_out1r)
                 + 1.)
              * (drive / drvc);
            o_in2r = ps_out2r * (std::abs (ps_out2r) + drive)
              / (eel2_pow (ps_out2r, 2.) + (drive - 1.) * std::abs (ps_out2r)
                 + 1.)
              * (drive / drvc);
            bl3_l1   = bl2_l1;
            bl3_r1   = bl2_r1;
            bl3_l2   = bl2_l2;
            bl3_r2   = bl2_r2;
            bl2_l1   = bl1_l1;
            bl2_r1   = bl1_r1;
            bl2_l2   = bl1_l2;
            bl2_r2   = bl1_r2;
            bl1_l1   = o_in1l;
            bl1_r1   = o_in1r;
            bl1_l2   = o_in2l;
            bl1_r2   = o_in2r;
            bl_out1l = (bl1_l1 * bl_c1 + bl2_l1 * bl_c2 + bl3_l1 * bl_c3);
            bl_out1r = (bl1_r1 * bl_c1 + bl2_r1 * bl_c2 + bl3_r1 * bl_c3);
            bl_out2l = (bl1_l2 * bl_c1 + bl2_l2 * bl_c2 + bl3_l2 * bl_c3);
            bl_out2r = (bl1_r2 * bl_c1 + bl2_r2 * bl_c2 + bl3_r2 * bl_c3);
            o_out1l  = 0.5 * (bl_out1l + o_out2l);
            o_out2l  = 0.5 * (bl_out2l + o_out1l);
            o_out1r  = 0.5 * (bl_out1r + o_out2r);
            o_out2r  = 0.5 * (bl_out2r + o_out1r);
            s3l      = s2l;
            s3r      = s2r;
            s2l      = s1l;
            s2r      = s1r;
            s1l      = o_out1l;
            s1r      = o_out1r;
            inputl   = (s1l * c1 + s2l * c2 + s3l * c3) * fgain;
            inputr   = (s1r * c1 + s2r * c2 + s3r * c3) * fgain;
          }
          else {
            inputl = inl * (std::abs (inl) + drive)
              / (eel2_pow (inl, 2.) + (drive - 1.) * std::abs (inl) + 1.)
              * (drive / drvc);
            inputr = inr * (std::abs (inr) + drive)
              / (eel2_pow (inr, 2.) + (drive - 1.) * std::abs (inr) + 1.)
              * (drive / drvc);
          }
        }
        else {
          inputl = spl0;
          inputr = spl1;
        }
        xl     = inputl - tr * y4l;
        xr     = inputr - tr * y4r;
        y1l    = xl * tp + oldxl * tp - tk * y1l;
        y1r    = xr * tp + oldxr * tp - tk * y1r;
        y2l    = y1l * tp + oldy1l * tp - tk * y2l;
        y2r    = y1r * tp + oldy1r * tp - tk * y2r;
        y3l    = y2l * tp + oldy2l * tp - tk * y3l;
        y3r    = y2r * tp + oldy2r * tp - tk * y3r;
        y4l    = y3l * tp + oldy3l * tp - tk * y4l;
        y4r    = y3r * tp + oldy3r * tp - tk * y4r;
        oldxl  = xl;
        oldxr  = xr;
        oldy1l = y1l;
        oldy1r = y1r;
        oldy2l = y2l;
        oldy2r = y2r;
        oldy3l = y3l;
        oldy3r = y3r;
        if (eel2_eq (ftype, 0.)) {
          outl = y4l;
          outr = y4r;
        }
        if (eel2_eq (ftype, 1.)) {
          outl = inputl - y4l;
          outr = inputr - y4r;
        }
        if (eel2_eq (ftype, 2.)) {
          outl = 6. * (y3l - y4l);
          outr = 6. * (y3r - y4r);
        }
        outl *= outgain;
        outr *= outgain;
        if (eel2_eq (limiter, 0.)) {
          spl0 = std::min (std::max ((outl + cdenorm), -mv), mv);
          spl1 = std::min (std::max ((outr + cdenorm), -mv), mv);
        }
        else {
          spl0 = outl;
          spl1 = outr;
        }
      }
      else {
        in = (spl0 + spl1) / 2.;
        if (drive > 1.) {
          if (eel2_eq (os, 1.)) {
            ps_out1l = 0.5 * (in + ps_out2l);
            ps_out2l = 0.5 * ps_out1l;
            o_in1l   = ps_out1l * (std::abs (ps_out1l) + drive)
              / (eel2_pow (ps_out1l, 2.) + (drive - 1.) * std::abs (ps_out1l)
                 + 1.)
              * (drive / drvc);
            o_in2l = ps_out2l * (std::abs (ps_out2l) + drive)
              / (eel2_pow (ps_out2l, 2.) + (drive - 1.) * std::abs (ps_out2l)
                 + 1.)
              * (drive / drvc);
            bl3_1   = bl2_1;
            bl3_2   = bl2_2;
            bl2_1   = bl1_1;
            bl2_2   = bl1_2;
            bl1_1   = o_in1l;
            bl1_2   = o_in12;
            bl_out1 = (bl1_1 * bl_c1 + bl2_1 * bl_c2 + bl3_1 * bl_c3);
            bl_out2 = (bl1_2 * bl_c1 + bl2_2 * bl_c2 + bl3_2 * bl_c3);
            o_out1l = 0.5 * (bl_out1 + o_out2l);
            o_out2l = 0.5 * (bl_out2 + o_out1l);
            s3l     = s2l;
            s2l     = s1l;
            s1l     = o_out1l;
            input   = (s1l * c1 + s2l * c2 + s3l * c3) * fgain;
          }
          else {
            (input = in * (std::abs (in) + drive)
               / (eel2_pow (in, 2.) + (drive - 1.) * std::abs (in) + 1.)
               * (drive / drvc));
          }
        }
        else {
          (input = in);
        }
        x     = input - tr * y4;
        y1    = x * tp + oldx * tp - tk * y1;
        y2    = y1 * tp + oldy1 * tp - tk * y2;
        y3    = y2 * tp + oldy2 * tp - tk * y3;
        y4    = y3 * tp + oldy3 * tp - tk * y4;
        oldx  = x;
        oldy1 = y1;
        oldy2 = y2;
        oldy3 = y3;
        if (eel2_eq (ftype, 0.)) {
          (out = y4);
        }
        if (eel2_eq (ftype, 1.)) {
          (out = input - y4);
        }
        if (eel2_eq (ftype, 2.)) {
          (out = 6. * (y3 - y4));
        }
        out *= outgain;
        if (eel2_eq (limiter, 0.)) {
          spl0 = std::min (std::max ((out + cdenorm), -mv), mv);
          spl1 = std::min (std::max ((out + cdenorm), -mv), mv);
        }
        else {
          spl0 = out;
          spl1 = out;
        }
      };
    }
  }
}; /* moog24 */
}} // namespace artv::liteon

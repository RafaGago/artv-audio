// Ported from https://github.com/Rcomian/jsfx-vcv
// commit sha: 65bfa7896480f3de7d424e42a6ef2b3737b43a20
#pragma once
// Generated by jsfx2cpp.py. To be manually corrected.
// includes for environment function calls
#include <algorithm>
#include <cmath>
#include <cstring>
#include <vector>

#include <juce_audio_processors/juce_audio_processors.h>

#include "artv-common/dsp/own/classes/plugin_context.hpp"
#include "artv-common/dsp/types.hpp"
#include "artv-common/juce/parameter_definitions.hpp"
#include "artv-common/juce/parameter_types.hpp"
#include "artv-common/misc/misc.hpp"
#include "artv-common/misc/mp11.hpp"
#include "artv-common/misc/range.hpp"
#include "artv-common/misc/short_ints.hpp"

namespace artv { namespace liteon {

struct pseudostereo {
public:
  //----------------------------------------------------------------------------
  static constexpr dsp_types dsp_type  = dsp_types::stereo;
  static constexpr bus_types bus_type  = bus_types::stereo;
  static constexpr uint      n_inputs  = 1;
  static constexpr uint      n_outputs = 1;
  //----------------------------------------------------------------------------
private:
#if 0
  /* "mempool" emulates the JSFX per instance memory pool.
  It can be removed if unused. On most cases the length of this array can be
  reduced. It is set to a very conservative (high) value matching what JSFX
  provides. */
  double mempool[12 * 1024] = {};
#else
  std::vector<float> mempool;
#endif

  //----------------------------------------------------------------------------
  // definitions for environment function calls
  static double eel2_pow (double lhs, double rhs)
  {
    return std::pow (lhs, rhs);
  }
  //----------------------------------------------------------------------------
public:
  // stubs for sliders
  // slider1:0<-100,100,0.01>Fx (%)
  double get_slider_slider1()
  {
    // Range: min:-100.0, max:100.0, default: 0.0, step: 0.01
    return amount_p;
  }
  float amount_p = 0;

  struct amount_tag {};
  void set (amount_tag, float v)
  {
    if (v == amount_p) {
      return;
    }
    amount_p = v;
    slider();
  }

  static constexpr auto get_parameter (amount_tag)
  {
    return float_param ("%", -100.f, 100.f, 0.f, 0.01f);
  }
  //----------------------------------------------------------------------------
  // slider2:20<1,50,0.01>Delay (ms)
  double get_slider_slider2()
  {
    // Range: min:1.0, max:50.0, default: 20.0, step: 0.01
    return delay_p;
  }
  float delay_p = 0;

  struct delay_tag {};
  void set (delay_tag, float v)
  {
    if (v == delay_p) {
      return;
    }
    delay_p = v;
    slider();
  }

  static constexpr auto get_parameter (delay_tag)
  {
    return float_param ("ms", 1.f, 50.f, 20.f, 0.01f);
  }
  //----------------------------------------------------------------------------
  // slider3:0<-100,100,0.01>Balance (L/R)
  double get_slider_slider3()
  {
    // Range: min:-100.0, max:100.0, default: 0.0, step: 0.01
    return balance_p;
  }
  float balance_p = 0;

  struct balance_tag {};
  void set (balance_tag, float v)
  {
    if (v == balance_p) {
      return;
    }
    balance_p = v;
    slider();
  }

  static constexpr auto get_parameter (balance_tag)
  {
    return float_param ("L/R", -100.f, 100.f, 0.f, 0.01f);
  }
  //----------------------------------------------------------------------------
  // slider4:0<-20,20,0.01>Output (dB)
  double get_slider_slider4()
  {
    // TODO: stub, add code for getting "slider4"
    // Range: min:-20.0, max:20.0, default: 0.0, step: 0.01
    return 0.;
  }
  //----------------------------------------------------------------------------
  using parameters = mp_list<amount_tag, delay_tag, balance_tag>;
  //----------------------------------------------------------------------------
private:
  // global/stateful variables for section "init"
  double bp;
  double buffer;
  double size;
  //----------------------------------------------------------------------------
  void init_init_variables()
  {
    bp     = 0;
    buffer = 0;
    size   = 0;
  }
  //----------------------------------------------------------------------------
  // global/stateful variables for section "slider"
  double tgt_bl;
  double tgt_br;
  double tgt_del;
  double tgt_ld;
  double tgt_li;
  double tgt_rd;
  double tgt_ri;
  //----------------------------------------------------------------------------
  void init_slider_variables()
  {
    tgt_bl  = 0;
    tgt_br  = 0;
    tgt_del = 0;
    tgt_ld  = 0;
    tgt_li  = 0;
    tgt_rd  = 0;
    tgt_ri  = 0;
  }
  //----------------------------------------------------------------------------
  // global/stateful variables for section "block"
  double src_bl;
  double src_br;
  double src_del;
  double src_ld;
  double src_li;
  double src_rd;
  double src_ri;
  float  samplerate = 44100;
  //----------------------------------------------------------------------------
  void init_block_variables()
  {
    src_bl  = 0;
    src_br  = 0;
    src_del = 0;
    src_ld  = 0;
    src_li  = 0;
    src_rd  = 0;
    src_ri  = 0;
  }
  //----------------------------------------------------------------------------
public:
  void reset (plugin_context& pc)
  {
    init_init_variables();
    init_slider_variables();
    init_block_variables();
    size = pc.get_sample_rate() / 10.;
    bp   = size;
#if 1
    mempool.resize (size + 1);
    memset (mempool.data(), 0, sizeof mempool[0] * mempool.size());
#endif
    buffer     = 0.;
    samplerate = pc.get_sample_rate();
    slider();
  }
  //----------------------------------------------------------------------------
private:
  void slider()
  {
    double bal        = 0.;
    double fxamnt_abs = 0.;
    double fxamount   = 0.;
    double fxk        = 0.;
    double outbalance = 0.;
    if (get_slider_slider1() > 0.) {
      fxk = 115.;
    }
    else {
      fxk = 200.;
    }
    fxamount = 0.5 + (get_slider_slider1() / fxk);
    tgt_del
      = (samplerate * (22. + 4. * get_slider_slider2()) - 200000.) / 208000.;
    tgt_del *= tgt_del;
    outbalance = eel2_pow (10., (get_slider_slider4() / 20.));
    bal        = get_slider_slider3() / 100.;
    tgt_bl     = std::min (1. - bal, 1.) * outbalance;
    tgt_br     = std::min (1. + bal, 1.) * outbalance;
    if (fxamount < 0.5) {
      tgt_li = 0.25 + (1.5 * fxamount);
      tgt_ld = 0.;
      tgt_ri = 2. * fxamount;
      tgt_rd = 1. - tgt_ri;
    }
    else {
      tgt_li = 1.5 - fxamount;
      tgt_ld = fxamount - 0.5;
      tgt_ri = tgt_li;
      tgt_rd = -tgt_ld;
    }
    fxamnt_abs = 0.5 + std::abs (fxamount - 0.5);
    tgt_li *= fxamnt_abs;
    tgt_ld *= fxamnt_abs;
    tgt_ri *= fxamnt_abs;
    tgt_rd *= fxamnt_abs;
    ;
  }
  //----------------------------------------------------------------------------
public:
  template <class T>
  void process (crange<T*> outs, crange<T const*> ins, uint samples)
  {
    assert (outs.size() >= (n_outputs * (uint) bus_type));
    assert (ins.size() >= (n_inputs * (uint) bus_type));

    double a     = 0.;
    double b     = 0.;
    double bl    = 0.;
    double br    = 0.;
    double chl   = 0.;
    double chr   = 0.;
    double d_bl  = 0.;
    double d_br  = 0.;
    double d_del = 0.;
    double d_ld  = 0.;
    double d_li  = 0.;
    double d_rd  = 0.;
    double d_ri  = 0.;
    double del   = 0.;
    double ld    = 0.;
    double li    = 0.;
    double rd    = 0.;
    double ri    = 0.;
    double spl0  = 0.;
    double spl1  = 0.;
    double tmp   = 0.;

    d_ri    = (tgt_ri - src_ri) / samples;
    ri      = src_ri;
    src_ri  = tgt_ri;
    d_rd    = (tgt_rd - src_rd) / samples;
    rd      = src_rd;
    src_rd  = tgt_rd;
    d_li    = (tgt_li - src_li) / samples;
    li      = src_li;
    src_li  = tgt_li;
    d_ld    = (tgt_ld - src_ld) / samples;
    ld      = src_ld;
    src_ld  = tgt_ld;
    d_del   = (tgt_del - src_del) / samples;
    del     = src_del;
    src_del = tgt_del;
    d_bl    = (tgt_bl - src_bl) / samples;
    bl      = src_bl;
    src_bl  = tgt_bl;
    d_br    = (tgt_br - src_br) / samples;
    br      = src_br;
    src_br  = tgt_br;

    for (uint i = 0; i < samples; ++i) {
      auto& spl0 = outs[0][$$i];
      auto& spl1 = outs[1][$$i];
      spl0       = ins[0][$$i];
      spl1       = ins[1][$$i];

      li += d_li;
      ld += d_ld;
      ri += d_ri;
      rd += d_rd;
      del += d_del;
      bl += d_bl;
      br += d_br;
      chl                             = spl0;
      chr                             = spl1;
      a                               = (spl0 + spl1) / 2.;
      mempool[(size_t) (buffer + bp)] = a;
      tmp                             = (u64) (bp + del) % (u64) size;
      b                               = mempool[(size_t) (buffer + tmp)];
      chl += (a * li) - (b * ld);
      chr += (a * ri) - (b * rd);
      bp -= 1.;
      if (bp < 0.) {
        bp = size;
      }
      spl0 = chl * bl * 0.7;
      spl1 = chr * br * 0.7;
      ;
    }
  }
}; /* pseudostereo */
}} // namespace artv::liteon

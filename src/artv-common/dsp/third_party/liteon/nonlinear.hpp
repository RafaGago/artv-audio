#pragma once
// Generated by jsfx2cpp.py. To be manually corrected.
// includes for environment function calls
#pragma once
// Generated by jsfx2cpp.py. To be manually corrected.
// includes for environment function calls
#include <algorithm>
#include <cmath>
#include <cstdint>
#include <cstdlib>
#include <limits>

#include <juce_audio_processors/juce_audio_processors.h>

#include "artv-common/dsp/own/classes/plugin_context.hpp"
#include "artv-common/dsp/third_party/jsfx_engine/jsfx_engine.hpp"
#include "artv-common/dsp/types.hpp"
#include "artv-common/juce/parameter_definitions.hpp"
#include "artv-common/juce/parameter_types.hpp"
#include "artv-common/misc/misc.hpp"
#include "artv-common/misc/mp11.hpp"
#include "artv-common/misc/short_ints.hpp"
#include "artv-common/misc/xspan.hpp"

#define LITEON_NONLIN_BIG_TABLE 0

namespace artv { namespace liteon {
struct nonlinear {
public:
  //----------------------------------------------------------------------------
  static constexpr dsp_types dsp_type  = dsp_types::exciter;
  static constexpr bus_types bus_type  = bus_types::stereo;
  static constexpr uint      n_inputs  = 1;
  static constexpr uint      n_outputs = 1;
  //----------------------------------------------------------------------------
private:
  //----------------------------------------------------------------------------
  // definitions for environment function calls
  static double eel2_eq (double lhs, double rhs)
  {
    return (double) (std::abs (lhs - rhs) < 0.00001);
  }
  static double eel2_pow (double lhs, double rhs)
  {
    return std::pow (lhs, rhs);
  }
  static double jsfx_rand (double maxv = 1.)
  {
    return jsfx_engine::rand (maxv);
  }
#if LITEON_NONLIN_BIG_TABLE
  std::vector<float> heapmem;
  inline float&      heap (std::size_t value) { return heapmem[value]; }
  void               heap_reset (std::size_t s)
  { /*heap_reset has to be set after manual analysis of the mem requirements*/
    heapmem.resize (s);
    std::memset (heapmem.data(), 0, heapmem.size() * sizeof heapmem[0]);
  }
#else
  double get_noise_sample() { return jsfx_engine::rand (2.) - 1.; }
#endif

  //----------------------------------------------------------------------------
  // stubs for JSFX special variables

  double jsfx_specialvar_get_samplesblock()
  {
    return 0.; /* TODO: stub for getting JSFX var "samplesblock" */
  }

  double jsfx_specialvar_get_srate() { return plugcontext->get_sample_rate(); }

  void jsfx_specialvar_set_pdc_bot_ch (double val)
  {
    /* TODO: stub for setting JSFX var "pdc_bot_ch" */
  }

  void jsfx_specialvar_set_pdc_delay (double val)
  {
    return plugcontext->set_delay_compensation ((uint) val);
  }

  void jsfx_specialvar_set_pdc_top_ch (double val)
  {
    /* TODO: stub for setting JSFX var "pdc_top_ch" */
  }

  //----------------------------------------------------------------------------
public:
#if 0
  void set_slider1_slider (float v)
  {
    // Original slider line: slider1:30<0,100,0.01>Saturation Amount (%)
    // Range: min:0.0, max:100.0, default: 30.0, step: 0.01
    if (v == slider1) {
      return;
    }
    slider1 = v;
    slider();
  }
#else
  // Snippet for parameter boilerplate in the authors framework....
  struct saturation_tag {};

  void set (saturation_tag, float v)
  {
    // Original slider line: slider1:30<0,100,0.01>Saturation Amount (%)
    // Range: min:0.0, max:100.0, default: 30.0, step: 0.01
    if (v == slider1) {
      return;
    }
    slider1 = v;
    slider();
  }

  static constexpr auto get_parameter (saturation_tag)
  {
    // Original slider line: slider1:30<0,100,0.01>Saturation Amount (%)
    return float_param ("%", 0.0, 100.0, 30.0, 0.01);
  }

#endif
#if 0
  void set_slider2_slider (float v)
  {
    // Original slider line: slider2:50<0,100,0.01>Fluctuation Amount (%)
    // Range: min:0.0, max:100.0, default: 50.0, step: 0.01
    if (v == slider2) {
      return;
    }
    slider2 = v;
    slider();
  }
#else
  // Snippet for parameter boilerplate in the authors framework....
  struct fluctuation_tag {};

  void set (fluctuation_tag, float v)
  {
    // Original slider line: slider2:50<0,100,0.01>Fluctuation Amount (%)
    // Range: min:0.0, max:100.0, default: 50.0, step: 0.01
    if (v == slider2) {
      return;
    }
    slider2 = v;
    slider();
  }

  static constexpr auto get_parameter (fluctuation_tag)
  {
    // Original slider line: slider2:50<0,100,0.01>Fluctuation Amount (%)
    return float_param ("%", 0.0, 100.0, 50.0, 0.01);
  }

#endif
#if 0
  void set_slider3_slider (float v)
  {
    // Original slider line: slider3:16<0,32,1>Noise Floor At (Bits)
    // Range: min:0.0, max:32.0, default: 16.0, step: 1.0
    if (v == slider3) {
      return;
    }
    slider3 = v;
    slider();
  }
#else
  // Snippet for parameter boilerplate in the authors framework....
  struct noise_floor_tag {};

  void set (noise_floor_tag, float v)
  {
    // Original slider line: slider3:16<0,32,1>Noise Floor At (Bits)
    // Range: min:0.0, max:32.0, default: 16.0, step: 1.0
    if (v == slider3) {
      return;
    }
    slider3 = v;
    slider();
  }

  static constexpr auto get_parameter (noise_floor_tag)
  {
    // Original slider line: slider3:16<0,32,1>Noise Floor At (Bits)
    return float_param ("bits", 0.0, 32.0, 16.0, 1.0);
  }

#endif
#if 0
  void set_slider4_slider (float v)
  {
    // Original slider line: slider4:0<-24,24,0.01>Output (dB)
    // Range: min:-24.0, max:24.0, default: 0.0, step: 0.01
    if (v == slider4) {
      return;
    }
    slider4 = v;
    slider();
  }
#else
  // Snippet for parameter boilerplate in the authors framework....
  struct output_tag {};

  void set (output_tag, float v)
  {
    // Original slider line: slider4:0<-24,24,0.01>Output (dB)
    // Range: min:-24.0, max:24.0, default: 0.0, step: 0.01
    if (v == slider4) {
      return;
    }
    slider4 = v;
    slider();
  }

  static constexpr auto get_parameter (output_tag)
  {
    // Original slider line: slider4:0<-24,24,0.01>Output (dB)
    return float_param ("dB", -24.0, 24.0, 0.0, 0.01);
  }

#endif
#if 0
  void set_slider5_slider (float v)
  {
    // Original slider line: slider5:0<0,1,1{Reversed (deprecated
    // legacy),Normal}>Output Polarity Range: min:0.0, max:1.0, default: 0.0,
    // step: 1.0
    if (v == slider5) {
      return;
    }
    slider5 = v;
    slider();
  }
#else
  // Snippet for parameter boilerplate in the authors framework....
  struct slider5_tag {};

  void set (slider5_tag, float v)
  {
    // Original slider line: slider5:0<0,1,1{Reversed (deprecated
    // legacy),Normal}>Output Polarity Range: min:0.0, max:1.0, default: 0.0,
    // step: 1.0
    if (v == slider5) {
      return;
    }
    slider5 = v;
    slider();
  }

  static constexpr auto get_parameter (slider5_tag)
  {
    // Original slider line: slider5:0<0,1,1{Reversed (deprecated
    // legacy),Normal}>Output Polarity
    return float_param ("", 0.0, 1.0, 1.0, 1.0);
  }

#endif
#if 0
#else
  // Snippet for parameter boilerplate in the authors framework....
  using parameters = mp11::
    mp_list<saturation_tag, fluctuation_tag, noise_floor_tag, output_tag>;
#endif
private:
  //----------------------------------------------------------------------------
  // global/stateful variables for section "init"
  double hpk0;
  double hpk1;
  double i;
  double lpk0;
  double lpk1;
  double lsk0;
  double lsk1;
  double m;
  double n;
  double n2;
  double n3;
  double n4;
  double nfk0;
  double nfk1;
  double pi;
  double slider1;
  double slider2;
  double slider3;
  double slider4;
  double slider5;
  double sr;
  //----------------------------------------------------------------------------
  void init_init_variables()
  {
    hpk0    = 0;
    hpk1    = 0;
    i       = 0;
    lpk0    = 0;
    lpk1    = 0;
    lsk0    = 0;
    lsk1    = 0;
    m       = 0;
    n       = 0;
    n2      = 0;
    n3      = 0;
    n4      = 0;
    nfk0    = 0;
    nfk1    = 0;
    pi      = 0;
    slider1 = 0;
    slider2 = 0;
    slider3 = 0;
    slider4 = 0;
    slider5 = 0;
    sr      = 0;
  }
  //----------------------------------------------------------------------------
  // global/stateful variables for section "slider"
  double outgain;
  double pidrv;
  double r1;
  double r2;
  double sinpidrv;
  //----------------------------------------------------------------------------
  void init_slider_variables()
  {
    outgain  = 0;
    pidrv    = 0;
    r1       = 0;
    r2       = 0;
    sinpidrv = 0;
  }
  //----------------------------------------------------------------------------
  // global/stateful variables for section "block"
  double fs0l;
  double fs0r;
  double fs1l;
  double fs1r;
  double hptmpl;
  double hptmpr;
  double ls0l;
  double ls0r;
  double nfout0;
  double nfout1;
  double s0;
  double s1;
  double src_min2;
  double src_min3;
  //----------------------------------------------------------------------------
  void init_block_variables()
  {
    fs0l     = 0;
    fs0r     = 0;
    fs1l     = 0;
    fs1r     = 0;
    hptmpl   = 0;
    hptmpr   = 0;
    ls0l     = 0;
    ls0r     = 0;
    nfout0   = 0;
    nfout1   = 0;
    s0       = 0;
    s1       = 0;
    src_min2 = 0;
    src_min3 = 0;
  }
  //----------------------------------------------------------------------------
  plugin_context* plugcontext;

public:
  void reset (plugin_context& pc)
  {
    plugcontext = &pc;
    init_init_variables();
    init_slider_variables();
    init_block_variables();

    slider1 = 30.0;
    slider2 = 50.0;
    slider3 = 16.0;
    slider4 = 0.0;
#if 0
    slider5 = 0.0;
#else
    slider5  = 1.0;
#endif
    n  = 100000.;
    n2 = 2. * n;
    n3 = 3. * n;
    n4 = 4. * n;
#if LITEON_NONLIN_BIG_TABLE
    heap_reset (n4);
    i = 0.;
    for (int $$i = 0, $$end = std::max (0, (int) (n)); $$i < $$end; ++$$i) {
      heap (m + i) = (jsfx_rand (2.) - 1.);
      i += 1.;
    }
    i = n;
    for (int $$i = 0, $$end = std::max (0, (int) (n)); $$i < $$end; ++$$i) {
      heap (m + i) = (jsfx_rand (2.) - 1.);
      i += 1.;
    }
    i = 2. * n;
    for (int $$i = 0, $$end = std::max (0, (int) (n)); $$i < $$end; ++$$i) {
      heap (m + i) = (jsfx_rand (2.) - 1.);
      i += 1.;
    }
    i = 3. * n;
    for (int $$i = 0, $$end = std::max (0, (int) (n)); $$i < $$end; ++$$i) {
      heap (m + i) = (jsfx_rand (2.) - 1.);
      i += 1.;
    }
#endif
    pi   = 3.1415926535897932384626433832795;
    sr   = jsfx_specialvar_get_srate();
    lpk0 = 0.121;
    lpk1 = -0.56;
    hpk1 = std::exp (-188.49555921538759430775860299677 / sr);
    hpk0 = 1. - hpk1;
    nfk1 = std::exp (-12566.370614359172953850573533118 / sr);
    nfk0 = 1. - nfk1;
    lsk0 = std::exp (-1884.9555921538759430775860299677 / sr);
    lsk1 = 1. - lsk0;
    jsfx_specialvar_set_pdc_delay (2.);
    jsfx_specialvar_set_pdc_bot_ch (0.);
    jsfx_specialvar_set_pdc_top_ch (2.);
    i = 0.;
    slider();
  }
  //----------------------------------------------------------------------------
private:
  void slider()
  {
    double drv = 0.;
    drv        = slider1 / 200. + 0.001;
    pidrv      = pi * drv;
    sinpidrv   = 1. / std::sin (pidrv);
    r1         = slider2 / 300.;
    r2         = 1. / eel2_pow (2., slider3);
    outgain    = eel2_pow (10., (slider4 / 20.));
    if (eel2_eq (slider5, 1.)) {
      outgain = -outgain;
    };
  }
  //----------------------------------------------------------------------------
public:
  template <class T>
  void process (xspan<T*> outs, xspan<T const*> ins, uint samples)
  {
    assert (outs.size() >= (n_outputs * (uint) bus_type));
    assert (ins.size() >= (n_inputs * (uint) bus_type));

    double avs      = 0.;
    double d_min2   = 0.;
    double d_min3   = 0.;
    double fs2l     = 0.;
    double fs2r     = 0.;
    double fxoutl   = 0.;
    double fxoutr   = 0.;
    double inl      = 0.;
    double inr      = 0.;
    double lpoutl   = 0.;
    double lpoutr   = 0.;
    double lsoutl   = 0.;
    double lsoutr   = 0.;
    double min0     = 0.;
    double min1     = 0.;
    double min2     = 0.;
    double min2d    = 0.;
    double min2h    = 0.;
    double min2s    = 0.;
    double min3     = 0.;
    double min3d    = 0.;
    double min3h    = 0.;
    double min3s    = 0.;
    double min_av   = 0.;
    double tgt_min2 = 0.;
    double tgt_min3 = 0.;
    double wsoutl   = 0.;
    double wsoutr   = 0.;

    avs = (s0 + s1) / 2.;
#if LITEON_NONLIN_BIG_TABLE
    tgt_min2 = avs * heap (m + (i + 2. * n)) * r1;
#else
    tgt_min2 = avs * get_noise_sample() * r1;
#endif
    d_min2   = (tgt_min2 - src_min2) / samples;
    min2     = src_min2;
    src_min2 = tgt_min2;
#if LITEON_NONLIN_BIG_TABLE
    tgt_min3 = avs * heap (m + (i + 3. * n)) * r1;
#else
    tgt_min3 = avs * get_noise_sample() * r1;
#endif
    d_min3   = (tgt_min3 - src_min3) / samples;
    min3     = src_min3;
    src_min3 = tgt_min3;
    min_av   = (tgt_min2 + tgt_min3) / 2.;

    for (uint $$i = 0; $$i < samples; ++$$i) {
      auto& spl0 = outs[0][$$i];
      auto& spl1 = outs[1][$$i];
      spl0       = ins[0][$$i];
      spl1       = ins[1][$$i];

      s0 = spl0;
      s1 = spl1;
#if LITEON_NONLIN_BIG_TABLE
      min0 = heap (m + i) * r2;
      min1 = heap (m + (i + n)) * r2;
#else
      min0 = get_noise_sample() * r2;
      min1 = get_noise_sample() * r2;
#endif
      min2 += d_min2;
      min3 += d_min3;
      min2s = min2 * 0.05;
      min3s = min3 * 0.05;
      min2h = min2 * 0.005;
      min3h = min3 * 0.005;
      min2d = min2 * 5.;
      min3d = min3 * 5.;
      if (eel2_eq ((s0 && s1), 0.)) {
        wsoutl = s0;
        wsoutr = s1;
      }
      else {
        nfout0 = nfk0 * min0 + nfk1 * nfout0;
        nfout1 = nfk0 * min1 + nfk1 * nfout1;
        inl    = spl0 + nfout0;
        inr    = spl1 + nfout1;
        wsoutl = std::sin (pidrv * inl) * (sinpidrv + min2d);
        wsoutr = std::sin (pidrv * inr) * (sinpidrv + min3d);
      }
      fs2l   = fs1l;
      fs1l   = fs0l;
      fs0l   = wsoutl;
      lpoutl = (lpk0 - min2) * fs0l + (lpk1 + min3) * (fs1l + fs2l);
      fs2r   = fs1r;
      fs1r   = fs0r;
      fs0r   = wsoutr;
      lpoutr = (lpk0 - min3) * fs0r + (lpk1 + min2) * (fs1r + fs2r);
      ls0l   = (lsk1 - min2s) * lpoutl + (lsk0 + min3s) * ls0l;
      ls0r   = (lsk1 - min3s) * lpoutr + (lsk0 + min2s) * ls0r;
      lsoutl = lpoutl + ls0l * 0.25;
      lsoutr = lpoutr + ls0r * 0.25;
      hptmpl = (hpk0 + min2h) * lsoutl + (hpk1 - min3h) * hptmpl;
      hptmpr = (hpk0 + min3h) * lsoutr + (hpk1 - min2h) * hptmpr;
      fxoutl = lsoutl - hptmpl;
      fxoutr = lsoutr - hptmpr;
#if LITEON_NONLIN_BIG_TABLE
      i += 1.;
      if (i > n) {
        i = 0.;
      }
#endif
      spl0 = fxoutl * outgain;
      spl1 = fxoutr * outgain;
      ;
    }
  }
}; /* jsfx_process */
}} // namespace artv::liteon

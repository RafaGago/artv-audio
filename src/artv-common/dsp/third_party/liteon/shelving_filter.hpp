// Ported from https://github.com/Rcomian/jsfx-vcv
// commit sha: 65bfa7896480f3de7d424e42a6ef2b3737b43a20
#pragma once
// Generated by jsfx2cpp.py. To be manually corrected.
// includes for environment function calls
#include <algorithm>
#include <cmath>
#include <juce_audio_processors/juce_audio_processors.h>

#include "artv-common/dsp/own/classes/plugin_context.hpp"
#include "artv-common/dsp/types.hpp"
#include "artv-common/juce/parameter_definitions.hpp"
#include "artv-common/juce/parameter_types.hpp"
#include "artv-common/misc/misc.hpp"
#include "artv-common/misc/mp11.hpp"
#include "artv-common/misc/short_ints.hpp"
#include "artv-common/misc/xspan.hpp"

namespace artv { namespace liteon {

struct shelving_filter {
public:
  //----------------------------------------------------------------------------
  static constexpr dsp_types dsp_type  = dsp_types::eq;
  static constexpr bus_types bus_type  = bus_types::stereo;
  static constexpr uint      n_inputs  = 1;
  static constexpr uint      n_outputs = 1;
  //----------------------------------------------------------------------------
private:
#if 0
  /* "mempool" emulates the JSFX per instance memory pool.
  It can be removed if unused. On most cases the length of this array can be
  reduced. It is set to a very conservative (high) value matching what JSFX
  provides. */
  double mempool[8 * 1024 * 1024] = {};
#endif
  //----------------------------------------------------------------------------
  // definitions for environment function calls
  static double eel2_eq (double lhs, double rhs)
  {
    return (double) (std::abs (lhs - rhs) < 0.00001);
  }
  static double eel2_pow (double lhs, double rhs)
  {
    return std::pow (lhs, rhs);
  }

public:
  //----------------------------------------------------------------------------
  // stubs for sliders
  // slider1:0<0,1,1{Stereo,Mono}>Processing
  constexpr double get_slider_slider1()
  {
    // TODO: stub, add code for getting "slider1"
    // Range: min:0.0, max:1.0, default: 0.0, step: 1.0
    return 0.;
  }
  //----------------------------------------------------------------------------
  // slider2:50<0,100,0.05>LowShelf (Scale)
  double get_slider_slider2()
  {
    // Range: min:0.0, max:100.0, default: 50.0, step: 0.05
    return low_freqp;
  }
  float low_freqp = 50.;
  struct lowf_tag {};
  void set (lowf_tag, float v)
  {
    if (v == low_freqp) {
      return;
    }
    low_freqp = v;
    slider();
  }

  static constexpr auto get_parameter (lowf_tag)
  {
    return float_param ("", 0.f, 100.f, 50.f, 0.05f);
  }
  //----------------------------------------------------------------------------
  // slider3:0<-24,24,0.01>Gain (dB)
  double get_slider_slider3()
  {
    // Range: min:-24.0, max:24.0, default: 0.0, step: 0.01
    return low_gainp;
  }
  float low_gainp = 0.;
  struct low_gain_tag {};
  void set (low_gain_tag, float v)
  {
    if (v == low_gainp) {
      return;
    }
    low_gainp = v;
    slider();
  }

  static constexpr auto get_parameter (low_gain_tag)
  {
    return float_param ("dB", -24.f, 24.f, 0.f, 0.01f);
  }
  //----------------------------------------------------------------------------
  // slider4:50<0,100,0.05>HighShelf (Scale)
  double get_slider_slider4()
  {
    // Range: min:0.0, max:100.0, default: 50.0, step: 0.05
    return high_freqp;
  }
  float high_freqp = 50.;
  struct highf_tag {};
  void set (highf_tag, float v)
  {
    if (v == high_freqp) {
      return;
    }
    high_freqp = v;
    slider();
  }

  static constexpr auto get_parameter (highf_tag)
  {
    return float_param ("", 0.f, 100.f, 50.f, 0.05f);
  }
  //----------------------------------------------------------------------------
  // slider5:0<-24,24,0.01>Gain (dB)
  double get_slider_slider5()
  {
    // Range: min:-24.0, max:24.0, default: 0.0, step: 0.01
    return high_gainp;
  }
  float high_gainp = 0.;
  struct high_gain_tag {};
  void set (high_gain_tag, float v)
  {
    if (v == high_gainp) {
      return;
    }
    high_gainp = v;
    slider();
  }

  static constexpr auto get_parameter (high_gain_tag)
  {
    return float_param ("dB", -24.f, 24.f, 0.f, 0.01f);
  }
  //----------------------------------------------------------------------------
  // slider6:0<-24,24,0.05>Output (dB)
  double get_slider_slider6()
  {
    // TODO: stub, add code for getting "slider6"
    // Range: min:-24.0, max:24.0, default: 0.0, step: 0.05
    return 0.;
  }
  //----------------------------------------------------------------------------
  using parameters = mp_list<lowf_tag, low_gain_tag, highf_tag, high_gain_tag>;
  //----------------------------------------------------------------------------
private:
  // global/stateful variables for section "init"
  double spn;
  double x1l_hs;
  double x1l_ls;
  double x1r_hs;
  double x1r_ls;
  double x2l_hs;
  double x2l_ls;
  double x2r_hs;
  double x2r_ls;
  double y1l_hs;
  double y1l_ls;
  double y1r_hs;
  double y1r_ls;
  double y2l_hs;
  double y2l_ls;
  double y2r_hs;
  double y2r_ls;
  double yl_hs;
  double yl_ls;
  double yr_hs;
  double yr_ls;
  //----------------------------------------------------------------------------
  void init_init_variables()
  {
    spn    = 0;
    x1l_hs = 0;
    x1l_ls = 0;
    x1r_hs = 0;
    x1r_ls = 0;
    x2l_hs = 0;
    x2l_ls = 0;
    x2r_hs = 0;
    x2r_ls = 0;
    y1l_hs = 0;
    y1l_ls = 0;
    y1r_hs = 0;
    y1r_ls = 0;
    y2l_hs = 0;
    y2l_ls = 0;
    y2r_hs = 0;
    y2r_ls = 0;
    yl_hs  = 0;
    yl_ls  = 0;
    yr_hs  = 0;
    yr_ls  = 0;
  }
  //----------------------------------------------------------------------------
  // global/stateful variables for section "slider"
  double a0_hs;
  double a0_ls;
  double a1_hs;
  double a1_ls;
  double a2_hs;
  double a2_ls;
  double b1_hs;
  double b1_ls;
  double b2_hs;
  double b2_ls;
  double mono;
  double outgain;
  float  samplerate;
  //----------------------------------------------------------------------------
  void init_slider_variables()
  {
    a0_hs   = 0;
    a0_ls   = 0;
    a1_hs   = 0;
    a1_ls   = 0;
    a2_hs   = 0;
    a2_ls   = 0;
    b1_hs   = 0;
    b1_ls   = 0;
    b2_hs   = 0;
    b2_ls   = 0;
    mono    = 0;
    outgain = 0;
  }
  //----------------------------------------------------------------------------
public:
  void reset (plugin_context& pc)
  {
    init_init_variables();
    init_slider_variables();
    spn        = 0.;
    y2r_ls     = 0.;
    y1r_ls     = y2r_ls;
    x2r_ls     = y1r_ls;
    x1r_ls     = x2r_ls;
    yr_ls      = x1r_ls;
    y2l_ls     = yr_ls;
    y1l_ls     = y2l_ls;
    x2l_ls     = y1l_ls;
    x1l_ls     = x2l_ls;
    yl_ls      = x1l_ls;
    y2r_hs     = 0.;
    y1r_hs     = y2r_hs;
    x2r_hs     = y1r_hs;
    x1r_hs     = x2r_hs;
    yr_hs      = x1r_hs;
    y2l_hs     = yr_hs;
    y1l_hs     = y2l_hs;
    x2l_hs     = y1l_hs;
    x1l_hs     = x2l_hs;
    yl_hs      = x1l_hs;
    samplerate = pc.get_sample_rate();
    slider();
  }
  //----------------------------------------------------------------------------
private:
  void slider()
  {
    double a       = 0.;
    double a0      = 0.;
    double a1      = 0.;
    double a2      = 0.;
    double aa1     = 0.;
    double ab1     = 0.;
    double asq     = 0.;
    double b0      = 0.;
    double b1      = 0.;
    double b2      = 0.;
    double boost   = 0.;
    double cf      = 0.;
    double f       = 0.;
    double f2      = 0.;
    double freq1   = 0.;
    double freq2   = 0.;
    double gain    = 0.;
    double gam2p1  = 0.;
    double gamma2  = 0.;
    double gammad  = 0.;
    double gamman  = 0.;
    double recipb0 = 0.;
    double sa      = 0.;
    double siggam2 = 0.;
    double sx      = 0.;
    double ta0     = 0.;
    double ta1     = 0.;
    double ta2     = 0.;
    double tb0     = 0.;
    double tb1     = 0.;
    double tb2     = 0.;
    double tmp     = 0.;
    mono           = get_slider_slider1();
    outgain        = eel2_pow (10., (get_slider_slider6() / 20.));
    sx             = 16. + get_slider_slider2() * 1.20103;
    cf             = std::floor (std::exp (sx * std::log (1.059)) * 8.17742);
    freq1          = cf;
    cf /= samplerate;
    boost = get_slider_slider3();
    sa    = std::tan (3.141592653589793 * (cf - 0.25));
    asq   = sa * sa;
    a     = eel2_pow (10., (boost / 20.0));
    if ((boost < 6.0) && (boost > -6.0)) {
      (f = std::sqrt (a));
    }
    else {
      if ((a > 1.0)) {
        (f = a / std::sqrt (2.0));
      }
      else {
        (f = a * std::sqrt (2.0));
      }
    }
    f2  = f * f;
    tmp = a * a - f2;
    if (std::abs (tmp) <= spn) {
      (gammad = 1.0);
    }
    else {
      (gammad = eel2_pow (((f2 - 1.0) / tmp), 0.25));
    }
    gamman  = std::sqrt (a) * gammad;
    gamma2  = gamman * gamman;
    gam2p1  = 1.0 + gamma2;
    siggam2 = 2.0 * std::sqrt (2.0) / 2.0 * gamman;
    ta0     = gam2p1 + siggam2;
    ta1     = -2.0 * (1.0 - gamma2);
    ta2     = gam2p1 - siggam2;
    gamma2  = gammad * gammad;
    gam2p1  = 1.0 + gamma2;
    siggam2 = 2.0 * std::sqrt (2.0) / 2.0 * gammad;
    tb0     = gam2p1 + siggam2;
    tb1     = -2.0 * (1.0 - gamma2);
    tb2     = gam2p1 - siggam2;
    aa1     = sa * ta1;
    a0      = ta0 + aa1 + asq * ta2;
    a1      = 2.0 * sa * (ta0 + ta2) + (1.0 + asq) * ta1;
    a2      = asq * ta0 + aa1 + ta2;
    ab1     = sa * tb1;
    b0      = tb0 + ab1 + asq * tb2;
    b1      = 2.0 * sa * (tb0 + tb2) + (1.0 + asq) * tb1;
    b2      = asq * tb0 + ab1 + tb2;
    recipb0 = 1.0 / b0;
    a0 *= recipb0;
    a1 *= recipb0;
    a2 *= recipb0;
    b1 *= recipb0;
    b2 *= recipb0;
    a0_ls = a0;
    a1_ls = a1;
    a2_ls = a2;
    b1_ls = -b1;
    b2_ls = -b2;
    sx    = 16. + get_slider_slider4() * 1.20103;
    cf    = std::floor (std::exp (sx * std::log (1.059)) * 8.17742);
    freq2 = cf;
    cf /= samplerate;
    boost = -get_slider_slider5();
    sa    = std::tan (3.141592653589793 * (cf - 0.25));
    asq   = sa * sa;
    a     = eel2_pow (10., (boost / 20.0));
    if ((boost < 6.0) && (boost > -6.0)) {
      (f = std::sqrt (a));
    }
    else {
      if ((a > 1.0)) {
        (f = a / std::sqrt (2.0));
      }
      else {
        (f = a * std::sqrt (2.0));
      }
    }
    f2  = f * f;
    tmp = a * a - f2;
    if (std::abs (tmp) <= spn) {
      (gammad = 1.0);
    }
    else {
      (gammad = eel2_pow (((f2 - 1.0) / tmp), 0.25));
    }
    gamman  = std::sqrt (a) * gammad;
    gamma2  = gamman * gamman;
    gam2p1  = 1.0 + gamma2;
    siggam2 = 2.0 * std::sqrt (2.0) / 2.0 * gamman;
    ta0     = gam2p1 + siggam2;
    ta1     = -2.0 * (1.0 - gamma2);
    ta2     = gam2p1 - siggam2;
    gamma2  = gammad * gammad;
    gam2p1  = 1.0 + gamma2;
    siggam2 = 2.0 * std::sqrt (2.0) / 2.0 * gammad;
    tb0     = gam2p1 + siggam2;
    tb1     = -2.0 * (1.0 - gamma2);
    tb2     = gam2p1 - siggam2;
    aa1     = sa * ta1;
    a0      = ta0 + aa1 + asq * ta2;
    a1      = 2.0 * sa * (ta0 + ta2) + (1.0 + asq) * ta1;
    a2      = asq * ta0 + aa1 + ta2;
    ab1     = sa * tb1;
    b0      = tb0 + ab1 + asq * tb2;
    b1      = 2.0 * sa * (tb0 + tb2) + (1.0 + asq) * tb1;
    b2      = asq * tb0 + ab1 + tb2;
    recipb0 = 1.0 / b0;
    a0 *= recipb0;
    a1 *= recipb0;
    a2 *= recipb0;
    b1 *= recipb0;
    b2 *= recipb0;
    gain  = eel2_pow (10., (boost / 20.0));
    a0_hs = a0 / gain;
    a1_hs = a1 / gain;
    a2_hs = a2 / gain;
    b1_hs = -b1;
    b2_hs = -b2;
    ;
  }
  //----------------------------------------------------------------------------
public:
  template <class T>
  void process (xspan<T*> outs, xspan<T const*> ins, uint samples)
  {
    assert (outs.size() >= (n_outputs * (uint) bus_type));
    assert (ins.size() >= (n_inputs * (uint) bus_type));
    double xl_hs = 0.;
    double xl_ls = 0.;
    double xr_hs = 0.;
    double xr_ls = 0.;

    for (uint i = 0; i < samples; ++i) {
      auto& spl0 = outs[0][i];
      auto& spl1 = outs[1][i];
      spl0       = ins[0][i];
      spl1       = ins[1][i];
      if (eel2_eq (mono, 1.)) {
        xl_ls = (spl0 + spl1) / 2.;
        yl_ls = a0_ls * xl_ls + a1_ls * x1l_ls + a2_ls * x2l_ls + b1_ls * y1l_ls
          + b2_ls * y2l_ls;
        x2l_ls = x1l_ls;
        x1l_ls = xl_ls;
        y2l_ls = y1l_ls;
        y1l_ls = yl_ls;
        xl_hs  = yl_ls;
        yl_hs = a0_hs * xl_hs + a1_hs * x1l_hs + a2_hs * x2l_hs + b1_hs * y1l_hs
          + b2_hs * y2l_hs;
        x2l_hs = x1l_hs;
        x1l_hs = xl_hs;
        y2l_hs = y1l_hs;
        y1l_hs = yl_hs;
        spl1   = yl_hs * outgain;
        spl0   = spl1;
      }
      else {
        xl_ls = spl0;
        xr_ls = spl1;
        yl_ls = a0_ls * xl_ls + a1_ls * x1l_ls + a2_ls * x2l_ls + b1_ls * y1l_ls
          + b2_ls * y2l_ls;
        x2l_ls = x1l_ls;
        x1l_ls = xl_ls;
        y2l_ls = y1l_ls;
        y1l_ls = yl_ls;
        yr_ls = a0_ls * xr_ls + a1_ls * x1r_ls + a2_ls * x2r_ls + b1_ls * y1r_ls
          + b2_ls * y2r_ls;
        x2r_ls = x1r_ls;
        x1r_ls = xr_ls;
        y2r_ls = y1r_ls;
        y1r_ls = yr_ls;
        xl_hs  = yl_ls;
        xr_hs  = yr_ls;
        yl_hs = a0_hs * xl_hs + a1_hs * x1l_hs + a2_hs * x2l_hs + b1_hs * y1l_hs
          + b2_hs * y2l_hs;
        x2l_hs = x1l_hs;
        x1l_hs = xl_hs;
        y2l_hs = y1l_hs;
        y1l_hs = yl_hs;
        yr_hs = a0_hs * xr_hs + a1_hs * x1r_hs + a2_hs * x2r_hs + b1_hs * y1r_hs
          + b2_hs * y2r_hs;
        x2r_hs = x1r_hs;
        x1r_hs = xr_hs;
        y2r_hs = y1r_hs;
        y1r_hs = yr_hs;
        spl0   = yl_hs * outgain;
        spl1   = yr_hs * outgain;
      }
    }
  }
}; /* shelving_filter */
}} // namespace artv::liteon

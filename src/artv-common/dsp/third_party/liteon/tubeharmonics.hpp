#pragma once
// Generated by jsfx2cpp.py. To be manually corrected.
// includes for environment function calls
#include <algorithm>
#include <cmath>
#include <cstdint>
#include <cstdlib>
#include <limits>

//#error "For some non obvious reason this one sounds broken"

#include <juce_audio_processors/juce_audio_processors.h>

#include "artv-common/dsp/own/classes/misc.hpp"
#include "artv-common/dsp/own/classes/plugin_context.hpp"
#include "artv-common/dsp/third_party/jsfx_engine/jsfx_engine.hpp"
#include "artv-common/dsp/types.hpp"
#include "artv-common/juce/parameter_definitions.hpp"
#include "artv-common/juce/parameter_types.hpp"
#include "artv-common/misc/misc.hpp"
#include "artv-common/misc/mp11.hpp"
#include "artv-common/misc/short_ints.hpp"
#include "artv-common/misc/xspan.hpp"

namespace artv { namespace liteon {
struct tube_harmonics {
public:
  //----------------------------------------------------------------------------
  static constexpr dsp_types dsp_type  = dsp_types::exciter;
  static constexpr bus_types bus_type  = bus_types::stereo;
  static constexpr uint      n_inputs  = 1;
  static constexpr uint      n_outputs = 1;

private:
  //----------------------------------------------------------------------------
  // definitions for environment function calls
  static double eel2_eq (double lhs, double rhs)
  {
    return (double) (std::abs (lhs - rhs) < 0.00001);
  }
  static double eel2_or (double lhs, double rhs)
  {
    return (double) ((uint64_t) lhs | (uint64_t) rhs);
  }
  static double eel2_pow (double lhs, double rhs)
  {
    return std::pow (lhs, rhs);
  }
  static double jsfx_rand (double maxv = 1.)
  {
    return jsfx_engine::rand (maxv);
  }

  //----------------------------------------------------------------------------
  // stubs for JSFX special variables

  void jsfx_specialvar_set_ext_noinit (double val)
  {
    /* TODO: stub for setting JSFX var "ext_noinit" */
  }

  //----------------------------------------------------------------------------
public:
#if 0
  void set_slider1_slider (float v)
  {
    // Original slider line: slider1:0.3<0,1,0.001>Even Harmonics
    // Range: min:0.0, max:1.0, default: 0.3, step: 0.001
    if (v == slider1) {
      return;
    }
    slider1 = v;
    slider();
  }
#else
  // Snippet for parameter boilerplate in the authors framework....
  struct even_tag {};

  void set (even_tag, float v)
  {
    // Original slider line: slider1:0.3<0,1,0.001>Even Harmonics
    // Range: min:0.0, max:1.0, default: 0.3, step: 0.001
    if (v == slider1) {
      return;
    }
    slider1 = v;
    slider();
  }

  static constexpr auto get_parameter (even_tag)
  {
    // Original slider line: slider1:0.3<0,1,0.001>Even Harmonics
    return float_param ("", 0.0, 1.0, 0.3, 0.001);
  }

#endif
#if 0
  void set_slider2_slider (float v)
  {
    // Original slider line: slider2:0.3<0,1,0.001>Odd Harmonics
    // Range: min:0.0, max:1.0, default: 0.3, step: 0.001
    if (v == slider2) {
      return;
    }
    slider2 = v;
    slider();
  }
#else
  // Snippet for parameter boilerplate in the authors framework....
  struct odd_tag {};

  void set (odd_tag, float v)
  {
    // Original slider line: slider2:0.3<0,1,0.001>Odd Harmonics
    // Range: min:0.0, max:1.0, default: 0.3, step: 0.001
    if (v == slider2) {
      return;
    }
    slider2 = v;
    slider();
  }

  static constexpr auto get_parameter (odd_tag)
  {
    // Original slider line: slider2:0.3<0,1,0.001>Odd Harmonics
    return float_param ("", 0.0, 1.0, 0.3, 0.001);
  }

#endif
#if 0
  void set_slider3_slider (float v)
  {
    // Original slider line: slider3:0.1<0,1,0.001>Fluctuation
    // Range: min:0.0, max:1.0, default: 0.1, step: 0.001
    if (v == slider3) {
      return;
    }
    slider3 = v;
    slider();
  }
#else
  // Snippet for parameter boilerplate in the authors framework....
  struct fluctuation_tag {};

  void set (fluctuation_tag, float v)
  {
    // Original slider line: slider3:0.1<0,1,0.001>Fluctuation
    // Range: min:0.0, max:1.0, default: 0.1, step: 0.001
    if (v == slider3) {
      return;
    }
    slider3 = v;
    slider();
  }

  static constexpr auto get_parameter (fluctuation_tag)
  {
    // Original slider line: slider3:0.1<0,1,0.001>Fluctuation
    return float_param ("", 0.0, 1.0, 0.1, 0.001);
  }

#endif
#if 0
  void set_slider4_slider (float v)
  {
    // Original slider line: slider4:0<-12,12,0.001>TS Input (dB)
    // Range: min:-12.0, max:12.0, default: 0.0, step: 0.001
    if (v == slider4) {
      return;
    }
    slider4 = v;
    slider();
  }
#else
  // Snippet for parameter boilerplate in the authors framework....
  struct ts_input_tag {};

  void set (ts_input_tag, float v)
  {
    // Original slider line: slider4:0<-12,12,0.001>TS Input (dB)
    // Range: min:-12.0, max:12.0, default: 0.0, step: 0.001
    if (v == slider4) {
      return;
    }
    slider4 = v;
    slider();
  }

  static constexpr auto get_parameter (ts_input_tag)
  {
    // Original slider line: slider4:0<-12,12,0.001>TS Input (dB)
    return float_param ("", -12.0, 12.0, 0.0, 0.001);
  }

#endif
#if 0
  void set_slider5_slider (float v)
  {
    // Original slider line: slider5:0<-12,12,0.001>TS Output (dB)
    // Range: min:-12.0, max:12.0, default: 0.0, step: 0.001
    if (v == slider5) {
      return;
    }
    slider5 = v;
    slider();
  }
#else
  // Snippet for parameter boilerplate in the authors framework....
  struct ts_output_tag {};

  void set (ts_output_tag, float v)
  {
    // Original slider line: slider5:0<-12,12,0.001>TS Output (dB)
    // Range: min:-12.0, max:12.0, default: 0.0, step: 0.001
    if (v == slider5) {
      return;
    }
    slider5 = v;
    slider();
  }

  static constexpr auto get_parameter (ts_output_tag)
  {
    // Original slider line: slider5:0<-12,12,0.001>TS Output (dB)
    return float_param ("", -12.0, 12.0, 0.0, 0.001);
  }

#endif
#if 0
  void set_slider6_slider (float v)
  {
    // Original slider line: slider6:0<-12,12,0.001>Output Gain (dB)
    // Range: min:-12.0, max:12.0, default: 0.0, step: 0.001
    if (v == slider6) {
      return;
    }
    slider6 = v;
    slider();
  }
#else
  // Snippet for parameter boilerplate in the authors framework....
  struct ts_gain_tag {};

  void set (ts_gain_tag, float v)
  {
    // Original slider line: slider6:0<-12,12,0.001>Output Gain (dB)
    // Range: min:-12.0, max:12.0, default: 0.0, step: 0.001
    if (v == slider6) {
      return;
    }
    slider6 = v;
    slider();
  }

  static constexpr auto get_parameter (ts_gain_tag)
  {
    // Original slider line: slider6:0<-12,12,0.001>Output Gain (dB)
    return float_param ("", -12.0, 12.0, 0.0, 0.001);
  }

#endif
#if 0
#else
  // Snippet for parameter boilerplate in the authors framework....
  using parameters = mp_list<
    even_tag,
    odd_tag,
    fluctuation_tag,
    ts_input_tag,
    ts_output_tag,
    ts_gain_tag>;
#endif
  //----------------------------------------------------------------------------
private:
  // global/stateful variables for section "init"
  double ka;
  double kb;
  double lim;
  double sc_y0;
  double sc_y1;
  double seed0;
  double seed1;
  double slider1;
  double slider2;
  double slider3;
  double slider4;
  double slider5;
  double slider6;
  //----------------------------------------------------------------------------
  void init_init_variables()
  {
    ka      = 0;
    kb      = 0;
    lim     = 0;
    sc_y0   = 0;
    sc_y1   = 0;
    seed0   = 0;
    seed1   = 0;
    slider1 = 0;
    slider2 = 0;
    slider3 = 0;
    slider4 = 0;
    slider5 = 0;
    slider6 = 0;
  }
  //----------------------------------------------------------------------------
  // global/stateful variables for section "slider"
  double drvo;
  double hgain;
  double ingain;
  double kabs;
  double kr;
  double tgt_drve;
  double trim;
  //----------------------------------------------------------------------------
  void init_slider_variables()
  {
    drvo     = 0;
    hgain    = 0;
    ingain   = 0;
    kabs     = 0;
    kr       = 0;
    tgt_drve = 0;
    trim     = 0;
  }
  //----------------------------------------------------------------------------
  // global/stateful variables for section "block"
  double ch0;
  double ch1;
  double dcf00;
  double dcf01;
  double dcf10;
  double dcf11;
  double m00;
  double m02;
  double m04;
  double m10;
  double m12;
  double m14;
  double src_abs0;
  double src_abs1;
  double src_drve;
  double src_y0;
  double src_y1;
  //----------------------------------------------------------------------------
  void init_block_variables()
  {
    ch0      = 0;
    ch1      = 0;
    dcf00    = 0;
    dcf01    = 0;
    dcf10    = 0;
    dcf11    = 0;
    m00      = 0;
    m02      = 0;
    m04      = 0;
    m10      = 0;
    m12      = 0;
    m14      = 0;
    src_abs0 = 0;
    src_abs1 = 0;
    src_drve = 0;
    src_y0   = 0;
    src_y1   = 0;
  }
  //----------------------------------------------------------------------------
public:
  void reset (plugin_context& pc)
  {
    init_init_variables();
    init_slider_variables();
    init_block_variables();

    slider1 = 0.3;
    slider2 = 0.3;
    slider3 = 0.1;
    slider4 = 0.0;
    slider5 = 0.0;
    slider6 = 0.0;
    jsfx_specialvar_set_ext_noinit (1.);
    seed0 = eel2_or (jsfx_rand (999.), 0.);
    {
      bool $$cond;
      do {
        $$cond = (bool) [&]
        {
          seed1 = eel2_or (jsfx_rand (999.), 0.);
          return eel2_eq (seed1, seed0);
        }
        ();
      } while ($$cond);
    }
    sc_y1 = 1.;
    sc_y0 = sc_y1;
    ka    = 0.97;
    kb    = 1. - ka;
    lim   = 0.5;
    slider();
  }
  //----------------------------------------------------------------------------
private:
  void slider()
  {
    tgt_drve = slider1 * 4.;
    drvo     = slider2 * 9.;
    kr       = slider3;
    kabs     = slider3 * 10.;
    ingain   = eel2_pow (2., (slider4 / 6.));
    hgain    = eel2_pow (2., (slider5 / 6.));
    trim     = eel2_pow (2., (slider6 / 6.));
    ;
  }
  //----------------------------------------------------------------------------
  white_noise_generator whitenoise;
  //----------------------------------------------------------------------------
public:
  template <class T>
  void process (xspan<T*> outs, xspan<T const*> ins, uint samples)
  {
    assert (outs.size() >= (n_outputs * (uint) bus_type));
    assert (ins.size() >= (n_inputs * (uint) bus_type));
    double abs0      = 0.;
    double abs1      = 0.;
    double d_abs0    = 0.;
    double d_abs1    = 0.;
    double d_drve    = 0.;
    double d_y0      = 0.;
    double d_y1      = 0.;
    double dc00      = 0.;
    double dc01      = 0.;
    double dc10      = 0.;
    double dc11      = 0.;
    double drve      = 0.;
    double drve_rnd0 = 0.;
    double drve_rnd1 = 0.;
    double drvo_rnd0 = 0.;
    double drvo_rnd1 = 0.;
    double fir0      = 0.;
    double fir1      = 0.;
    double h0        = 0.;
    double h1        = 0.;
    double lim0      = 0.;
    double lim1      = 0.;
    double m01       = 0.;
    double m03       = 0.;
    double m05       = 0.;
    double m11       = 0.;
    double m13       = 0.;
    double m15       = 0.;
    double tgt_abs0  = 0.;
    double tgt_abs1  = 0.;
    double tgt_y0    = 0.;
    double tgt_y1    = 0.;
    double y0        = 0.;
    double y1        = 0.;

    d_drve   = (tgt_drve - src_drve) / samples;
    drve     = src_drve;
    src_drve = tgt_drve;
    (seed0 += 1.);
    sc_y0  = std::sin (seed0 * sc_y0);
    tgt_y0 = sc_y0 * kr;
    d_y0   = (tgt_y0 - src_y0) / samples;
    y0     = src_y0;
    src_y0 = tgt_y0;
    (seed1 += 1.);
    sc_y1    = std::sin (seed1 * sc_y1);
    tgt_y1   = sc_y1 * kr;
    d_y1     = (tgt_y1 - src_y1) / samples;
    y1       = src_y1;
    src_y1   = tgt_y1;
    tgt_abs0 = std::abs (ch0) * kabs;
    d_abs0   = (tgt_abs0 - src_abs0) / samples;
    abs0     = src_abs0;
    src_abs0 = tgt_abs0;
    tgt_abs1 = std::abs (ch1) * kabs;
    d_abs1   = (tgt_abs1 - src_abs1) / samples;
    abs1     = src_abs1;
    src_abs1 = tgt_abs1;

    for (uint i = 0; i < samples; ++i) {
      auto& spl0 = outs[0][i];
      auto& spl1 = outs[1][i];
      spl0       = ins[0][i];
      spl1       = ins[1][i];

      spl0 += whitenoise (1e-24);
      spl1 += whitenoise (1e-24);

      ch0 = spl0 * ingain;
      ch1 = spl1 * ingain;

      y0 += d_y0;
      y1 += d_y1;
      abs0 += d_abs0;
      abs1 += d_abs1;
      drve += d_drve;
      drve_rnd0 = drve - abs0;
      drve_rnd1 = drve - abs1;
      drvo_rnd0 = drvo - abs0 - y0;
      drvo_rnd1 = drvo - abs1 - y1;
      h0        = std::sin (ch0) / std::sin (ch0 * 2.) * drve_rnd0
        + (ch0 - std::tan (ch0)) * drvo_rnd0;
      h1 = std::sin (ch1) / std::sin (ch1 * 2.) * drve_rnd1
        + (ch1 - std::tan (ch1)) * drvo_rnd1;
      (dcf00 = h0 * kb + dcf00 * ka);
      dc00 = h0 - dcf00;
      (dcf01 = h1 * kb + dcf01 * ka);
      dc01 = h1 - dcf01;
      lim0 = std::min (std::max (dc00 * hgain, -lim), lim);
      lim1 = std::min (std::max (dc01 * hgain, -lim), lim);
      m01  = m00;
      m03  = m02;
      m05  = m04;
      m00  = lim0;
      m02  = 0.5 * (m01 + m00);
      m04  = 0.5 * (m03 + m02);
      fir0 = 0.5 * (m05 + m04);
      m11  = m10;
      m13  = m12;
      m15  = m14;
      m10  = lim1;
      m12  = 0.5 * (m11 + m10);
      m14  = 0.5 * (m13 + m12);
      fir1 = 0.5 * (m15 + m14);
      (dcf10 = fir0 * kb + dcf10 * ka);
      dc10 = fir0 - dcf10;
      (dcf11 = fir1 * kb + dcf11 * ka);
      dc11 = fir1 - dcf11;

      spl0 = (spl0 + dc10) * trim;
      spl1 = (spl1 + dc11) * trim;
      ;
    }
  }
}; /* jsfx_process */
}} // namespace artv::liteon

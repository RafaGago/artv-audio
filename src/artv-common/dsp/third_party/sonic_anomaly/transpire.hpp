// Ported from https://github.com/Sonic-Anomaly/Sonic-Anomaly-JSFX.git
// commit sha: 663735021e59d788e8ebacc4b9678569378deec9

#pragma once
// Generated by jsfx2cpp.py. To be manually corrected.
// includes for environment function calls
#include <algorithm>
#include <cmath>
#include <cstdint>
#include <cstdlib>
#include <cstring>
#include <limits>
#include <vector>
// slider1:0<-10,10,0.1>-Attack
// slider2:0<-10,10,0.1>-Sustain
// slider7:0.5<0,1,0.1>-Sensitivity
// slider10:0<-12,12,0.1>-Output
#include <juce_audio_processors/juce_audio_processors.h>

#include "artv-common/dsp/own/classes/plugin_context.hpp"
#include "artv-common/dsp/third_party/jsfx_engine/jsfx_engine.hpp"
#include "artv-common/dsp/types.hpp"
#include "artv-common/juce/parameter_definitions.hpp"
#include "artv-common/juce/parameter_types.hpp"
#include "artv-common/misc/misc.hpp"
#include "artv-common/misc/mp11.hpp"
#include "artv-common/misc/range.hpp"
#include "artv-common/misc/short_ints.hpp"

namespace artv { namespace sonic_anomaly {

struct transpire {
public:
  //----------------------------------------------------------------------------
  static constexpr dsp_types dsp_type  = dsp_types::dynamics;
  static constexpr bus_types bus_type  = bus_types::stereo;
  static constexpr uint      n_inputs  = 1;
  static constexpr uint      n_outputs = 1;
  //----------------------------------------------------------------------------
private:
  // definitions for environment function calls
  static double eel2_pow (double lhs, double rhs)
  {
    return std::pow (lhs, rhs);
  }

  std::vector<float> heapmem;
  inline float&      heap (std::size_t value) { return heapmem[value]; }

  void heap_reset (std::size_t s)
  {
    heapmem.resize (s);
    std::memset (heapmem.data(), 0, heapmem.size() * sizeof heapmem[0]);
  }

  static double jsfx_rand (double maxv = 1.)
  {
    return jsfx_engine::rand (maxv);
  }

  double jsfx_sign (double value)
  {
    auto v = *((uint64_t*) ((void*) &value));
    return (v == 0) ? 0. : (v & (1ull << 63)) ? -1. : 1.;
  }

  //----------------------------------------------------------------------------
  // stubs for JSFX special variables

  double jsfx_specialvar_get_srate() { return plugcontext->get_sample_rate(); }

  void jsfx_specialvar_set_pdc_bot_ch (double val)
  {
    /* TODO: stub for setting JSFX var "pdc_bot_ch" */
  }

  void jsfx_specialvar_set_pdc_delay (double val)
  {
    plugcontext->set_delay_compensation ((uint) val);
  }

  void jsfx_specialvar_set_pdc_top_ch (double val)
  {
    /* TODO: stub for setting JSFX var "pdc_top_ch" */
  }

  //----------------------------------------------------------------------------
  // stubs for sliders
public:
#if 0
  double get_slider_slider1()
  {
    // TODO: stub, add code for getting "slider1"
    // Range: min:-10.0, max:10.0, default: 0.0, step: 0.1
    // Original line: slider1:0<-10,10,0.1>-Attack
    return 0.;
  }
#else
  // Snippet for parameter boilerplate in the authors framework....
  double get_slider_slider1()
  {
    // Range: min:-10.0, max:10.0, default: 0.0, step: 0.1
    return slider1p;
  }

  float slider1p = 0.0;

  struct attack_tag {};

  void set (attack_tag, float v)
  {
    if (v == slider1p) {
      return;
    }
    slider1p = v;
    slider();
  }

  static constexpr auto get_parameter (attack_tag)
  {
    // Original slider line: slider1:0<-10,10,0.1>-Attack
    return float_param ("", -10.0, 10.0, 0.0, 0.1);
  }
#endif
#if 1
  double get_slider_slider10()
  {
    // TODO: stub, add code for getting "slider10"
    // Range: min:-12.0, max:12.0, default: 0.0, step: 0.1
    // Original line: slider10:0<-12,12,0.1>-Output
    return 0.;
  }
#else
  // Snippet for parameter boilerplate in the authors framework....
  double get_slider_slider10()
  {
    // Range: min:-12.0, max:12.0, default: 0.0, step: 0.1
    return slider10p;
  }

  float slider10p = 0.0;

  struct slider10_tag {};

  void set (slider10_tag, float v)
  {
    if (v == slider10p) {
      return;
    }
    slider10p = v;
    slider();
  }

  static constexpr auto get_parameter (slider10_tag)
  {
    // Original slider line: slider10:0<-12,12,0.1>-Output
    return float_param ("", -12.0, 12.0, 0.0, 0.1);
  }
#endif
#if 0
  double get_slider_slider2()
  {
    // TODO: stub, add code for getting "slider2"
    // Range: min:-10.0, max:10.0, default: 0.0, step: 0.1
    // Original line: slider2:0<-10,10,0.1>-Sustain
    return 0.;
  }
#else
  // Snippet for parameter boilerplate in the authors framework....
  double get_slider_slider2()
  {
    // Range: min:-10.0, max:10.0, default: 0.0, step: 0.1
    return slider2p;
  }

  float slider2p = 0.0;

  struct sustain_tag {};

  void set (sustain_tag, float v)
  {
    if (v == slider2p) {
      return;
    }
    slider2p = v;
    slider();
  }

  static constexpr auto get_parameter (sustain_tag)
  {
    // Original slider line: slider2:0<-10,10,0.1>-Sustain
    return float_param ("", -10.0, 10.0, 0.0, 0.1);
  }
#endif
#if 0
  double get_slider_slider7()
  {
    // TODO: stub, add code for getting "slider7"
    // Range: min:0.0, max:1.0, default: 0.5, step: 0.1
    // Original line: slider7:0.5<0,1,0.1>-Sensitivity
    return 0.;
  }
#else
  // Snippet for parameter boilerplate in the authors framework....
  double get_slider_slider7()
  {
    // Range: min:0.0, max:1.0, default: 0.5, step: 0.1
    return slider7p;
  }

  float slider7p = 0.5;

  struct sensitivity_tag {};

  void set (sensitivity_tag, float v)
  {
    if (v == slider7p) {
      return;
    }
    slider7p = v;
    slider();
  }

  static constexpr auto get_parameter (sensitivity_tag)
  {
    // Original slider line: slider7:0.5<0,1,0.1>-Sensitivity
    return float_param ("", 0.0, 1.0, 0.5, 0.1);
  }

  using parameters = mp_list<sensitivity_tag, attack_tag, sustain_tag>;
#endif
  //----------------------------------------------------------------------------
  // global/stateful variables for section "init"
private:
  double _playbackinit;
  double adir;
  double attack$exp;
  double buildstr;
  double l0$end;
  double l0$expval;
  double l0$floorindex;
  double l0$frac;
  double l0$hi;
  double l0$i;
  double l0$index;
  double l0$invstep;
  double l0$len;
  double l0$lo;
  double l0$maxval;
  double l0$start;
  double l0$v;
  double l1$end;
  double l1$expval;
  double l1$floorindex;
  double l1$frac;
  double l1$hi;
  double l1$i;
  double l1$index;
  double l1$invstep;
  double l1$len;
  double l1$lo;
  double l1$maxval;
  double l1$start;
  double l1$v;
  double lutmem;
#if 0
  double m0$a;
  double m0$b;
  double m0$g;
  double m0$r;
  double m1$a;
  double m1$b;
  double m1$g;
  double m1$r;
#endif
  double mtr$att;
  double mtr$sus;
  double norm;
  double output;
  double predelay;
  double prm$sens;
#if 0
  double s1$a;
  double s1$b;
  double s1$g;
  double s1$r;
  double s10$a;
  double s10$b;
  double s10$g;
  double s10$r;
  double s2$a;
  double s2$b;
  double s2$g;
  double s2$r;
  double s7$a;
  double s7$b;
  double s7$g;
  double s7$r;
#endif
  double sdir;
  double sustain$exp;
  double t$d0$length;
  double t$d0$sloop;
  double t$d0$splay;
  double t$d1$length;
  double t$d1$sloop;
  double t$d1$splay;
  double t$e0$a;
  double t$e0$a2;
  double t$e0$r;
  double t$e0$r2;
  double t$e0$s;
  double t$e1$a;
  double t$e1$a2;
  double t$e1$r;
  double t$e1$r2;
  double t$e1$s;
  double t$e2$a;
  double t$e2$a2;
  double t$e2$r;
  double t$e2$r2;
  double t$e2$s;
  double t$e3$a;
  double t$e3$a2;
  double t$e3$r;
  double t$e3$r2;
  double t$e3$s;
  double t$e4$a;
  double t$e4$a2;
  double t$e4$r;
  double t$e4$r2;
  double t$e4$s;
  //----------------------------------------------------------------------------
  void init_init_variables()
  {
    _playbackinit = 0;
    adir          = 0;
    attack$exp    = 0;
    buildstr      = 0;
    l0$end        = 0;
    l0$expval     = 0;
    l0$floorindex = 0;
    l0$frac       = 0;
    l0$hi         = 0;
    l0$i          = 0;
    l0$index      = 0;
    l0$invstep    = 0;
    l0$len        = 0;
    l0$lo         = 0;
    l0$maxval     = 0;
    l0$start      = 0;
    l0$v          = 0;
    l1$end        = 0;
    l1$expval     = 0;
    l1$floorindex = 0;
    l1$frac       = 0;
    l1$hi         = 0;
    l1$i          = 0;
    l1$index      = 0;
    l1$invstep    = 0;
    l1$len        = 0;
    l1$lo         = 0;
    l1$maxval     = 0;
    l1$start      = 0;
    l1$v          = 0;
    lutmem        = 0;
#if 0
    m0$a          = 0;
    m0$b          = 0;
    m0$g          = 0;
    m0$r          = 0;
    m1$a          = 0;
    m1$b          = 0;
    m1$g          = 0;
    m1$r          = 0;
#endif
    mtr$att  = 0;
    mtr$sus  = 0;
    norm     = 0;
    output   = 0;
    predelay = 0;
    prm$sens = 0;
#if 0
    s1$a        = 0;
    s1$b        = 0;
    s1$g        = 0;
    s1$r        = 0;
    s10$a       = 0;
    s10$b       = 0;
    s10$g       = 0;
    s10$r       = 0;
    s2$a        = 0;
    s2$b        = 0;
    s2$g        = 0;
    s2$r        = 0;
    s7$a        = 0;
    s7$b        = 0;
    s7$g        = 0;
    s7$r        = 0;
#endif
    sdir        = 0;
    sustain$exp = 0;
    t$d0$length = 0;
    t$d0$sloop  = 0;
    t$d0$splay  = 0;
    t$d1$length = 0;
    t$d1$sloop  = 0;
    t$d1$splay  = 0;
    t$e0$a      = 0;
    t$e0$a2     = 0;
    t$e0$r      = 0;
    t$e0$r2     = 0;
    t$e0$s      = 0;
    t$e1$a      = 0;
    t$e1$a2     = 0;
    t$e1$r      = 0;
    t$e1$r2     = 0;
    t$e1$s      = 0;
    t$e2$a      = 0;
    t$e2$a2     = 0;
    t$e2$r      = 0;
    t$e2$r2     = 0;
    t$e2$s      = 0;
    t$e3$a      = 0;
    t$e3$a2     = 0;
    t$e3$r      = 0;
    t$e3$r2     = 0;
    t$e3$s      = 0;
    t$e4$a      = 0;
    t$e4$a2     = 0;
    t$e4$r      = 0;
    t$e4$r2     = 0;
    t$e4$s      = 0;
  }
  //----------------------------------------------------------------------------
  // global/stateful variables for section "block"
  double amax;
  double smax;
  double t$d0$sindex;
  double t$d1$sindex;
  double t$dryl;
  double t$dryr;
  double t$e0$e;
  double t$e0$tmp;
  double t$e1$e;
  double t$e1$tmp;
  double t$e2$e;
  double t$e2$tmp;
  double t$e3$e;
  double t$e3$tmp;
  double t$e4$e;
  double t$e4$tmp;
  double t$outl;
  double t$outr;
  double t$sgn$at;
  double t$sgn$c;
  double t$sgn$in;
  double t$sgn$su;
  //----------------------------------------------------------------------------
  void init_block_variables()
  {
    amax        = 0;
    smax        = 0;
    t$d0$sindex = 0;
    t$d1$sindex = 0;
    t$dryl      = 0;
    t$dryr      = 0;
    t$e0$e      = 0;
    t$e0$tmp    = 0;
    t$e1$e      = 0;
    t$e1$tmp    = 0;
    t$e2$e      = 0;
    t$e2$tmp    = 0;
    t$e3$e      = 0;
    t$e3$tmp    = 0;
    t$e4$e      = 0;
    t$e4$tmp    = 0;
    t$outl      = 0;
    t$outr      = 0;
    t$sgn$at    = 0;
    t$sgn$c     = 0;
    t$sgn$in    = 0;
    t$sgn$su    = 0;
  }

  plugin_context* plugcontext = nullptr;
  //----------------------------------------------------------------------------
public:
  void reset (plugin_context& pc)
  {
    plugcontext = &pc;
    init_init_variables();
    init_block_variables();
#if 0
    !0.; /* jsfx2cpp strings unsupported: was: "#define VAL(A) (A) */
    ;
    buildstr = 0.; /* jsfx2cpp strings unsupported: was: "Build 170506" */
#endif
    ;
    ;
#if 0
    init$rgba (1., 1., 1., 0.6, m0$r, m0$g, m0$b, m0$a);
    init$rgba (1., 1., 1., 0.6, m1$r, m1$g, m1$b, m1$a);
    init$rgba (1., 1., 1., 0.3, s1$r, s1$g, s1$b, s1$a);
    init$rgba (1., 1., 1., 0.3, s2$r, s2$g, s2$b, s2$a);
    init$rgba (1., 1., 1., 0.3, s7$r, s7$g, s7$b, s7$a);
    init$rgba (1., 1., 1., 0.3, s10$r, s10$g, s10$b, s10$a);
#endif
#if 1
    // init$fillenvlut:  0 - 10000
    // init$fillenvlut:  10000 - 20000
    // init$delayinit: 20000 - 20400
    // init$delayinit: 20400 - 20800
    heap_reset (20800);
#endif
    init$transuinit (
      t$e0$a,
      t$e0$r,
      t$e0$s,
      t$e0$a2,
      t$e0$r2,
      t$e1$a,
      t$e1$r,
      t$e1$s,
      t$e1$a2,
      t$e1$r2,
      t$e2$a,
      t$e2$r,
      t$e2$s,
      t$e2$a2,
      t$e2$r2,
      t$e3$a,
      t$e3$r,
      t$e3$s,
      t$e3$a2,
      t$e3$r2,
      t$e4$a,
      t$e4$r,
      t$e4$s,
      t$e4$a2,
      t$e4$r2,
      t$d0$splay,
      t$d0$sloop,
      t$d0$length,
      t$d1$splay,
      t$d1$sloop,
      t$d1$length);
    _playbackinit = 0.;
    mtr$att       = 1.;
    mtr$sus       = 1.;
    slider();
  }
  //----------------------------------------------------------------------------
private:
  void slider()
  {
    double s1$value  = 0.;
    double s10$value = 0.;
    double s2$value  = 0.;
    double s7$value  = 0.;
    s1$value         = get_slider_slider1();
    s2$value         = get_slider_slider2();
    s7$value         = get_slider_slider7();
    s10$value        = get_slider_slider10();
    init$processsliders();
    ;
  }
  //----------------------------------------------------------------------------
public:
  template <class T>
  void process (crange<T*> outs, crange<T const*> ins, uint samples)
  {
    assert (outs.size() >= (n_outputs * (uint) bus_type));
    assert (ins.size() >= (n_inputs * (uint) bus_type));
    double inl      = 0.;
    double inr      = 0.;
    double mtr$over = 0.;

    if (!_playbackinit) {
      predelay = (jsfx_specialvar_get_srate() / 44100.) * 88.;
      jsfx_specialvar_set_pdc_delay (predelay);
      jsfx_specialvar_set_pdc_bot_ch (0.);
      jsfx_specialvar_set_pdc_top_ch (2.);
      _playbackinit = 1.;
    }
    if (attack$exp) {
      amax = std::max (amax, t$sgn$at);
    }
    if (sustain$exp) {
      smax = std::max (smax, t$sgn$su);
    }
    mtr$att = [&] {
      if (adir > 0.) {
        return 1. + amax;
      }
      else {
        return 1. - amax;
      }
    }();
    mtr$sus = [&] {
      if (sdir > 0.) {
        return 1. + smax;
      }
      else {
        return 1. - smax;
      }
    }();
    norm = (jsfx_rand (1.) * 0.000000000000001);
    ;
    for (int $$i = 0, $$end = samples; $$i < $$end; ++$$i) {
      auto& spl0 = outs[0][i];
      auto& spl1 = outs[1][i];
      spl0       = ins[0][i];
      spl1       = ins[1][i];

      inl = spl0;
      inr = spl1;
      init$transu (
        inl,
        inr,
        t$sgn$in,
        t$sgn$c,
        t$dryl,
        t$dryr,
        t$sgn$at,
        t$sgn$su,
        t$outl,
        t$outr,
        t$e0$tmp,
        t$e0$s,
        t$e0$e,
        t$e0$r,
        t$e0$r2,
        t$d0$sloop,
        t$d0$sindex,
        t$d0$length,
        t$d0$splay,
        t$d1$sloop,
        t$d1$sindex,
        t$d1$length,
        t$d1$splay,
        t$e1$tmp,
        t$e1$s,
        t$e1$e,
        t$e1$a,
        t$e1$a2,
        t$e2$tmp,
        t$e2$s,
        t$e2$e,
        t$e2$a,
        t$e2$a2,
        t$e3$tmp,
        t$e3$s,
        t$e3$e,
        t$e3$r,
        t$e3$r2,
        t$e4$tmp,
        t$e4$s,
        t$e4$e,
        t$e4$a,
        t$e4$a2);
      spl0 = t$outl;
      spl1 = t$outr;
      spl0 *= output;
      spl1 *= output;
      if ((std::abs (spl0) > 0.989 || std::abs (spl1) > 0.989)) {
        spl0     = std::min (std::max (spl0, (T) -0.989), (T) 0.989);
        spl1     = std::min (std::max (spl1, (T) -0.989), (T) 0.989);
        mtr$over = 1.;
      };
    }
  }
  // functions for section "init"
private:
  //----------------------------------------------------------------------------
  double init$curve (double input, double expval)
  {
    input = 1. / (input + 1.);
    input = 1. - eel2_pow (input, expval);
    return input;
  }
  //----------------------------------------------------------------------------
  double init$delay (
    double  input,
    double& sloop,
    double& sindex,
    double& length,
    double& splay)
  {
    heap (sloop + sindex) = input;
    sindex += 1.;
#if 0
    if (sindex > length) {
#else
    if (sindex >= length) {
#endif
    sindex = 0.;
  }
  return heap (splay + sindex);
}
//----------------------------------------------------------------------------
double
init$delayinit (
  double  start,
  double  end,
  double& splay,
  double& sloop,
  double& length)
{
  splay  = start;
  sloop  = splay;
  length = end - start;
  return length;
}
//----------------------------------------------------------------------------
double init$fillenvlut (
  double  start,
  double  end,
  double  step,
  double& len,
  double& maxval,
  double& start_,
  double& end_,
  double& invstep,
  double& i,
  double& v,
  double& expval)
{
  len     = end - start;
  maxval  = len * step;
  start_  = start;
  end_    = end;
  invstep = 1. / step;
  i       = 0.;
  return [&] {
    double $$loop_ret_0 = {};
    for (int $$i = 0, $$end = std::max (0, (int) (len)); $$i < $$end; ++$$i) {
      v                 = i * step;
      lutmem            = start;
      heap (lutmem + i) = init$curve (v, expval);
      i += 1.;
      $$loop_ret_0 = i;
    }
    return $$loop_ret_0;
  }();
}
//----------------------------------------------------------------------------
double init$follower (
  double  in,
  double& tmp,
  double& s,
  double& e,
  double& r,
  double& r2,
  double& a,
  double& a2)
{
  tmp = std::max (in + s * (tmp - in), in);
  (e = r * e + r2 * tmp);
  return [&] {
    if (e < tmp) {
      (e = a * e + a2 * tmp);
      return e;
    }
    else {
      return e;
    }
  }();
}
//----------------------------------------------------------------------------
double init$followerinit (
  double  attack,
  double  release,
  double  smoothing,
  double& a,
  double& r,
  double& s,
  double& a2,
  double& r2)
{
  a  = std::exp (-1. / (jsfx_specialvar_get_srate() * attack / 1000.));
  r  = std::exp (-1. / (jsfx_specialvar_get_srate() * release / 1000.));
  s  = std::exp (-1. / (jsfx_specialvar_get_srate() * smoothing / 1000.));
  a2 = 1. - a;
  r2 = 1. - r;
  return r2;
}
//----------------------------------------------------------------------------
double init$followerzeroatt (
  double  in,
  double& tmp,
  double& s,
  double& e,
  double& r,
  double& r2)
{
  tmp = std::max (in + s * (tmp - in), in);
  (e = r * e + r2 * tmp);
  return [&] {
    if (e < tmp) {
      (e = tmp);
      return e;
    }
    else {
      return e;
    }
  }();
}
//----------------------------------------------------------------------------
double init$followerzerorel (
  double  in,
  double& tmp,
  double& s,
  double& e,
  double& a,
  double& a2)
{
  tmp = std::max (in + s * (tmp - in), in);
  (e = tmp);
  return [&] {
    if (e < tmp) {
      (e = a * e + a2 * tmp);
      return e;
    }
    else {
      return e;
    }
  }();
}
//----------------------------------------------------------------------------
double init$getlutval (
  double  in,
  double& index,
  double& invstep,
  double& end,
  double& floorindex,
  double& start,
  double& lo,
  double& hi,
  double& frac)
{
  index      = std::max (std::min (in * invstep, end), 0.);
  floorindex = std::floor (index);
  lutmem     = start;
  lo         = heap (lutmem + floorindex);
  hi         = heap (lutmem + (floorindex + 1.));
  frac       = index - floorindex;
  return init$interpolate (lo, hi, frac);
}
//----------------------------------------------------------------------------
double init$hfcut (double input, double& n0, double& weight, double& out)
{
  (n0 += ((input - n0) * weight));
  out = n0;
  return out;
}
//----------------------------------------------------------------------------
double init$hflfinit (double freq, double& n0, double& weight)
{
  n0     = 0.;
  weight = 1.
    - std::exp (-2. * 3.141592653589793 * freq / jsfx_specialvar_get_srate());
  return weight;
}
//----------------------------------------------------------------------------
double init$interpolate (double a, double b, double x)
{
  return a + ((b - a) * x);
}
//----------------------------------------------------------------------------
double init$lfcut (double input, double& n0, double& weight, double& out)
{
  (n0 += ((input - n0) * weight));
  out = input - n0;
  return out;
}
//----------------------------------------------------------------------------
double init$processsliders()
{
  attack$exp = std::abs (get_slider_slider1() / 10.);
  adir       = jsfx_sign (get_slider_slider1());
  attack$exp = [&] {
    if (adir > 0.) {
      return eel2_pow (attack$exp, 2.) * 20.;
    }
    else {
      return eel2_pow (attack$exp, 2.) * 5.;
    }
  }();
  l0$expval = attack$exp;
#if 0
    init$fillenvlut (
      100000.,
      110000.,
      0.01,
      l0$len,
      l0$maxval,
      l0$start,
      l0$end,
      l0$invstep,
      l0$i,
      l0$v,
      l0$expval);
#else
    init$fillenvlut (
      0.,
      10000.,
      0.01,
      l0$len,
      l0$maxval,
      l0$start,
      l0$end,
      l0$invstep,
      l0$i,
      l0$v,
      l0$expval);
#endif
  sustain$exp = std::abs (get_slider_slider2() / 10.);
  sustain$exp = eel2_pow (sustain$exp, 2.) * 5.;
  sdir        = jsfx_sign (get_slider_slider2());
  l1$expval   = sustain$exp;
#if 0
    init$fillenvlut (
      200000.,
      210000.,
      0.01,
      l1$len,
      l1$maxval,
      l1$start,
      l1$end,
      l1$invstep,
      l1$i,
      l1$v,
      l1$expval);
#else
    init$fillenvlut (
      10000.,
      20000.,
      0.01,
      l1$len,
      l1$maxval,
      l1$start,
      l1$end,
      l1$invstep,
      l1$i,
      l1$v,
      l1$expval);
#endif
  output   = eel2_pow (10., (get_slider_slider10() / 20.));
  prm$sens = 1. - get_slider_slider7();
  init$transusetsmooth (
    init$interpolate (10., 1000., eel2_pow (prm$sens, 3.431)),
    t$e0$a,
    t$e0$r,
    t$e0$s,
    t$e0$a2,
    t$e0$r2);
  return [&] {
    if (sdir > 0.) {
      return init$transusetsustain (
        750., t$e4$a, t$e4$r, t$e4$s, t$e4$a2, t$e4$r2);
    }
    else {
      return init$transusetsustain (
        100., t$e4$a, t$e4$r, t$e4$s, t$e4$a2, t$e4$r2);
    }
  }();
}
//----------------------------------------------------------------------------
#if 0
  double init$rgba (
    double  r,
    double  g,
    double  b,
    double  a,
    double& r,
    double& g,
    double& b,
    double& a)
  {
    r = r;
    g = g;
    b = b;
    a = a;
    return a;
  }
#endif
//----------------------------------------------------------------------------
double init$rms (double input, double& s, double& weight, double& rms)
{
  s += weight * (eel2_pow (input, 2.) - s);
  rms = std::sqrt (s);
  return rms;
}
//----------------------------------------------------------------------------
double init$rmsinit (double weight_ms, double& weight)
{
  weight
    = 1. - std::exp (-1. / (weight_ms / 1000. * jsfx_specialvar_get_srate()));
  return weight;
}
//----------------------------------------------------------------------------
double init$transu (
  double  inl,
  double  inr,
  double& sgn$in,
  double& sgn$c,
  double& dryl,
  double& dryr,
  double& sgn$at,
  double& sgn$su,
  double& outl,
  double& outr,
  double& e0$tmp,
  double& e0$s,
  double& e0$e,
  double& e0$r,
  double& e0$r2,
  double& d0$sloop,
  double& d0$sindex,
  double& d0$length,
  double& d0$splay,
  double& d1$sloop,
  double& d1$sindex,
  double& d1$length,
  double& d1$splay,
  double& e1$tmp,
  double& e1$s,
  double& e1$e,
  double& e1$a,
  double& e1$a2,
  double& e2$tmp,
  double& e2$s,
  double& e2$e,
  double& e2$a,
  double& e2$a2,
  double& e3$tmp,
  double& e3$s,
  double& e3$e,
  double& e3$r,
  double& e3$r2,
  double& e4$tmp,
  double& e4$s,
  double& e4$e,
  double& e4$a,
  double& e4$a2)
{
  sgn$in = std::max (std::abs (inl), std::abs (inr)) + norm;
  sgn$in = eel2_pow (sgn$in, 0.5) * 2.;
  sgn$c  = init$followerzeroatt (sgn$in, e0$tmp, e0$s, e0$e, e0$r, e0$r2);
  dryl   = init$delay (inl, d0$sloop, d0$sindex, d0$length, d0$splay);
  inl    = dryl;
  dryr   = init$delay (inr, d1$sloop, d1$sindex, d1$length, d1$splay);
  inr    = dryr;
  if (attack$exp) {
    sgn$at
      = (sgn$c - init$followerzerorel (sgn$c, e1$tmp, e1$s, e1$e, e1$a, e1$a2));
    sgn$at = init$followerzerorel (sgn$at, e2$tmp, e2$s, e2$e, e2$a, e2$a2);
    sgn$at = init$getlutval (
      sgn$at,
      l0$index,
      l0$invstep,
      l0$end,
      l0$floorindex,
      l0$start,
      l0$lo,
      l0$hi,
      l0$frac);
    if (adir > 0.) {
      sgn$at *= 1.2;
      inl = (inl * sgn$at) + inl;
      inr = (inr * sgn$at) + inr;
    }
    if (adir < 0.) {
      inl -= (inl * sgn$at);
      inr -= (inr * sgn$at);
    }
  }
  if (sustain$exp) {
    sgn$su
      = (init$followerzeroatt (sgn$c, e3$tmp, e3$s, e3$e, e3$r, e3$r2) - sgn$c);
    sgn$su = init$followerzerorel (sgn$su, e4$tmp, e4$s, e4$e, e4$a, e4$a2);
    sgn$su = init$getlutval (
      sgn$su,
      l1$index,
      l1$invstep,
      l1$end,
      l1$floorindex,
      l1$start,
      l1$lo,
      l1$hi,
      l1$frac);
    if (sdir > 0.) {
      sgn$su *= 3.98;
      inl += (inl * sgn$su);
      inr += (inr * sgn$su);
    }
    if (sdir < 0.) {
      inl -= (inl * sgn$su);
      inr -= (inr * sgn$su);
    }
  }
  outl = inl;
  outr = inr;
  return outr;
}
//----------------------------------------------------------------------------
double init$transuinit (
  double& e0$a,
  double& e0$r,
  double& e0$s,
  double& e0$a2,
  double& e0$r2,
  double& e1$a,
  double& e1$r,
  double& e1$s,
  double& e1$a2,
  double& e1$r2,
  double& e2$a,
  double& e2$r,
  double& e2$s,
  double& e2$a2,
  double& e2$r2,
  double& e3$a,
  double& e3$r,
  double& e3$s,
  double& e3$a2,
  double& e3$r2,
  double& e4$a,
  double& e4$r,
  double& e4$s,
  double& e4$a2,
  double& e4$r2,
  double& d0$splay,
  double& d0$sloop,
  double& d0$length,
  double& d1$splay,
  double& d1$sloop,
  double& d1$length)
{
  init$followerinit (0., 50., 100., e0$a, e0$r, e0$s, e0$a2, e0$r2);
  init$followerinit (5., 0., 0., e1$a, e1$r, e1$s, e1$a2, e1$r2);
  init$followerinit (1., 0., 5., e2$a, e2$r, e2$s, e2$a2, e2$r2);
  init$followerinit (0., 50., 200., e3$a, e3$r, e3$s, e3$a2, e3$r2);
  init$followerinit (100., 0., 0., e4$a, e4$r, e4$s, e4$a2, e4$r2);
  predelay = (jsfx_specialvar_get_srate() / 44100.) * 88.;
#if 0
    init$delayinit (1000., 1000. + predelay, d0$splay, d0$sloop, d0$length);
    return init$delayinit (
      2000., 2000. + predelay, d1$splay, d1$sloop, d1$length);
#else
    init$delayinit (20000., 20000. + predelay, d0$splay, d0$sloop, d0$length);
    return init$delayinit (
      20400., 20400. + predelay, d1$splay, d1$sloop, d1$length);
#endif
}
//----------------------------------------------------------------------------
double init$transusetsmooth (
  double  val_ms,
  double& e0$a,
  double& e0$r,
  double& e0$s,
  double& e0$a2,
  double& e0$r2)
{
  return init$followerinit (0., 50., val_ms, e0$a, e0$r, e0$s, e0$a2, e0$r2);
}
//----------------------------------------------------------------------------
double init$transusetsustain (
  double  val_ms,
  double& e4$a,
  double& e4$r,
  double& e4$s,
  double& e4$a2,
  double& e4$r2)
{
  return init$followerinit (val_ms, 0., 0.5, e4$a, e4$r, e4$s, e4$a2, e4$r2);
}
}; }
} // namespace artv::sonic_anomaly

#pragma once
// Generated by jsfx2cpp.py. To be manually corrected.
// includes for environment function calls
#include <algorithm>
#include <cmath>
#include <cstdint>

#include "artv-common/dsp/own/classes/misc.hpp"
#include "artv-common/dsp/own/classes/plugin_context.hpp"
#include "artv-common/dsp/third_party/jsfx_engine/jsfx_engine.hpp"
#include "artv-common/dsp/types.hpp"
#include "artv-common/juce/parameter_definitions.hpp"
#include "artv-common/juce/parameter_types.hpp"
#include "artv-common/misc/misc.hpp"
#include "artv-common/misc/mp11.hpp"
#include "artv-common/misc/short_ints.hpp"
#include "artv-common/misc/xspan.hpp"

#if 0
// Issues happening just on the release version.
#define TRACK_COMP_DEBUG(...)
#else
#define TRACK_COMP_DEBUG(...) printf (__VA_ARGS__)
#endif

namespace artv { namespace chokehold {

class track_comp {
public:
  static constexpr dsp_types dsp_type  = dsp_types::dynamics;
  static constexpr bus_types bus_type  = bus_types::stereo;
  static constexpr uint      n_inputs  = 1;
  static constexpr uint      n_outputs = 1;
  //----------------------------------------------------------------------------
private:
  //----------------------------------------------------------------------------
  // definitions for environment function calls
  static double eel2_eq (double lhs, double rhs)
  {
    return (double) (std::fabs (lhs - rhs) < 0.00001);
  }
  static bool   eel2_ne (double lhs, double rhs) { return !eel2_eq (lhs, rhs); }
  static double eel2_pow (double lhs, double rhs)
  {
    return std::pow (lhs, rhs);
  }
  static double jsfx_invsqrt (double v) { return 1. / sqrt (v); }
  double        jsfx_sign (double value)
  {
    auto v = *((uint64_t*) ((void*) &value));
    return (v == 0) ? 0. : (v & (1ull << 63)) ? -1. : 1.;
  }
  static double jsfx_sqr (double v) { return v * v; }

  //----------------------------------------------------------------------------
  // stubs for JSFX special variables

  double jsfx_specialvar_get_srate() { return plugcontext->get_sample_rate(); }

  //----------------------------------------------------------------------------
public:
#if 0
  void set_dbgain_slider (float v)
  {
    // Original slider line: slider1: dBGain=0<-12, 12, 0.01> Input Gain [dB]
    // Range: min:-12.0, max:12.0, default: 0.0, step: 0.01
    if (v == dbgain) {
      return;
    }
    dbgain = v;
    slider();
  }
#else
  // Snippet for parameter boilerplate in the authors framework....
  struct dbgain_tag {};

  void set (dbgain_tag, float v)
  {
    // Original slider line: slider1: dBGain=0<-12, 12, 0.01> Input Gain [dB]
    // Range: min:-12.0, max:12.0, default: 0.0, step: 0.01
    if (v == dbgain) {
      return;
    }
    dbgain = v;
    slider();
  }

  static constexpr auto get_parameter (dbgain_tag)
  {
    // Original slider line: slider1: dBGain=0<-12, 12, 0.01> Input Gain [dB]
    return float_param ("dB", -24.0, 24.0, 0.0, 0.01);
  }

#endif
#if 0
  void set_compfeedbk_slider (float v)
  {
    // Original slider line: slider2: compFeedbk=25<0, 100, 0.01> Feedback [%]
    // Range: min:0.0, max:100.0, default: 25.0, step: 0.01
    if (v == compfeedbk) {
      return;
    }
    compfeedbk = v;
    slider();
  }
#else
  // Snippet for parameter boilerplate in the authors framework....
  struct compfeedbk_tag {};

  void set (compfeedbk_tag, float v)
  {
    // Original slider line: slider2: compFeedbk=25<0, 100, 0.01> Feedback [%]
    // Range: min:0.0, max:100.0, default: 25.0, step: 0.01
    if (v == compfeedbk) {
      return;
    }
    compfeedbk = v;
    slider();
  }

  static constexpr auto get_parameter (compfeedbk_tag)
  {
    // Original slider line: slider2: compFeedbk=25<0, 100, 0.01> Feedback [%]
    return float_param ("%", 0.0, 100.0, 25.0, 0.01);
  }

#endif
#if 0
  void set_compthresh_slider (float v)
  {
    // Original slider line: slider3: compThresh=0<-60, 0, 0.01> Threshold [dB]
    // Range: min:-60.0, max:0.0, default: 0.0, step: 0.01
    if (v == compthresh) {
      return;
    }
    compthresh = v;
    slider();
  }
#else
  // Snippet for parameter boilerplate in the authors framework....
  struct compthresh_tag {};

  void set (compthresh_tag, float v)
  {
    // Original slider line: slider3: compThresh=0<-60, 0, 0.01> Threshold [dB]
    // Range: min:-60.0, max:0.0, default: 0.0, step: 0.01
    if (v == compthresh) {
      return;
    }
    compthresh = v;
    slider();
  }

  static constexpr auto get_parameter (compthresh_tag)
  {
    // Original slider line: slider3: compThresh=0<-60, 0, 0.01> Threshold [dB]
    return float_param ("dB", -60.0, 0.0, 0.0, 0.01);
  }

#endif
#if 0
  void set_compratio_slider (float v)
  {
    // Original slider line: slider4: compRatio=4<0.1, 20, 0.1> Ratio
    // Range: min:0.1, max:20.0, default: 4.0, step: 0.1
    if (v == compratio) {
      return;
    }
    compratio = v;
    slider();
  }
#else
  // Snippet for parameter boilerplate in the authors framework....
  struct compratio_tag {};

  void set (compratio_tag, float v)
  {
    // Original slider line: slider4: compRatio=4<0.1, 20, 0.1> Ratio
    // Range: min:0.1, max:20.0, default: 4.0, step: 0.1
    if (v == compratio) {
      return;
    }
    compratio = v;
    slider();
  }

  static constexpr auto get_parameter (compratio_tag)
  {
    // Original slider line: slider4: compRatio=4<0.1, 20, 0.1> Ratio
    return float_param ("", 0.8, 20.0, 4.0, 0.05, 0.6);
  }

#endif
#if 0
  void set_compattack_slider (float v)
  {
    // Original slider line: slider5: compAttack=10<0.001, 100, 0.01> Attack
    // [ms] Range: min:0.001, max:100.0, default: 10.0, step: 0.01
    if (v == compattack) {
      return;
    }
    compattack = v;
    slider();
  }
#else
  // Snippet for parameter boilerplate in the authors framework....
  struct compattack_tag {};

  void set (compattack_tag, float v)
  {
    // Original slider line: slider5: compAttack=10<0.001, 100, 0.01> Attack
    // [ms] Range: min:0.001, max:100.0, default: 10.0, step: 0.01
    if (v == compattack) {
      return;
    }
    compattack = v;
    slider();
  }

  static constexpr auto get_parameter (compattack_tag)
  {
    // Original slider line: slider5: compAttack=10<0.001, 100, 0.01> Attack
    // [ms]
    return float_param ("ms", 0.001, 100.0, 10.0, 0.01, 0.6);
  }

#endif
#if 0
  void set_comprelease_slider (float v)
  {
    // Original slider line: slider6: compRelease=200<20, 1500, 0.01> Release
    // [ms] Range: min:20.0, max:1500.0, default: 200.0, step: 0.01
    if (v == comprelease) {
      return;
    }
    comprelease = v;
    slider();
  }
#else
  // Snippet for parameter boilerplate in the authors framework....
  struct comprelease_tag {};

  void set (comprelease_tag, float v)
  {
    // Original slider line: slider6: compRelease=200<20, 1500, 0.01> Release
    // [ms] Range: min:20.0, max:1500.0, default: 200.0, step: 0.01
    if (v == comprelease) {
      return;
    }
    comprelease = v;
    slider();
  }

  static constexpr auto get_parameter (comprelease_tag)
  {
    // Original slider line: slider6: compRelease=200<20, 1500, 0.01> Release
    // [ms]
    return float_param ("ms", 20.0, 1500.0, 200.0, 0.01, 0.6);
  }

#endif
#if 0
  void set_compwindow_slider (float v)
  {
    // Original slider line: slider7: compWindow=0<0,150,0.01> RMS Window [ms]
    // Range: min:0.0, max:150.0, default: 0.0, step: 0.01
    if (v == compwindow) {
      return;
    }
    compwindow = v;
    slider();
  }
#else
  // Snippet for parameter boilerplate in the authors framework....
  struct compwindow_tag {};

  void set (compwindow_tag, float v)
  {
    // Original slider line: slider7: compWindow=0<0,150,0.01> RMS Window [ms]
    // Range: min:0.0, max:150.0, default: 0.0, step: 0.01
    if (v == compwindow) {
      return;
    }
    compwindow = v;
    slider();
  }

  static constexpr auto get_parameter (compwindow_tag)
  {
    // Original slider line: slider7: compWindow=0<0,150,0.01> RMS Window [ms]
    return float_param ("ms", 0.0, 150.0, 0.0, 0.01, 0.6);
  }

#endif
#if 0
  void set_compknee_slider (float v)
  {
    // Original slider line: slider8: compKnee=4.5<0,12,0.01> Hard/Soft Knee
    // [dB] Range: min:0.0, max:12.0, default: 4.5, step: 0.01
    if (v == compknee) {
      return;
    }
    compknee = v;
    slider();
  }
#else
  // Snippet for parameter boilerplate in the authors framework....
  struct compknee_tag {};

  void set (compknee_tag, float v)
  {
    // Original slider line: slider8: compKnee=4.5<0,12,0.01> Hard/Soft Knee
    // [dB] Range: min:0.0, max:12.0, default: 4.5, step: 0.01
    if (v == compknee) {
      return;
    }
    compknee = v;
    slider();
  }

  static constexpr auto get_parameter (compknee_tag)
  {
    // Original slider line: slider8: compKnee=4.5<0,12,0.01> Hard/Soft Knee
    // [dB]
    return float_param ("dB", 0.0, 12.0, 4.5, 0.01);
  }

#endif
#if 0
  void set_comprange_slider (float v)
  {
    // Original slider line: slider9: compRange=-40<-40, 0, 0.01> Comp. Range
    // [dB] Range: min:-40.0, max:0.0, default: -40.0, step: 0.01
    if (v == comprange) {
      return;
    }
    comprange = v;
    slider();
  }
#else
  // Snippet for parameter boilerplate in the authors framework....
  struct comprange_tag {};

  void set (comprange_tag, float v)
  {
    // Original slider line: slider9: compRange=-40<-40, 0, 0.01> Comp. Range
    // [dB] Range: min:-40.0, max:0.0, default: -40.0, step: 0.01
    if (v == comprange) {
      return;
    }
    comprange = v;
    slider();
  }

  static constexpr auto get_parameter (comprange_tag)
  {
    // Original slider line: slider9: compRange=-40<-40, 0, 0.01> Comp. Range
    // [dB]
    return float_param ("dB", -40.0, 0.0, -40.0, 0.01);
  }

#endif
#if 0
  void set_linkamount_slider (float v)
  {
    // Original slider line: slider10:linkAmount=50<0, 100, 1> Stereo Link [%]
    // Range: min:0.0, max:100.0, default: 50.0, step: 1.0
    if (v == linkamount) {
      return;
    }
    linkamount = v;
    slider();
  }
#else
  // Snippet for parameter boilerplate in the authors framework....
  struct linkamount_tag {};

  void set (linkamount_tag, float v)
  {
    // Original slider line: slider10:linkAmount=50<0, 100, 1> Stereo Link [%]
    // Range: min:0.0, max:100.0, default: 50.0, step: 1.0
    if (v == linkamount) {
      return;
    }
    linkamount = v;
    slider();
  }

  static constexpr auto get_parameter (linkamount_tag)
  {
    // Original slider line: slider10:linkAmount=50<0, 100, 1> Stereo Link [%]
    return float_param ("%", 0.0, 100.0, 50.0, 1.0);
  }

#endif
#if 0
  void set_scfreq_slider (float v)
  {
    // Original slider line: slider11:scFreq=70<20, 350, 1> SC High Pass [Hz]
    // Range: min:20.0, max:350.0, default: 70.0, step: 1.0
    if (v == scfreq) {
      return;
    }
    scfreq = v;
    slider();
  }
#else
  // Snippet for parameter boilerplate in the authors framework....
  struct scfreq_tag {};

  void set (scfreq_tag, float v)
  {
    // Original slider line: slider11:scFreq=70<20, 350, 1> SC High Pass [Hz]
    // Range: min:20.0, max:350.0, default: 70.0, step: 1.0
    if (v == scfreq) {
      return;
    }
    scfreq = v;
    slider();
  }

  static constexpr auto get_parameter (scfreq_tag)
  {
    // Original slider line: slider11:scFreq=70<20, 350, 1> SC High Pass [Hz]
    return float_param ("Hz", 20.0, 350.0, 70.0, 1.0);
  }

#endif
#if 0
  void set_autogain_slider (float v)
  {
    // Original slider line: slider12:autoGain=0<0,1,{Enabled,Disabled}> Auto
    // Makeup Gain Range: min:0.0, max:1.0, default: 0.0, step: None
    if (v == autogain) {
      return;
    }
    autogain = v;
    slider();
  }
#else
  // Snippet for parameter boilerplate in the authors framework....
  struct autogain_tag {};

  void set (autogain_tag, int v)
  {
    // Original slider line: slider12:autoGain=0<0,1,{Enabled,Disabled}> Auto
    // Makeup Gain Range: min:0.0, max:1.0, default: 0.0, step: None
    if ((float) v == autogain) {
      return;
    }
    autogain = (float) v;
    slider();
  }

  static constexpr auto get_parameter (autogain_tag)
  {
    // Original slider line: slider12:autoGain=0<0,1,{Enabled,Disabled}> Auto
    // Makeup Gain
    return choice_param (1, make_cstr_array ("On", "Off"));
  }

#endif
#if 0
  void set_saturation_slider (float v)
  {
    // Original slider line: slider13:saturation=25<0,100,0.01> Saturation [%]
    // Range: min:0.0, max:100.0, default: 25.0, step: 0.01
    if (v == saturation) {
      return;
    }
    saturation = v;
    slider();
  }
#else
  // Snippet for parameter boilerplate in the authors framework....
  struct saturation_tag {};

  void set (saturation_tag, float v)
  {
    // Original slider line: slider13:saturation=25<0,100,0.01> Saturation [%]
    // Range: min:0.0, max:100.0, default: 25.0, step: 0.01
    if (v == saturation) {
      return;
    }
    saturation = v;
    slider();
  }

  static constexpr auto get_parameter (saturation_tag)
  {
    // Original slider line: slider13:saturation=25<0,100,0.01> Saturation [%]
    return float_param ("%", 0.0, 100.0, 25.0, 0.01);
  }

#endif
#if 0
  void set_dbtrim_slider (float v)
  {
    // Original slider line: slider14:dBTrim=0<-12, 12, 0.01> Output Gain [dB]
    // Range: min:-12.0, max:12.0, default: 0.0, step: 0.01
    if (v == dbtrim) {
      return;
    }
    dbtrim = v;
    slider();
  }
#else
  // Snippet for parameter boilerplate in the authors framework....
  struct dbtrim_tag {};

  void set (dbtrim_tag, float v)
  {
    // Original slider line: slider14:dBTrim=0<-12, 12, 0.01> Output Gain [dB]
    // Range: min:-12.0, max:12.0, default: 0.0, step: 0.01
    if (v == dbtrim) {
      return;
    }
    dbtrim = v;
    slider();
  }

  static constexpr auto get_parameter (dbtrim_tag)
  {
    // Original slider line: slider14:dBTrim=0<-12, 12, 0.01> Output Gain [dB]
    return float_param ("dB", -24.0, 24.0, 0.0, 0.01);
  }

#endif
#if 0
  void set_pctmix_slider (float v)
  {
    // Original slider line: slider15:pctMix=100<0,100,0.01> Dry/Wet Mix [%]
    // Range: min:0.0, max:100.0, default: 100.0, step: 0.01
    if (v == pctmix) {
      return;
    }
    pctmix = v;
    slider();
  }
#else
  // Snippet for parameter boilerplate in the authors framework....
  struct pctmix_tag {};

  void set (pctmix_tag, float v)
  {
    // Original slider line: slider15:pctMix=100<0,100,0.01> Dry/Wet Mix [%]
    // Range: min:0.0, max:100.0, default: 100.0, step: 0.01
    if (v == pctmix) {
      return;
    }
    pctmix = v;
    slider();
  }

  static constexpr auto get_parameter (pctmix_tag)
  {
    // Original slider line: slider15:pctMix=100<0,100,0.01> Dry/Wet Mix [%]
    return float_param ("%", 0.0, 100.0, 100.0, 0.01);
  }

#endif
#if 0
  void set_routing_slider (float v)
  {
    // Original slider line: slider16:routing=0<0, 3,{Stereo (internal
    // SC),Stereo (external SC 3-4),Mono (L),Mono (R),Mono (signal L / key
    // R),Mono (key L / signal R)}> Routing Range: min:0.0, max:3.0, default:
    // 0.0, step: None
    if (v == routing) {
      return;
    }
    routing = v;
    slider();
  }
#else
  // Snippet for parameter boilerplate in the authors framework....
  struct routing_tag {};

  void set (routing_tag, float v)
  {
    // Original slider line: slider16:routing=0<0, 3,{Stereo (internal
    // SC),Stereo (external SC 3-4),Mono (L),Mono (R),Mono (signal L / key
    // R),Mono (key L / signal R)}> Routing Range: min:0.0, max:3.0, default:
    // 0.0, step: None
    if (v == routing) {
      return;
    }
    routing = v;
    slider();
  }

  static constexpr auto get_parameter (routing_tag)
  {
    // Original slider line: slider16:routing=0<0, 3,{Stereo (internal
    // SC),Stereo (external SC 3-4),Mono (L),Mono (R),Mono (signal L / key
    // R),Mono (key L / signal R)}> Routing
    return float_param ("", 0.0, 3.0, 0.0);
  }

#endif
#if 0
#else
  // Snippet for parameter boilerplate in the authors framework....
  using parameters = mp_list<
    dbgain_tag,
    compfeedbk_tag,
    compthresh_tag,
    compratio_tag,
    compattack_tag,
    comprelease_tag,
    compwindow_tag,
    compknee_tag,
    comprange_tag,
    linkamount_tag,
    scfreq_tag,
    autogain_tag,
    saturation_tag,
    dbtrim_tag,
    pctmix_tag,
    routing_tag>;
#endif
  //----------------------------------------------------------------------------
  // global/stateful variables for section "init"
private:
  double autogain;
  double compattack;
  double compfeedbk;
  double compknee;
  double comprange;
  double compratio;
  double comprelease;
  double compthresh;
  double compwindow;
  double dbgain;
  double dbtrim;
  double dcblockerl;
  double dcblockerr;
  double floatfloor;
  double halfpi;
  double linkamount;
  double m_ln10_20;
  double pctmix;
  double routing;
  double satl$satenv$coeff;
  double satr$satenv$coeff;
  double satspeed;
  double saturation;
  double scfreq;
  //----------------------------------------------------------------------------
  void init_init_variables()
  {
    autogain          = 0.;
    compattack        = 0.;
    compfeedbk        = 0.;
    compknee          = 0.;
    comprange         = 0.;
    compratio         = 0.;
    comprelease       = 0.;
    compthresh        = 0.;
    compwindow        = 0.;
    dbgain            = 0.;
    dbtrim            = 0.;
    dcblockerl        = 0.;
    dcblockerr        = 0.;
    floatfloor        = 0.;
    halfpi            = 0.;
    linkamount        = 0.;
    m_ln10_20         = 0.;
    pctmix            = 0.;
    routing           = 0.;
    satl$satenv$coeff = 0.;
    satr$satenv$coeff = 0.;
    satspeed          = 0.;
    saturation        = 0.;
    scfreq            = 0.;
  }
  //----------------------------------------------------------------------------
  // global/stateful variables for section "slider"
private:
  double compl$attrel$coeffatt;
  double compl$attrel$coeffrel;
  double compl$autogain;
  double compl$calc$knee;
  double compl$calc$kneelower;
  double compl$calc$kneeupper;
  double compl$calc$kneewidth;
  double compl$calc$makeup;
  double compl$calc$range;
  double compl$calc$ratio;
  double compl$calc$threshold;
  double compl$feedback;
  double compl$rms$rmsenv$coeff;
  double compr$attrel$coeffatt;
  double compr$attrel$coeffrel;
  double compr$autogain;
  double compr$calc$knee;
  double compr$calc$kneelower;
  double compr$calc$kneeupper;
  double compr$calc$kneewidth;
  double compr$calc$makeup;
  double compr$calc$range;
  double compr$calc$ratio;
  double compr$calc$threshold;
  double compr$feedback;
  double compr$rms$rmsenv$coeff;
  double drymix;
  double drywet;
  double filterl$a1;
  double filterl$a2;
  double filterl$a3;
  double filterl$m0;
  double filterl$m1;
  double filterl$m2;
  double filterr$a1;
  double filterr$a2;
  double filterr$a3;
  double filterr$m0;
  double filterr$m1;
  double filterr$m2;
  double gainin;
  double gainout;
  double lnkmix;
  double satmix;
  double splmix;
  double wetdry;
  //----------------------------------------------------------------------------
  void init_slider_variables()
  {
    compl$attrel$coeffatt  = 0.;
    compl$attrel$coeffrel  = 0.;
    compl$autogain         = 0.;
    compl$calc$knee        = 0.;
    compl$calc$kneelower   = 0.;
    compl$calc$kneeupper   = 0.;
    compl$calc$kneewidth   = 0.;
    compl$calc$makeup      = 0.;
    compl$calc$range       = 0.;
    compl$calc$ratio       = 0.;
    compl$calc$threshold   = 0.;
    compl$feedback         = 0.;
    compl$rms$rmsenv$coeff = 0.;
    compr$attrel$coeffatt  = 0.;
    compr$attrel$coeffrel  = 0.;
    compr$autogain         = 0.;
    compr$calc$knee        = 0.;
    compr$calc$kneelower   = 0.;
    compr$calc$kneeupper   = 0.;
    compr$calc$kneewidth   = 0.;
    compr$calc$makeup      = 0.;
    compr$calc$range       = 0.;
    compr$calc$ratio       = 0.;
    compr$calc$threshold   = 0.;
    compr$feedback         = 0.;
    compr$rms$rmsenv$coeff = 0.;
    drymix                 = 0.;
    drywet                 = 0.;
    filterl$a1             = 0.;
    filterl$a2             = 0.;
    filterl$a3             = 0.;
    filterl$m0             = 0.;
    filterl$m1             = 0.;
    filterl$m2             = 0.;
    filterr$a1             = 0.;
    filterr$a2             = 0.;
    filterr$a3             = 0.;
    filterr$m0             = 0.;
    filterr$m1             = 0.;
    filterr$m2             = 0.;
    gainin                 = 0.;
    gainout                = 0.;
    lnkmix                 = 0.;
    satmix                 = 0.;
    splmix                 = 0.;
    wetdry                 = 0.;
  }
  //----------------------------------------------------------------------------
  // global/stateful variables for section "block"
private:
  double compl$attrel$envelope;
  double compl$gr;
  double compl$rms$envelope;
  double compr$attrel$envelope;
  double compr$gr;
  double compr$rms$envelope;
  double filterl$ic1eq;
  double filterl$ic2eq;
  double filterl$v1;
  double filterl$v2;
  double filterl$v3;
  double filterr$ic1eq;
  double filterr$ic2eq;
  double filterr$v1;
  double filterr$v2;
  double filterr$v3;
  double satl$envelope;
  double satr$envelope;
  double spl0$statein;
  double spl0$stateout;
  double spl1$statein;
  double spl1$stateout;
  double spl2;
  double spl3;
  //----------------------------------------------------------------------------
  void init_block_variables()
  {
    compl$attrel$envelope = 0.;
    compl$gr              = 0.;
    compl$rms$envelope    = 0.;
    compr$attrel$envelope = 0.;
    compr$gr              = 0.;
    compr$rms$envelope    = 0.;
    filterl$ic1eq         = 0.;
    filterl$ic2eq         = 0.;
    filterl$v1            = 0.;
    filterl$v2            = 0.;
    filterl$v3            = 0.;
    filterr$ic1eq         = 0.;
    filterr$ic2eq         = 0.;
    filterr$v1            = 0.;
    filterr$v2            = 0.;
    filterr$v3            = 0.;
    satl$envelope         = 0.;
    satr$envelope         = 0.;
    spl0$statein          = 0.;
    spl0$stateout         = 0.;
    spl1$statein          = 0.;
    spl1$stateout         = 0.;
    spl2                  = 0.;
    spl3                  = 0.;
  }

  plugin_context* plugcontext;

public:
  void reset (plugin_context& pc)
  {
    plugcontext = &pc;
    init_init_variables();
    init_block_variables();

    dbgain      = 0.0;
    compfeedbk  = 25.0;
    compthresh  = 0.0;
    compratio   = 4.0;
    compattack  = 10.0;
    comprelease = 200.0;
    compwindow  = 0.0;
    compknee    = 4.5;
    comprange   = -40.0;
    linkamount  = 50.0;
    scfreq      = 70.0;
    autogain    = 0.0;
    saturation  = 25.0;
    dbtrim      = 0.0;
    pctmix      = 100.0;
    routing     = 0.0;
    m_ln10_20   = 8.68588963806503655302257837833210164588794011607333;
    floatfloor  = 0.0000000630957;
    halfpi      = 3.141592653589793 * 0.5;
    satspeed    = 50.0;
    ;
    init$satsetup (satspeed, satl$satenv$coeff);
    init$satsetup (satspeed, satr$satenv$coeff);
    dcblockerr = 0.0;
    dcblockerl = dcblockerr;
    slider();
  }
  //----------------------------------------------------------------------------
private:
  void slider()
  {
    init_slider_variables();
    double maxrange = 0.;
    maxrange        = [&] {
      if (eel2_eq (comprange, -40.)) {
        return -400.;
      }
      else {
        return comprange;
      }
    }();

    init$compsetup (
      compattack,
      comprelease,
      compwindow,
      compthresh,
      compratio,
      compknee,
      maxrange,
      compfeedbk,
      autogain,
      compl$feedback,
      compl$autogain,
      compl$attrel$coeffatt,
      compl$attrel$coeffrel,
      compl$rms$rmsenv$coeff,
      compl$calc$threshold,
      compl$calc$ratio,
      compl$calc$makeup,
      compl$calc$knee,
      compl$calc$kneewidth,
      compl$calc$kneeupper,
      compl$calc$kneelower,
      compl$calc$range);

    init$compsetup (
      compattack,
      comprelease,
      compwindow,
      compthresh,
      compratio,
      compknee,
      maxrange,
      compfeedbk,
      autogain,
      compr$feedback,
      compr$autogain,
      compr$attrel$coeffatt,
      compr$attrel$coeffrel,
      compr$rms$rmsenv$coeff,
      compr$calc$threshold,
      compr$calc$ratio,
      compr$calc$makeup,
      compr$calc$knee,
      compr$calc$kneewidth,
      compr$calc$kneeupper,
      compr$calc$kneelower,
      compr$calc$range);
    lnkmix = linkamount * 0.01;
    splmix = 1.0 - lnkmix;

    init$eqhp (
      scfreq,
      1.5,
      filterl$a1,
      filterl$a2,
      filterl$a3,
      filterl$m0,
      filterl$m1,
      filterl$m2);
    init$eqhp (
      scfreq,
      1.5,
      filterr$a1,
      filterr$a2,
      filterr$a3,
      filterr$m0,
      filterr$m1,
      filterr$m2);
    gainin  = init$dbtogain (dbgain);
    gainout = init$dbtogain (dbtrim);
    satmix  = saturation * 0.01;
    drymix  = 1.0 - satmix;
    wetdry  = pctmix * 0.01;
    drywet  = 1.0 - wetdry;
    ;
  }
  //----------------------------------------------------------------------------
public:
  template <class T>
  void process (xspan<T*> outs, xspan<T const*> ins, uint samples)
  {
    assert (outs.size() >= (n_outputs * (uint) bus_type));
    assert (ins.size() >= (n_inputs * (uint) bus_type));

    double dryl        = 0.;
    double dryr        = 0.;
    double keyl        = 0.;
    double keyr        = 0.;
    double linked      = 0.;
    double saturationl = 0.;
    double saturationr = 0.;

    for (uint $$i = 0.; $$i < samples; ++$$i) {
      auto& spl0 = outs[0][$$i];
      auto& spl1 = outs[1][$$i];
      spl0       = ins[0][$$i];
      spl1       = ins[1][$$i];

      dryl        = spl0;
      dryr        = spl1;
      keyr        = 0.0;
      keyl        = keyr;
      saturationr = 0.0;
      saturationl = saturationr;
      spl0 *= gainin;

      spl1 *= gainin;
      if (eel2_eq (routing, 0.)) {
        keyl = std::abs (init$eqtick (
          spl0,
          filterl$v3,
          filterl$ic2eq,
          filterl$v1,
          filterl$a1,
          filterl$ic1eq,
          filterl$a2,
          filterl$v2,
          filterl$a3,
          filterl$m0,
          filterl$m1,
          filterl$m2));
        keyr = std::abs (init$eqtick (
          spl1,
          filterr$v3,
          filterr$ic2eq,
          filterr$v1,
          filterr$a1,
          filterr$ic1eq,
          filterr$a2,
          filterr$v2,
          filterr$a3,
          filterr$m0,
          filterr$m1,
          filterr$m2));
        if ((lnkmix > 0.)) {
          linked = std::sqrt (jsfx_sqr (keyl) + jsfx_sqr (keyr)) * lnkmix;
          keyl *= splmix;
          keyr *= splmix;
          keyl += linked;
          keyr += linked;
        }
        spl0 *= init$comptick (
          keyl,
          compl$gr,
          compl$feedback,
          compl$rms$rmsenv$coeff,
          compl$attrel$envelope,
          compl$autogain,
          compl$calc$makeup,
          compl$rms$envelope,
          compl$attrel$coeffatt,
          compl$attrel$coeffrel,
          compl$calc$ratio,
          compl$calc$knee,
          compl$calc$kneelower,
          compl$calc$kneeupper,
          compl$calc$threshold,
          compl$calc$range);

        spl1 *= init$comptick (
          keyr,
          compr$gr,
          compr$feedback,
          compr$rms$rmsenv$coeff,
          compr$attrel$envelope,
          compr$autogain,
          compr$calc$makeup,
          compr$rms$envelope,
          compr$attrel$coeffatt,
          compr$attrel$coeffrel,
          compr$calc$ratio,
          compr$calc$knee,
          compr$calc$kneelower,
          compr$calc$kneeupper,
          compr$calc$threshold,
          compr$calc$range);
        saturationl = init$sattick (compl$gr, satl$envelope, satl$satenv$coeff);
        saturationr = init$sattick (compr$gr, satr$envelope, satr$satenv$coeff);
      }
      if (eel2_eq (routing, 1.)) {
        keyl = std::abs (init$eqtick (
          spl2,
          filterl$v3,
          filterl$ic2eq,
          filterl$v1,
          filterl$a1,
          filterl$ic1eq,
          filterl$a2,
          filterl$v2,
          filterl$a3,
          filterl$m0,
          filterl$m1,
          filterl$m2));
        keyr = std::abs (init$eqtick (
          spl3,
          filterr$v3,
          filterr$ic2eq,
          filterr$v1,
          filterr$a1,
          filterr$ic1eq,
          filterr$a2,
          filterr$v2,
          filterr$a3,
          filterr$m0,
          filterr$m1,
          filterr$m2));
        if (lnkmix > 0.) {
          linked = std::sqrt (jsfx_sqr (keyl) + jsfx_sqr (keyr)) * lnkmix;
          keyl *= splmix;
          keyr *= splmix;
          keyl += linked;
          keyr += linked;
        }
        spl0 *= init$comptick (
          keyl,
          compl$gr,
          compl$feedback,
          compl$rms$rmsenv$coeff,
          compl$attrel$envelope,
          compl$autogain,
          compl$calc$makeup,
          compl$rms$envelope,
          compl$attrel$coeffatt,
          compl$attrel$coeffrel,
          compl$calc$ratio,
          compl$calc$knee,
          compl$calc$kneelower,
          compl$calc$kneeupper,
          compl$calc$threshold,
          compl$calc$range);
        spl1 *= init$comptick (
          keyr,
          compr$gr,
          compr$feedback,
          compr$rms$rmsenv$coeff,
          compr$attrel$envelope,
          compr$autogain,
          compr$calc$makeup,
          compr$rms$envelope,
          compr$attrel$coeffatt,
          compr$attrel$coeffrel,
          compr$calc$ratio,
          compr$calc$knee,
          compr$calc$kneelower,
          compr$calc$kneeupper,
          compr$calc$threshold,
          compr$calc$range);
        saturationl = init$sattick (compl$gr, satl$envelope, satl$satenv$coeff);
        saturationr = init$sattick (compr$gr, satr$envelope, satr$satenv$coeff);
      }
      if (eel2_eq (routing, 2.)) {
        spl0 *= init$comptick (
          std::abs (init$eqtick (
            spl0,
            filterl$v3,
            filterl$ic2eq,
            filterl$v1,
            filterl$a1,
            filterl$ic1eq,
            filterl$a2,
            filterl$v2,
            filterl$a3,
            filterl$m0,
            filterl$m1,
            filterl$m2)),
          compl$gr,
          compl$feedback,
          compl$rms$rmsenv$coeff,
          compl$attrel$envelope,
          compl$autogain,
          compl$calc$makeup,
          compl$rms$envelope,
          compl$attrel$coeffatt,
          compl$attrel$coeffrel,
          compl$calc$ratio,
          compl$calc$knee,
          compl$calc$kneelower,
          compl$calc$kneeupper,
          compl$calc$threshold,
          compl$calc$range);
        spl1        = spl0;
        saturationl = init$sattick (compl$gr, satl$envelope, satl$satenv$coeff);
        saturationr = saturationl;
      }
      if (eel2_eq (routing, 3.)) {
        spl1 *= init$comptick (
          std::abs (init$eqtick (
            spl1,
            filterr$v3,
            filterr$ic2eq,
            filterr$v1,
            filterr$a1,
            filterr$ic1eq,
            filterr$a2,
            filterr$v2,
            filterr$a3,
            filterr$m0,
            filterr$m1,
            filterr$m2)),
          compr$gr,
          compr$feedback,
          compr$rms$rmsenv$coeff,
          compr$attrel$envelope,
          compr$autogain,
          compr$calc$makeup,
          compr$rms$envelope,
          compr$attrel$coeffatt,
          compr$attrel$coeffrel,
          compr$calc$ratio,
          compr$calc$knee,
          compr$calc$kneelower,
          compr$calc$kneeupper,
          compr$calc$threshold,
          compr$calc$range);
        spl0        = spl1;
        saturationr = init$sattick (compr$gr, satr$envelope, satr$satenv$coeff);
        saturationl = saturationr;
      }
      if (eel2_eq (routing, 4.)) {
        spl0 *= init$comptick (
          std::abs (init$eqtick (
            spl1,
            filterl$v3,
            filterl$ic2eq,
            filterl$v1,
            filterl$a1,
            filterl$ic1eq,
            filterl$a2,
            filterl$v2,
            filterl$a3,
            filterl$m0,
            filterl$m1,
            filterl$m2)),
          compl$gr,
          compl$feedback,
          compl$rms$rmsenv$coeff,
          compl$attrel$envelope,
          compl$autogain,
          compl$calc$makeup,
          compl$rms$envelope,
          compl$attrel$coeffatt,
          compl$attrel$coeffrel,
          compl$calc$ratio,
          compl$calc$knee,
          compl$calc$kneelower,
          compl$calc$kneeupper,
          compl$calc$threshold,
          compl$calc$range);
        spl1        = spl0;
        saturationl = init$sattick (compl$gr, satl$envelope, satl$satenv$coeff);
        saturationr = saturationl;
      }
      if (eel2_eq (routing, 5.)) {
        spl1 *= init$comptick (
          std::abs (init$eqtick (
            spl0,
            filterr$v3,
            filterr$ic2eq,
            filterr$v1,
            filterr$a1,
            filterr$ic1eq,
            filterr$a2,
            filterr$v2,
            filterr$a3,
            filterr$m0,
            filterr$m1,
            filterr$m2)),
          compr$gr,
          compr$feedback,
          compr$rms$rmsenv$coeff,
          compr$attrel$envelope,
          compr$autogain,
          compr$calc$makeup,
          compr$rms$envelope,
          compr$attrel$coeffatt,
          compr$attrel$coeffrel,
          compr$calc$ratio,
          compr$calc$knee,
          compr$calc$kneelower,
          compr$calc$kneeupper,
          compr$calc$threshold,
          compr$calc$range);
        spl0        = spl1;
        saturationr = init$sattick (compr$gr, satr$envelope, satr$satenv$coeff);
        saturationl = saturationr;
      }
      if ((saturation > 0.)) {
        double v0 = spl0;
        double v1 = spl1;
        init$saturate (saturationl, v0);
        init$saturate (saturationr, v1);
        init$dcblocker (spl0$stateout, v0, spl0$statein);
        init$dcblocker (spl1$stateout, v1, spl1$statein);
        spl0 = v0;
        spl1 = v1;
      }
      spl0 *= gainout;
      spl1 *= gainout;
      if (wetdry < 1.) {
        spl0 = drywet * dryl + wetdry * spl0;
        spl1 = drywet * dryr + wetdry * spl1;
      };
    }
  }
  // functions for section "init"
private:
  //----------------------------------------------------------------------------
  double init$attrelsetup (
    double  msattack,
    double  msrelease,
    double& $coeffatt,
    double& $coeffrel)
  {
    $coeffatt = std::exp (
      -1000. * init$fastreciprocal (msattack * jsfx_specialvar_get_srate()));
    $coeffrel = std::exp (
      -1000. * init$fastreciprocal (msrelease * jsfx_specialvar_get_srate()));
    return $coeffrel;
  }
  //----------------------------------------------------------------------------
  double init$attreltick (
    double  dbsample,
    double& $envelope,
    double& $coeffatt,
    double& $coeffrel)
  {
    double change = 0.;
    double above  = 0.;
    above         = (dbsample > $envelope);
    change        = $envelope - dbsample;
    $envelope     = (above * (dbsample + $coeffatt * change))
      + (!above * (dbsample + $coeffrel * change));
    return $envelope;
  }
  //----------------------------------------------------------------------------
  double init$compsetup (
    double  msattack,
    double  msrelease,
    double  mswindow,
    double  dbthreshold,
    double  fullratio,
    double  dbknee,
    double  dbrange,
    double  pctfeedback,
    double  automakeup,
    double& $feedback,
    double& $autogain,
    double& $attrel$coeffatt,
    double& $attrel$coeffrel,
    double& $rms$rmsenv$coeff,
    double& $calc$threshold,
    double& $calc$ratio,
    double& $calc$makeup,
    double& $calc$knee,
    double& $calc$kneewidth,
    double& $calc$kneeupper,
    double& $calc$kneelower,
    double& $calc$range)
  {
    init$attrelsetup (msattack, msrelease, $attrel$coeffatt, $attrel$coeffrel);
    init$rmssetup (mswindow, $rms$rmsenv$coeff);
    init$gaincalcsetup (
      dbthreshold,
      fullratio,
      dbknee,
      dbrange,
      $calc$threshold,
      $calc$ratio,
      $calc$makeup,
      $calc$knee,
      $calc$kneewidth,
      $calc$kneeupper,
      $calc$kneelower,
      $calc$range);
    $feedback = pctfeedback * 0.01;
    $autogain = automakeup;
    return $autogain;
  }
  //----------------------------------------------------------------------------
  double init$comptick (
    double  sample,
    double& $gr,
    double& $feedback,
    double& $rms$rmsenv$coeff,
    double& $attrel$envelope,
    double& $autogain,
    double& $calc$makeup,
    double& $rms$envelope,
    double& $attrel$coeffatt,
    double& $attrel$coeffrel,
    double& $calc$ratio,
    double& $calc$knee,
    double& $calc$kneelower,
    double& $calc$kneeupper,
    double& $calc$threshold,
    double& $calc$range)
  {
    double feedbackfactor = 0.;
    double gainadjust     = 0.;
    double keygain        = 0.;
    double keydecibels    = 0.;
    feedbackfactor        = 1.0 - ((1.0 - $gr) * $feedback);
    keygain               = sample * feedbackfactor;
    if ($rms$rmsenv$coeff > 0.) {
      keygain = init$rmstick (keygain, $rms$envelope, $rms$rmsenv$coeff);
    }
    keydecibels = init$gaintodb (keygain);
    init$attreltick (
      keydecibels, $attrel$envelope, $attrel$coeffatt, $attrel$coeffrel);
    $gr = init$gaincalctick (
      $attrel$envelope,
      $calc$ratio,
      $calc$knee,
      $calc$kneelower,
      $calc$kneeupper,
      $calc$threshold,
      $calc$range);
    gainadjust = [&] {
      if (eel2_eq ($autogain, 0.)) {
        return $calc$makeup;
      }
      else {
        return 1.0;
      }
    }();
    return $gr * gainadjust;
  }
  //----------------------------------------------------------------------------
  double init$dbtogain (double decibels)
  {
    return eel2_pow (10.0, (decibels / 20.0));
  }
  //----------------------------------------------------------------------------
  double init$dcblocker (double& $stateout, double& this$, double& $statein)
  {
    $stateout *= 0.99988487;
    $stateout += this$ - $statein;
    $statein = this$;
    this$    = $stateout;
    return this$;
  }
  //----------------------------------------------------------------------------
  double init$envsetup (double mstime, double& $coeff)
  {
#if 1
    if (mstime == 0.) {
      $coeff = 0.f;
      return $coeff;
    }
#endif
    $coeff = std::exp (
      -1000. * init$fastreciprocal (mstime * jsfx_specialvar_get_srate()));
    return $coeff;
  }
  //----------------------------------------------------------------------------
  double init$envtick (double dbsample, double envelope, double& $coeff)
  {
    double active = 0.;
    active        = eel2_ne ($coeff, 0.);
    return (!active * dbsample)
      + (active * (dbsample + $coeff * (envelope - dbsample)));
  }
  //----------------------------------------------------------------------------
  double init$eqhp (
    double  hz,
    double  q,
    double& $a1,
    double& $a2,
    double& $a3,
    double& $m0,
    double& $m1,
    double& $m2)
  {
    double k = 0.;
    double g = 0.;
    g        = std::tan (halfpi * (hz / jsfx_specialvar_get_srate()));
    k        = init$fastreciprocal (q);
    $a1      = init$fastreciprocal (1.0 + g * (g + k));
    $a2      = $a1 * g;
    $a3      = $a2 * g;
    $m0      = 1.0;
    $m1      = -k;
    $m2      = -1.0;
    return $m2;
  }
  //----------------------------------------------------------------------------
  double init$eqtick (
    double  sample,
    double& $v3,
    double& $ic2eq,
    double& $v1,
    double& $a1,
    double& $ic1eq,
    double& $a2,
    double& $v2,
    double& $a3,
    double& $m0,
    double& $m1,
    double& $m2)
  {
    $v3    = sample - $ic2eq;
    $v1    = $a1 * $ic1eq + $a2 * $v3;
    $v2    = $ic2eq + $a2 * $ic1eq + $a3 * $v3;
    $ic1eq = 2.0 * $v1 - $ic1eq;
    $ic2eq = 2.0 * $v2 - $ic2eq;
    return ($m0 * sample + $m1 * $v1 + $m2 * $v2);
  }
  //----------------------------------------------------------------------------
  double init$fastreciprocal (double value)
  {
    return jsfx_sqr (jsfx_invsqrt (value));
  }
  //----------------------------------------------------------------------------
  double init$gaincalcsetup (
    double  dbthreshold,
    double  fullratio,
    double  dbknee,
    double  dbrange,
    double& $threshold,
    double& $ratio,
    double& $makeup,
    double& $knee,
    double& $kneewidth,
    double& $kneeupper,
    double& $kneelower,
    double& $range)
  {
    $threshold = dbthreshold;
    $ratio     = init$fastreciprocal (fullratio);
    $makeup    = init$dbtogain (
      std::abs (($threshold + (std::abs ($threshold) * $ratio)) * 0.4));
    $knee      = dbknee;
    $kneewidth = $knee * 0.5;
    $kneeupper = $threshold + $kneewidth;
    $kneelower = $threshold - $kneewidth;
    $range     = dbrange;
    return $range;
  }
  //----------------------------------------------------------------------------
  double init$gaincalctick (
    double  dbsample,
    double& $ratio,
    double& $knee,
    double& $kneelower,
    double& $kneeupper,
    double& $threshold,
    double& $range)
  {
    double dbreduction = 0.;
    double slope       = 0.;
    dbreduction        = dbsample;
    slope              = 1.0 - $ratio;
    if (($knee > 0.0) && (dbsample > $kneelower) && (dbsample < $kneeupper)) {
      slope *= ((dbsample - $kneelower) / $knee) * 0.5;
      dbreduction = slope * ($kneelower - dbsample);
    }
    else {
      (dbreduction = std::min (0.0, slope * ($threshold - dbsample)));
    }
    return init$dbtogain (std::max (dbreduction, $range));
  }
  //----------------------------------------------------------------------------
  double init$gaintodb (double float_)
  {
    double below = 0.;
    float_       = std::abs (float_);
    below        = float_ < floatfloor;
    float_       = below * floatfloor + !(below) *float_;
    return (std::log (float_) * m_ln10_20);
  }
  //----------------------------------------------------------------------------
  double init$rmssetup (double mswindow, double& $rmsenv$coeff)
  {
    return init$envsetup (mswindow, $rmsenv$coeff);
  }
  //----------------------------------------------------------------------------
  double init$rmstick (double sample, double& $envelope, double& $rmsenv$coeff)
  {
    $envelope = init$envtick (sample * sample, $envelope, $rmsenv$coeff);
    return std::sqrt ($envelope);
  }
  //----------------------------------------------------------------------------
  double init$satsetup (double msspeed, double& $satenv$coeff)
  {
    return init$envsetup (msspeed, $satenv$coeff);
  }
  //----------------------------------------------------------------------------
  double init$sattick (
    double  samplegr,
    double& $envelope,
    double& $satenv$coeff)
  {
    $envelope = init$envtick (samplegr, $envelope, $satenv$coeff);
    return $envelope;
  }
  //----------------------------------------------------------------------------
  double init$saturate (double drive, double& this$)
  {
    double boost = 0.;
    boost        = 1.0 + (1.0 - drive);
    this$        = (drymix * this$) + (satmix * init$softclip (this$ * boost));
    return this$;
  }
  //----------------------------------------------------------------------------
  double init$softclip (double number)
  {
    double x7  = 0.;
    double x2  = 0.;
    double x4  = 0.;
    double res = 0.;
    double xa  = 0.;
    double x3  = 0.;
    xa         = std::abs (number);
    x2         = xa * xa;
    x3         = x2 * xa;
    x4         = x2 * x2;
    x7         = x4 * x3;
    res
      = (1.0 - 1.0 / (1.0 + xa + x2 + 0.58576695 * x3 + 0.55442112 * x4 + 0.057481508 * x7));
    return jsfx_sign (number) * res;
  }
}; /* jsfx_process */

}} // namespace artv::chokehold

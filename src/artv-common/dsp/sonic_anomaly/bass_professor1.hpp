// Ported from https://github.com/Sonic-Anomaly/Sonic-Anomaly-JSFX.git
// commit sha: 663735021e59d788e8ebacc4b9678569378deec9

#pragma once
// Generated by jsfx2cpp.py. To be manually corrected.
// includes for environment function calls
#include <algorithm>
#include <cmath>
#include <cstdint>
#include <cstdlib>
#include <limits>
// slider1:0<0,40,1>-Profess
// slider2:0<-20,20,0.5>-Output
// slider3:0<0,10,0.1>-Presence
// slider4:0<0,10,0.1>-Dirt
// slider5:0<-6,6,0.1>-Bass
// slider6:0<-6,6,0.1>-Middle
// slider7:0<-6,6,0.1>-Treble
// slider8:8<0.1,10,0.1>-Depth
// slider9:0<0,10,0.1>-LFcut
#include <juce_audio_processors/juce_audio_processors.h>

#include "artv-common/dsp/jsfx_engine/jsfx_engine.hpp"
#include "artv-common/dsp/own/classes/plugin_context.hpp"
#include "artv-common/dsp/types.hpp"
#include "artv-common/juce/parameter_definitions.hpp"
#include "artv-common/juce/parameter_types.hpp"
#include "artv-common/misc/mp11.hpp"
#include "artv-common/misc/short_ints.hpp"
#include "artv-common/misc/util.hpp"

namespace artv { namespace sonic_anomaly {

struct bass_professor {
public:
  //----------------------------------------------------------------------------
  static constexpr dsp_types dsp_type = dsp_types::exciter;
  //----------------------------------------------------------------------------
private:
  // definitions for environment function calls
  static double eel2_eq (double lhs, double rhs)
  {
    return (double) (std::abs (lhs - rhs) < 0.00001);
  }
  static bool   eel2_ne (double lhs, double rhs) { return !eel2_eq (lhs, rhs); }
  static double eel2_pow (double lhs, double rhs)
  {
    return std::pow (lhs, rhs);
  }
  static double jsfx_rand (double maxv = 1.)
  {
    return jsfx_engine::rand (maxv);
  }

  //----------------------------------------------------------------------------
public:
  // stubs for JSFX special variables
#if 0
  double jsfx_specialvar_get_samplesblock()
  {
    return 0.; /* TODO: stub for getting JSFX var "samplesblock" */
  }

#endif
  float  sample_rate = 44100;
  double jsfx_specialvar_get_srate() { return sample_rate; }
  //----------------------------------------------------------------------------
  // stubs for sliders

#if 0
  double get_slider_slider1()
  {
    // TODO: stub, add code for getting "slider1"
    // Range: min:0.0, max:40.0, default: 0.0, step: 1.0
    // Original line: slider1:0<0,40,1>-Profess
    return 0.;
  }
#else
  // Snippet for parameter boilerplate in the authors framework....
  double get_slider_slider1()
  {
    // Range: min:0.0, max:40.0, default: 0.0, step: 1.0
    return slider1p;
  }

  float slider1p = 0.0;
  float slider2p = 0.0;

  struct amount_tag {};

  void set (amount_tag, float v)
  {
    if (v == slider1p) {
      return;
    }
    slider1p = v;
    slider();
  }

  static constexpr auto get_parameter (amount_tag)
  {
    // Original slider line: slider1:0<0,40,1>-Profess
    return float_param ("", 0.0, 40.0, 0.0, 1.0);
  }
#endif
#if 1
  double get_slider_slider2()
  {
    // TODO: stub, add code for getting "slider2"
    // Range: min:-20.0, max:20.0, default: 0.0, step: 0.5
    // Original line: slider2:0<-20,20,0.5>-Output
    return 0.;
  }
#else
  // Snippet for parameter boilerplate in the authors framework....
  double get_slider_slider2()
  {
    // Range: min:-20.0, max:20.0, default: 0.0, step: 0.5
    return slider2p;
  }

  float slider2p = 0.0;

  struct slider2_tag {};

  void set (slider2_tag, float v)
  {
    if (v == slider2p) {
      return;
    }
    slider2p = v;
    slider();
  }

  static constexpr auto get_parameter (slider2_tag)
  {
    // Original slider line: slider2:0<-20,20,0.5>-Output
    return float_param ("", -20.0, 20.0, 0.0, 0.5);
  }
#endif
#if 0
  double get_slider_slider3()
  {
    // TODO: stub, add code for getting "slider3"
    // Range: min:0.0, max:10.0, default: 0.0, step: 0.1
    // Original line: slider3:0<0,10,0.1>-Presence
    return 0.;
  }
#else
  // Snippet for parameter boilerplate in the authors framework....
  double get_slider_slider3()
  {
    // Range: min:0.0, max:10.0, default: 0.0, step: 0.1
    return slider3p;
  }

  float slider3p = 0.0;

  struct presence_tag {};

  void set (presence_tag, float v)
  {
    if (v == slider3p) {
      return;
    }
    slider3p = v;
    slider();
  }

  static constexpr auto get_parameter (presence_tag)
  {
    // Original slider line: slider3:0<0,10,0.1>-Presence
    return float_param ("", 0.0, 10.0, 0.0, 0.1);
  }
#endif
#if 0
  double get_slider_slider4()
  {
    // TODO: stub, add code for getting "slider4"
    // Range: min:0.0, max:10.0, default: 0.0, step: 0.1
    // Original line: slider4:0<0,10,0.1>-Dirt
    return 0.;
  }
#else
  // Snippet for parameter boilerplate in the authors framework....
  double get_slider_slider4()
  {
    // Range: min:0.0, max:10.0, default: 0.0, step: 0.1
    return slider4p;
  }

  float slider4p = 0.0;

  struct dirt_tag {};

  void set (dirt_tag, float v)
  {
    if (v == slider4p) {
      return;
    }
    slider4p = v;
    slider();
  }

  static constexpr auto get_parameter (dirt_tag)
  {
    // Original slider line: slider4:0<0,10,0.1>-Dirt
    return float_param ("", 0.0, 10.0, 0.0, 0.1);
  }
#endif
#if 0
  double get_slider_slider5()
  {
    // TODO: stub, add code for getting "slider5"
    // Range: min:-6.0, max:6.0, default: 0.0, step: 0.1
    // Original line: slider5:0<-6,6,0.1>-Bass
    return 0.;
  }
#else
  // Snippet for parameter boilerplate in the authors framework....
  double get_slider_slider5()
  {
    // Range: min:-6.0, max:6.0, default: 0.0, step: 0.1
    return slider5p;
  }

  float slider5p = 0.0;

  struct bass_tag {};

  void set (bass_tag, float v)
  {
    if (v == slider5p) {
      return;
    }
    slider5p = v;
    slider();
  }

  static constexpr auto get_parameter (bass_tag)
  {
    // Original slider line: slider5:0<-6,6,0.1>-Bass
    return float_param ("", -6.0, 6.0, 0.0, 0.1);
  }
#endif
#if 0
  double get_slider_slider6()
  {
    // TODO: stub, add code for getting "slider6"
    // Range: min:-6.0, max:6.0, default: 0.0, step: 0.1
    // Original line: slider6:0<-6,6,0.1>-Middle
    return 0.;
  }
#else
  // Snippet for parameter boilerplate in the authors framework....
  double get_slider_slider6()
  {
    // Range: min:-6.0, max:6.0, default: 0.0, step: 0.1
    return slider6p;
  }

  float slider6p = 0.0;

  struct middle_tag {};

  void set (middle_tag, float v)
  {
    if (v == slider6p) {
      return;
    }
    slider6p = v;
    slider();
  }

  static constexpr auto get_parameter (middle_tag)
  {
    // Original slider line: slider6:0<-6,6,0.1>-Middle
    return float_param ("", -6.0, 6.0, 0.0, 0.1);
  }

#endif
#if 0
  double get_slider_slider7()
  {
    // TODO: stub, add code for getting "slider7"
    // Range: min:-6.0, max:6.0, default: 0.0, step: 0.1
    // Original line: slider7:0<-6,6,0.1>-Treble
    return 0.;
  }
#else
  // Snippet for parameter boilerplate in the authors framework....
  double get_slider_slider7()
  {
    // Range: min:-6.0, max:6.0, default: 0.0, step: 0.1
    return slider7p;
  }

  float slider7p = 0.0;

  struct treble_tag {};

  void set (treble_tag, float v)
  {
    if (v == slider7p) {
      return;
    }
    slider7p = v;
    slider();
  }

  static constexpr auto get_parameter (treble_tag)
  {
    // Original slider line: slider7:0<-6,6,0.1>-Treble
    return float_param ("", -6.0, 6.0, 0.0, 0.1);
  }

#endif
#if 0
  double get_slider_slider8()
  {
    // TODO: stub, add code for getting "slider8"
    // Range: min:0.1, max:10.0, default: 8.0, step: 0.1
    // Original line: slider8:8<0.1,10,0.1>-Depth
    return 0.;
  }
#else
  // Snippet for parameter boilerplate in the authors framework....
  double get_slider_slider8()
  {
    // Range: min:0.1, max:10.0, default: 8.0, step: 0.1
    return slider8p;
  }

  float slider8p = 8.0;

  struct depth_tag {};

  void set (depth_tag, float v)
  {
    if (v == slider8p) {
      return;
    }
    slider8p = v;
    slider();
  }

  static constexpr auto get_parameter (depth_tag)
  {
    // Original slider line: slider8:8<0.1,10,0.1>-Depth
    return float_param ("", 0.1, 10.0, 8.0, 0.1);
  }
#endif
#if 0
  double get_slider_slider9()
  {
    // TODO: stub, add code for getting "slider9"
    // Range: min:0.0, max:10.0, default: 0.0, step: 0.1
    // Original line: slider9:0<0,10,0.1>-LFcut
    return 0.;
  }
#else
  // Snippet for parameter boilerplate in the authors framework....
  double get_slider_slider9()
  {
    // Range: min:0.0, max:10.0, default: 0.0, step: 0.1
    return slider9p;
  }

  float slider9p = 0.0;

  struct lf_cut_tag {};

  void set (lf_cut_tag, float v)
  {
    if (v == slider9p) {
      return;
    }
    slider9p = v;
    slider();
  }

  static constexpr auto get_parameter (lf_cut_tag)
  {
    // Original slider line: slider9:0<0,10,0.1>-LFcut
    return float_param ("", 0.0, 10.0, 0.0, 0.1);
  }

  using parameters = mp_list<
    amount_tag,
    presence_tag,
    dirt_tag,
    bass_tag,
    middle_tag,
    treble_tag,
    depth_tag,
    lf_cut_tag>;
#endif
private:
  //----------------------------------------------------------------------------
  // global/stateful variables for section "init"
  double boost;
  double buildstr;
  double lf1$a;
  double lf1$a0;
  double lf1$a1;
  double lf1$a2;
  double lf1$alpha;
  double lf1$b0;
  double lf1$b1;
  double lf1$b2;
  double lf1$beta;
  double lf1$omega;
  double lf1$tcos;
  double lf1$tsin;
  double lf2$a;
  double lf2$a0;
  double lf2$a1;
  double lf2$a2;
  double lf2$alpha;
  double lf2$b0;
  double lf2$b1;
  double lf2$b2;
  double lf2$beta;
  double lf2$omega;
  double lf2$tcos;
  double lf2$tsin;
  double limit_active;
  double m1;
  double m2;
  double m3;
  double m4;
  double mf1$a;
  double mf1$a0;
  double mf1$a1;
  double mf1$a2;
  double mf1$alpha;
  double mf1$b0;
  double mf1$b1;
  double mf1$b2;
  double mf1$beta;
  double mf1$omega;
  double mf1$tcos;
  double mf1$tsin;
  double mf2$a;
  double mf2$a0;
  double mf2$a1;
  double mf2$a2;
  double mf2$alpha;
  double mf2$b0;
  double mf2$b1;
  double mf2$b2;
  double mf2$beta;
  double mf2$omega;
  double mf2$tcos;
  double mf2$tsin;
  double od$f1$a;
  double od$f1$a0;
  double od$f1$a1;
  double od$f1$a2;
  double od$f1$alpha;
  double od$f1$b0;
  double od$f1$b1;
  double od$f1$b2;
  double od$f1$beta;
  double od$f1$omega;
  double od$f1$tcos;
  double od$f1$tsin;
  double od$f2$a;
  double od$f2$a0;
  double od$f2$a1;
  double od$f2$a2;
  double od$f2$alpha;
  double od$f2$b0;
  double od$f2$b1;
  double od$f2$b2;
  double od$f2$beta;
  double od$f2$omega;
  double od$f2$tcos;
  double od$f2$tsin;
  double od$f3$a;
  double od$f3$a0;
  double od$f3$a1;
  double od$f3$a2;
  double od$f3$alpha;
  double od$f3$b0;
  double od$f3$b1;
  double od$f3$b2;
  double od$f3$beta;
  double od$f3$omega;
  double od$f3$tcos;
  double od$f3$tsin;
  double od$f4$a;
  double od$f4$a0;
  double od$f4$a1;
  double od$f4$a2;
  double od$f4$alpha;
  double od$f4$b0;
  double od$f4$b1;
  double od$f4$b2;
  double od$f4$beta;
  double od$f4$omega;
  double od$f4$tcos;
  double od$f4$tsin;
  double rmsw;
  double sf$a;
  double sf$a0;
  double sf$a1;
  double sf$a2;
  double sf$alpha;
  double sf$b0;
  double sf$b1;
  double sf$b2;
  double sf$beta;
  double sf$omega;
  double sf$tcos;
  double sf$tsin;
  double t01;
  double t20;
  double t200;
  double t40;
  double t60;
  double temp;
  //----------------------------------------------------------------------------
  void init_init_variables()
  {
    boost        = 0;
    buildstr     = 0;
    lf1$a        = 0;
    lf1$a0       = 0;
    lf1$a1       = 0;
    lf1$a2       = 0;
    lf1$alpha    = 0;
    lf1$b0       = 0;
    lf1$b1       = 0;
    lf1$b2       = 0;
    lf1$beta     = 0;
    lf1$omega    = 0;
    lf1$tcos     = 0;
    lf1$tsin     = 0;
    lf2$a        = 0;
    lf2$a0       = 0;
    lf2$a1       = 0;
    lf2$a2       = 0;
    lf2$alpha    = 0;
    lf2$b0       = 0;
    lf2$b1       = 0;
    lf2$b2       = 0;
    lf2$beta     = 0;
    lf2$omega    = 0;
    lf2$tcos     = 0;
    lf2$tsin     = 0;
    limit_active = 0;
    m1           = 0;
    m2           = 0;
    m3           = 0;
    m4           = 0;
    mf1$a        = 0;
    mf1$a0       = 0;
    mf1$a1       = 0;
    mf1$a2       = 0;
    mf1$alpha    = 0;
    mf1$b0       = 0;
    mf1$b1       = 0;
    mf1$b2       = 0;
    mf1$beta     = 0;
    mf1$omega    = 0;
    mf1$tcos     = 0;
    mf1$tsin     = 0;
    mf2$a        = 0;
    mf2$a0       = 0;
    mf2$a1       = 0;
    mf2$a2       = 0;
    mf2$alpha    = 0;
    mf2$b0       = 0;
    mf2$b1       = 0;
    mf2$b2       = 0;
    mf2$beta     = 0;
    mf2$omega    = 0;
    mf2$tcos     = 0;
    mf2$tsin     = 0;
    od$f1$a      = 0;
    od$f1$a0     = 0;
    od$f1$a1     = 0;
    od$f1$a2     = 0;
    od$f1$alpha  = 0;
    od$f1$b0     = 0;
    od$f1$b1     = 0;
    od$f1$b2     = 0;
    od$f1$beta   = 0;
    od$f1$omega  = 0;
    od$f1$tcos   = 0;
    od$f1$tsin   = 0;
    od$f2$a      = 0;
    od$f2$a0     = 0;
    od$f2$a1     = 0;
    od$f2$a2     = 0;
    od$f2$alpha  = 0;
    od$f2$b0     = 0;
    od$f2$b1     = 0;
    od$f2$b2     = 0;
    od$f2$beta   = 0;
    od$f2$omega  = 0;
    od$f2$tcos   = 0;
    od$f2$tsin   = 0;
    od$f3$a      = 0;
    od$f3$a0     = 0;
    od$f3$a1     = 0;
    od$f3$a2     = 0;
    od$f3$alpha  = 0;
    od$f3$b0     = 0;
    od$f3$b1     = 0;
    od$f3$b2     = 0;
    od$f3$beta   = 0;
    od$f3$omega  = 0;
    od$f3$tcos   = 0;
    od$f3$tsin   = 0;
    od$f4$a      = 0;
    od$f4$a0     = 0;
    od$f4$a1     = 0;
    od$f4$a2     = 0;
    od$f4$alpha  = 0;
    od$f4$b0     = 0;
    od$f4$b1     = 0;
    od$f4$b2     = 0;
    od$f4$beta   = 0;
    od$f4$omega  = 0;
    od$f4$tcos   = 0;
    od$f4$tsin   = 0;
    rmsw         = 0;
    sf$a         = 0;
    sf$a0        = 0;
    sf$a1        = 0;
    sf$a2        = 0;
    sf$alpha     = 0;
    sf$b0        = 0;
    sf$b1        = 0;
    sf$b2        = 0;
    sf$beta      = 0;
    sf$omega     = 0;
    sf$tcos      = 0;
    sf$tsin      = 0;
    t01          = 0;
    t20          = 0;
    t200         = 0;
    t40          = 0;
    t60          = 0;
    temp         = 0;
  }
  //----------------------------------------------------------------------------
  // global/stateful variables for section "slider"
  double bass;
  double c1$attack;
  double c1$d;
  double c1$release;
  double c2$attack;
  double c2$d;
  double c2$release;
  double c3$attack;
  double c3$d;
  double c3$release;
  double c4$attack;
  double c4$d;
  double c4$release;
  double dirt;
  double eq1$a;
  double eq1$a0;
  double eq1$a1;
  double eq1$a2;
  double eq1$alpha;
  double eq1$b0;
  double eq1$b1;
  double eq1$b2;
  double eq1$beta;
  double eq1$omega;
  double eq1$tcos;
  double eq1$tsin;
  double eq10$a;
  double eq10$a0;
  double eq10$a1;
  double eq10$a2;
  double eq10$alpha;
  double eq10$b0;
  double eq10$b1;
  double eq10$b2;
  double eq10$beta;
  double eq10$omega;
  double eq10$tcos;
  double eq10$tsin;
  double eq11$a;
  double eq11$a0;
  double eq11$a1;
  double eq11$a2;
  double eq11$alpha;
  double eq11$b0;
  double eq11$b1;
  double eq11$b2;
  double eq11$beta;
  double eq11$omega;
  double eq11$tcos;
  double eq11$tsin;
  double eq12$a;
  double eq12$a0;
  double eq12$a1;
  double eq12$a2;
  double eq12$alpha;
  double eq12$b0;
  double eq12$b1;
  double eq12$b2;
  double eq12$beta;
  double eq12$omega;
  double eq12$tcos;
  double eq12$tsin;
  double eq2$a;
  double eq2$a0;
  double eq2$a1;
  double eq2$a2;
  double eq2$alpha;
  double eq2$b0;
  double eq2$b1;
  double eq2$b2;
  double eq2$beta;
  double eq2$omega;
  double eq2$tcos;
  double eq2$tsin;
  double eq3$a;
  double eq3$a0;
  double eq3$a1;
  double eq3$a2;
  double eq3$alpha;
  double eq3$b0;
  double eq3$b1;
  double eq3$b2;
  double eq3$beta;
  double eq3$omega;
  double eq3$tcos;
  double eq3$tsin;
  double eq4$a;
  double eq4$a0;
  double eq4$a1;
  double eq4$a2;
  double eq4$alpha;
  double eq4$b0;
  double eq4$b1;
  double eq4$b2;
  double eq4$beta;
  double eq4$omega;
  double eq4$tcos;
  double eq4$tsin;
  double eq5$a;
  double eq5$a0;
  double eq5$a1;
  double eq5$a2;
  double eq5$alpha;
  double eq5$b0;
  double eq5$b1;
  double eq5$b2;
  double eq5$beta;
  double eq5$omega;
  double eq5$tcos;
  double eq5$tsin;
  double eq6$a;
  double eq6$a0;
  double eq6$a1;
  double eq6$a2;
  double eq6$alpha;
  double eq6$b0;
  double eq6$b1;
  double eq6$b2;
  double eq6$beta;
  double eq6$omega;
  double eq6$tcos;
  double eq6$tsin;
  double eq7$a;
  double eq7$a0;
  double eq7$a1;
  double eq7$a2;
  double eq7$alpha;
  double eq7$b0;
  double eq7$b1;
  double eq7$b2;
  double eq7$beta;
  double eq7$omega;
  double eq7$tcos;
  double eq7$tsin;
  double eq8$a;
  double eq8$a0;
  double eq8$a1;
  double eq8$a2;
  double eq8$alpha;
  double eq8$b0;
  double eq8$b1;
  double eq8$b2;
  double eq8$beta;
  double eq8$omega;
  double eq8$tcos;
  double eq8$tsin;
  double eq9$a;
  double eq9$a0;
  double eq9$a1;
  double eq9$a2;
  double eq9$alpha;
  double eq9$b0;
  double eq9$b1;
  double eq9$b2;
  double eq9$beta;
  double eq9$omega;
  double eq9$tcos;
  double eq9$tsin;
  double hf1$a;
  double hf1$a0;
  double hf1$a1;
  double hf1$a2;
  double hf1$alpha;
  double hf1$b0;
  double hf1$b1;
  double hf1$b2;
  double hf1$beta;
  double hf1$omega;
  double hf1$tcos;
  double hf1$tsin;
  double middle;
  double output;
  double profess;
  double sb1$a;
  double sb1$a0;
  double sb1$a1;
  double sb1$a2;
  double sb1$alpha;
  double sb1$b0;
  double sb1$b1;
  double sb1$b2;
  double sb1$beta;
  double sb1$omega;
  double sb1$tcos;
  double sb1$tsin;
  double treble;
  //----------------------------------------------------------------------------
  void init_slider_variables()
  {
    bass       = 0;
    c1$attack  = 0;
    c1$d       = 0;
    c1$release = 0;
    c2$attack  = 0;
    c2$d       = 0;
    c2$release = 0;
    c3$attack  = 0;
    c3$d       = 0;
    c3$release = 0;
    c4$attack  = 0;
    c4$d       = 0;
    c4$release = 0;
    dirt       = 0;
    eq1$a      = 0;
    eq1$a0     = 0;
    eq1$a1     = 0;
    eq1$a2     = 0;
    eq1$alpha  = 0;
    eq1$b0     = 0;
    eq1$b1     = 0;
    eq1$b2     = 0;
    eq1$beta   = 0;
    eq1$omega  = 0;
    eq1$tcos   = 0;
    eq1$tsin   = 0;
    eq10$a     = 0;
    eq10$a0    = 0;
    eq10$a1    = 0;
    eq10$a2    = 0;
    eq10$alpha = 0;
    eq10$b0    = 0;
    eq10$b1    = 0;
    eq10$b2    = 0;
    eq10$beta  = 0;
    eq10$omega = 0;
    eq10$tcos  = 0;
    eq10$tsin  = 0;
    eq11$a     = 0;
    eq11$a0    = 0;
    eq11$a1    = 0;
    eq11$a2    = 0;
    eq11$alpha = 0;
    eq11$b0    = 0;
    eq11$b1    = 0;
    eq11$b2    = 0;
    eq11$beta  = 0;
    eq11$omega = 0;
    eq11$tcos  = 0;
    eq11$tsin  = 0;
    eq12$a     = 0;
    eq12$a0    = 0;
    eq12$a1    = 0;
    eq12$a2    = 0;
    eq12$alpha = 0;
    eq12$b0    = 0;
    eq12$b1    = 0;
    eq12$b2    = 0;
    eq12$beta  = 0;
    eq12$omega = 0;
    eq12$tcos  = 0;
    eq12$tsin  = 0;
    eq2$a      = 0;
    eq2$a0     = 0;
    eq2$a1     = 0;
    eq2$a2     = 0;
    eq2$alpha  = 0;
    eq2$b0     = 0;
    eq2$b1     = 0;
    eq2$b2     = 0;
    eq2$beta   = 0;
    eq2$omega  = 0;
    eq2$tcos   = 0;
    eq2$tsin   = 0;
    eq3$a      = 0;
    eq3$a0     = 0;
    eq3$a1     = 0;
    eq3$a2     = 0;
    eq3$alpha  = 0;
    eq3$b0     = 0;
    eq3$b1     = 0;
    eq3$b2     = 0;
    eq3$beta   = 0;
    eq3$omega  = 0;
    eq3$tcos   = 0;
    eq3$tsin   = 0;
    eq4$a      = 0;
    eq4$a0     = 0;
    eq4$a1     = 0;
    eq4$a2     = 0;
    eq4$alpha  = 0;
    eq4$b0     = 0;
    eq4$b1     = 0;
    eq4$b2     = 0;
    eq4$beta   = 0;
    eq4$omega  = 0;
    eq4$tcos   = 0;
    eq4$tsin   = 0;
    eq5$a      = 0;
    eq5$a0     = 0;
    eq5$a1     = 0;
    eq5$a2     = 0;
    eq5$alpha  = 0;
    eq5$b0     = 0;
    eq5$b1     = 0;
    eq5$b2     = 0;
    eq5$beta   = 0;
    eq5$omega  = 0;
    eq5$tcos   = 0;
    eq5$tsin   = 0;
    eq6$a      = 0;
    eq6$a0     = 0;
    eq6$a1     = 0;
    eq6$a2     = 0;
    eq6$alpha  = 0;
    eq6$b0     = 0;
    eq6$b1     = 0;
    eq6$b2     = 0;
    eq6$beta   = 0;
    eq6$omega  = 0;
    eq6$tcos   = 0;
    eq6$tsin   = 0;
    eq7$a      = 0;
    eq7$a0     = 0;
    eq7$a1     = 0;
    eq7$a2     = 0;
    eq7$alpha  = 0;
    eq7$b0     = 0;
    eq7$b1     = 0;
    eq7$b2     = 0;
    eq7$beta   = 0;
    eq7$omega  = 0;
    eq7$tcos   = 0;
    eq7$tsin   = 0;
    eq8$a      = 0;
    eq8$a0     = 0;
    eq8$a1     = 0;
    eq8$a2     = 0;
    eq8$alpha  = 0;
    eq8$b0     = 0;
    eq8$b1     = 0;
    eq8$b2     = 0;
    eq8$beta   = 0;
    eq8$omega  = 0;
    eq8$tcos   = 0;
    eq8$tsin   = 0;
    eq9$a      = 0;
    eq9$a0     = 0;
    eq9$a1     = 0;
    eq9$a2     = 0;
    eq9$alpha  = 0;
    eq9$b0     = 0;
    eq9$b1     = 0;
    eq9$b2     = 0;
    eq9$beta   = 0;
    eq9$omega  = 0;
    eq9$tcos   = 0;
    eq9$tsin   = 0;
    hf1$a      = 0;
    hf1$a0     = 0;
    hf1$a1     = 0;
    hf1$a2     = 0;
    hf1$alpha  = 0;
    hf1$b0     = 0;
    hf1$b1     = 0;
    hf1$b2     = 0;
    hf1$beta   = 0;
    hf1$omega  = 0;
    hf1$tcos   = 0;
    hf1$tsin   = 0;
    middle     = 0;
    output     = 0;
    profess    = 0;
    sb1$a      = 0;
    sb1$a0     = 0;
    sb1$a1     = 0;
    sb1$a2     = 0;
    sb1$alpha  = 0;
    sb1$b0     = 0;
    sb1$b1     = 0;
    sb1$b2     = 0;
    sb1$beta   = 0;
    sb1$omega  = 0;
    sb1$tcos   = 0;
    sb1$tsin   = 0;
    treble     = 0;
  }
  //----------------------------------------------------------------------------
  // global/stateful variables for section "block"
  double c1$e1$env;
  double c1$e1$tmp;
  double c1$e2$env;
  double c1$e2$tmp;
  double c1$e3$env;
  double c1$e3$tmp;
  double c1$env;
  double c1$output;
  double c2$e1$env;
  double c2$e1$tmp;
  double c2$e2$env;
  double c2$e2$tmp;
  double c2$e3$env;
  double c2$e3$tmp;
  double c2$env;
  double c2$output;
  double c3$e1$env;
  double c3$e1$tmp;
  double c3$e2$env;
  double c3$e2$tmp;
  double c3$e3$env;
  double c3$e3$tmp;
  double c3$env;
  double c3$output;
  double c4$e1$env;
  double c4$e1$tmp;
  double c4$e2$env;
  double c4$e2$tmp;
  double c4$e3$env;
  double c4$e3$tmp;
  double c4$env;
  double c4$output;
  double eq1$mx1;
  double eq1$mx2;
  double eq1$my1;
  double eq1$my2;
  double eq1$output;
  double eq10$mx1;
  double eq10$mx2;
  double eq10$my1;
  double eq10$my2;
  double eq10$output;
  double eq11$mx1;
  double eq11$mx2;
  double eq11$my1;
  double eq11$my2;
  double eq11$output;
  double eq12$mx1;
  double eq12$mx2;
  double eq12$my1;
  double eq12$my2;
  double eq12$output;
  double eq2$mx1;
  double eq2$mx2;
  double eq2$my1;
  double eq2$my2;
  double eq2$output;
  double eq3$mx1;
  double eq3$mx2;
  double eq3$my1;
  double eq3$my2;
  double eq3$output;
  double eq4$mx1;
  double eq4$mx2;
  double eq4$my1;
  double eq4$my2;
  double eq4$output;
  double eq5$mx1;
  double eq5$mx2;
  double eq5$my1;
  double eq5$my2;
  double eq5$output;
  double eq6$mx1;
  double eq6$mx2;
  double eq6$my1;
  double eq6$my2;
  double eq6$output;
  double eq7$mx1;
  double eq7$mx2;
  double eq7$my1;
  double eq7$my2;
  double eq7$output;
  double eq8$mx1;
  double eq8$mx2;
  double eq8$my1;
  double eq8$my2;
  double eq8$output;
  double eq9$mx1;
  double eq9$mx2;
  double eq9$my1;
  double eq9$my2;
  double eq9$output;
  double hf1$mx1;
  double hf1$mx2;
  double hf1$my1;
  double hf1$my2;
  double hf1$output;
  double l1$e1$env;
  double l1$e1$tmp;
  double l1$e2$env;
  double l1$e2$tmp;
  double l1$e3$env;
  double l1$e3$tmp;
  double l1$env;
  double l1$th;
  double lf1$mx1;
  double lf1$mx2;
  double lf1$my1;
  double lf1$my2;
  double lf1$output;
  double lf2$mx1;
  double lf2$mx2;
  double lf2$my1;
  double lf2$my2;
  double lf2$output;
  double mf1$mx1;
  double mf1$mx2;
  double mf1$my1;
  double mf1$my2;
  double mf1$output;
  double mf2$mx1;
  double mf2$mx2;
  double mf2$my1;
  double mf2$my2;
  double mf2$output;
  double od$f1$mx1;
  double od$f1$mx2;
  double od$f1$my1;
  double od$f1$my2;
  double od$f1$output;
  double od$f2$mx1;
  double od$f2$mx2;
  double od$f2$my1;
  double od$f2$my2;
  double od$f2$output;
  double od$f3$mx1;
  double od$f3$mx2;
  double od$f3$my1;
  double od$f3$my2;
  double od$f3$output;
  double od$f4$mx1;
  double od$f4$mx2;
  double od$f4$my1;
  double od$f4$my2;
  double od$f4$output;
  double od$rms;
  double od$s1;
  double rmss;
  double sb1$mx1;
  double sb1$mx2;
  double sb1$my1;
  double sb1$my2;
  double sb1$output;
  double sf$mx1;
  double sf$mx2;
  double sf$my1;
  double sf$my2;
  double sf$output;
  double sgn;
  //----------------------------------------------------------------------------
  void init_block_variables()
  {
    c1$e1$env    = 0;
    c1$e1$tmp    = 0;
    c1$e2$env    = 0;
    c1$e2$tmp    = 0;
    c1$e3$env    = 0;
    c1$e3$tmp    = 0;
    c1$env       = 0;
    c1$output    = 0;
    c2$e1$env    = 0;
    c2$e1$tmp    = 0;
    c2$e2$env    = 0;
    c2$e2$tmp    = 0;
    c2$e3$env    = 0;
    c2$e3$tmp    = 0;
    c2$env       = 0;
    c2$output    = 0;
    c3$e1$env    = 0;
    c3$e1$tmp    = 0;
    c3$e2$env    = 0;
    c3$e2$tmp    = 0;
    c3$e3$env    = 0;
    c3$e3$tmp    = 0;
    c3$env       = 0;
    c3$output    = 0;
    c4$e1$env    = 0;
    c4$e1$tmp    = 0;
    c4$e2$env    = 0;
    c4$e2$tmp    = 0;
    c4$e3$env    = 0;
    c4$e3$tmp    = 0;
    c4$env       = 0;
    c4$output    = 0;
    eq1$mx1      = 0;
    eq1$mx2      = 0;
    eq1$my1      = 0;
    eq1$my2      = 0;
    eq1$output   = 0;
    eq10$mx1     = 0;
    eq10$mx2     = 0;
    eq10$my1     = 0;
    eq10$my2     = 0;
    eq10$output  = 0;
    eq11$mx1     = 0;
    eq11$mx2     = 0;
    eq11$my1     = 0;
    eq11$my2     = 0;
    eq11$output  = 0;
    eq12$mx1     = 0;
    eq12$mx2     = 0;
    eq12$my1     = 0;
    eq12$my2     = 0;
    eq12$output  = 0;
    eq2$mx1      = 0;
    eq2$mx2      = 0;
    eq2$my1      = 0;
    eq2$my2      = 0;
    eq2$output   = 0;
    eq3$mx1      = 0;
    eq3$mx2      = 0;
    eq3$my1      = 0;
    eq3$my2      = 0;
    eq3$output   = 0;
    eq4$mx1      = 0;
    eq4$mx2      = 0;
    eq4$my1      = 0;
    eq4$my2      = 0;
    eq4$output   = 0;
    eq5$mx1      = 0;
    eq5$mx2      = 0;
    eq5$my1      = 0;
    eq5$my2      = 0;
    eq5$output   = 0;
    eq6$mx1      = 0;
    eq6$mx2      = 0;
    eq6$my1      = 0;
    eq6$my2      = 0;
    eq6$output   = 0;
    eq7$mx1      = 0;
    eq7$mx2      = 0;
    eq7$my1      = 0;
    eq7$my2      = 0;
    eq7$output   = 0;
    eq8$mx1      = 0;
    eq8$mx2      = 0;
    eq8$my1      = 0;
    eq8$my2      = 0;
    eq8$output   = 0;
    eq9$mx1      = 0;
    eq9$mx2      = 0;
    eq9$my1      = 0;
    eq9$my2      = 0;
    eq9$output   = 0;
    hf1$mx1      = 0;
    hf1$mx2      = 0;
    hf1$my1      = 0;
    hf1$my2      = 0;
    hf1$output   = 0;
    l1$e1$env    = 0;
    l1$e1$tmp    = 0;
    l1$e2$env    = 0;
    l1$e2$tmp    = 0;
    l1$e3$env    = 0;
    l1$e3$tmp    = 0;
    l1$env       = 0;
    l1$th        = 0;
    lf1$mx1      = 0;
    lf1$mx2      = 0;
    lf1$my1      = 0;
    lf1$my2      = 0;
    lf1$output   = 0;
    lf2$mx1      = 0;
    lf2$mx2      = 0;
    lf2$my1      = 0;
    lf2$my2      = 0;
    lf2$output   = 0;
    mf1$mx1      = 0;
    mf1$mx2      = 0;
    mf1$my1      = 0;
    mf1$my2      = 0;
    mf1$output   = 0;
    mf2$mx1      = 0;
    mf2$mx2      = 0;
    mf2$my1      = 0;
    mf2$my2      = 0;
    mf2$output   = 0;
    od$f1$mx1    = 0;
    od$f1$mx2    = 0;
    od$f1$my1    = 0;
    od$f1$my2    = 0;
    od$f1$output = 0;
    od$f2$mx1    = 0;
    od$f2$mx2    = 0;
    od$f2$my1    = 0;
    od$f2$my2    = 0;
    od$f2$output = 0;
    od$f3$mx1    = 0;
    od$f3$mx2    = 0;
    od$f3$my1    = 0;
    od$f3$my2    = 0;
    od$f3$output = 0;
    od$f4$mx1    = 0;
    od$f4$mx2    = 0;
    od$f4$my1    = 0;
    od$f4$my2    = 0;
    od$f4$output = 0;
    od$rms       = 0;
    od$s1        = 0;
    rmss         = 0;
    sb1$mx1      = 0;
    sb1$mx2      = 0;
    sb1$my1      = 0;
    sb1$my2      = 0;
    sb1$output   = 0;
    sf$mx1       = 0;
    sf$mx2       = 0;
    sf$my1       = 0;
    sf$my2       = 0;
    sf$output    = 0;
    sgn          = 0;
  }
  //----------------------------------------------------------------------------
public:
  void reset (plugin_context& pc)
  {
#if 0
    !0.; /* jsfx2cpp strings unsupported: was: "#define VAL(A) (A) */
    ;
    buildstr = 0.; /* jsfx2cpp strings unsupported: was: "build 170206" */
    ;
#endif
    init_init_variables();
    init_slider_variables();
    init_block_variables();

    sample_rate = pc.get_sample_rate();
    t01         = std::exp (-1. / (jsfx_specialvar_get_srate() * 0.001));
    t20         = std::exp (-1. / (jsfx_specialvar_get_srate() * 0.02));
    t40         = std::exp (-1. / (jsfx_specialvar_get_srate() * 0.04));
    t60         = std::exp (-1. / (jsfx_specialvar_get_srate() * 0.06));
    t200        = std::exp (-1. / (jsfx_specialvar_get_srate() * 0.2));
    rmsw        = 1.
      - std::exp (
             -2. * 3.141592653589793 * ((1. / 1000.) * 1000.)
             / jsfx_specialvar_get_srate());
    m4 = 100.;
    m3 = m4;
    m2 = m3;
    m1 = m2;
    ;
    init$megafilter_init (
      2000.,
      1.,
      0.,
      5.,
      od$f1$a,
      od$f1$omega,
      od$f1$tsin,
      od$f1$tcos,
      od$f1$alpha,
      od$f1$beta,
      od$f1$b0,
      od$f1$b1,
      od$f1$b2,
      od$f1$a0,
      od$f1$a1,
      od$f1$a2);
    init$megafilter_init (
      1000.,
      0.5,
      0.,
      4.,
      od$f2$a,
      od$f2$omega,
      od$f2$tsin,
      od$f2$tcos,
      od$f2$alpha,
      od$f2$beta,
      od$f2$b0,
      od$f2$b1,
      od$f2$b2,
      od$f2$a0,
      od$f2$a1,
      od$f2$a2);
    init$megafilter_init (
      1000.,
      0.5,
      0.,
      8.,
      od$f3$a,
      od$f3$omega,
      od$f3$tsin,
      od$f3$tcos,
      od$f3$alpha,
      od$f3$beta,
      od$f3$b0,
      od$f3$b1,
      od$f3$b2,
      od$f3$a0,
      od$f3$a1,
      od$f3$a2);
    init$megafilter_init (
      300.,
      0.9,
      0.,
      5.,
      od$f4$a,
      od$f4$omega,
      od$f4$tsin,
      od$f4$tcos,
      od$f4$alpha,
      od$f4$beta,
      od$f4$b0,
      od$f4$b1,
      od$f4$b2,
      od$f4$a0,
      od$f4$a1,
      od$f4$a2);
    init$megafilter_init (
      80.,
      1.,
      0.,
      4.,
      sf$a,
      sf$omega,
      sf$tsin,
      sf$tcos,
      sf$alpha,
      sf$beta,
      sf$b0,
      sf$b1,
      sf$b2,
      sf$a0,
      sf$a1,
      sf$a2);
    init$megafilter_init (
      70.,
      1.,
      0.,
      5.,
      lf1$a,
      lf1$omega,
      lf1$tsin,
      lf1$tcos,
      lf1$alpha,
      lf1$beta,
      lf1$b0,
      lf1$b1,
      lf1$b2,
      lf1$a0,
      lf1$a1,
      lf1$a2);
    init$megafilter_init (
      220.,
      0.6,
      0.,
      4.,
      lf2$a,
      lf2$omega,
      lf2$tsin,
      lf2$tcos,
      lf2$alpha,
      lf2$beta,
      lf2$b0,
      lf2$b1,
      lf2$b2,
      lf2$a0,
      lf2$a1,
      lf2$a2);
    init$megafilter_init (
      220.,
      0.6,
      0.,
      5.,
      mf1$a,
      mf1$omega,
      mf1$tsin,
      mf1$tcos,
      mf1$alpha,
      mf1$beta,
      mf1$b0,
      mf1$b1,
      mf1$b2,
      mf1$a0,
      mf1$a1,
      mf1$a2);
    init$megafilter_init (
      1600.,
      0.7,
      0.,
      4.,
      mf2$a,
      mf2$omega,
      mf2$tsin,
      mf2$tcos,
      mf2$alpha,
      mf2$beta,
      mf2$b0,
      mf2$b1,
      mf2$b2,
      mf2$a0,
      mf2$a1,
      mf2$a2);
    slider();
  }
  //----------------------------------------------------------------------------
private:
  void slider()
  {
    double locut      = 0.;
    double p1$val_pos = 0.;
    double p2$val_pos = 0.;
    double p3$val_pos = 0.;
    double p4$val_pos = 0.;
    double p5$val_pos = 0.;
    double p6$val_pos = 0.;
    double p7$val_pos = 0.;
    double p8$val_pos = 0.;
    double p9$val_pos = 0.;
    double presence   = 0.;
    double speed      = 0.;
    p1$val_pos        = get_slider_slider1();
    p2$val_pos        = get_slider_slider2();
    p3$val_pos        = get_slider_slider3();
    p4$val_pos        = get_slider_slider4();
    p5$val_pos        = get_slider_slider5();
    p6$val_pos        = get_slider_slider6();
    p7$val_pos        = get_slider_slider7();
    p8$val_pos        = get_slider_slider8();
    p9$val_pos        = get_slider_slider9();
    speed             = (10. - get_slider_slider8()) / 3. + 1.;
    boost             = 0.5 + (10. - get_slider_slider8()) / 20.;
    locut             = 1. / (get_slider_slider9() + 1.25) + 0.20;
    profess           = eel2_pow (10., (get_slider_slider1() / 20.));
    output            = eel2_pow (10., (get_slider_slider2() / 20.));
    presence          = (10. - get_slider_slider3()) * 70. + 600.;
    dirt              = get_slider_slider4() / 10.;
    bass              = get_slider_slider5();
    middle            = get_slider_slider6();
    treble            = get_slider_slider7();
    init$megafilter_init (
      40.,
      locut,
      0.,
      5.,
      sb1$a,
      sb1$omega,
      sb1$tsin,
      sb1$tcos,
      sb1$alpha,
      sb1$beta,
      sb1$b0,
      sb1$b1,
      sb1$b2,
      sb1$a0,
      sb1$a1,
      sb1$a2);
    init$megafilter_init (
      presence,
      0.7,
      0.,
      5.,
      hf1$a,
      hf1$omega,
      hf1$tsin,
      hf1$tcos,
      hf1$alpha,
      hf1$beta,
      hf1$b0,
      hf1$b1,
      hf1$b2,
      hf1$a0,
      hf1$a1,
      hf1$a2);
    init$megafilter_init (
      110.,
      1.5,
      bass * 3.3,
      3.,
      eq1$a,
      eq1$omega,
      eq1$tsin,
      eq1$tcos,
      eq1$alpha,
      eq1$beta,
      eq1$b0,
      eq1$b1,
      eq1$b2,
      eq1$a0,
      eq1$a1,
      eq1$a2);
    init$megafilter_init (
      160.,
      3.,
      -bass * 2.5,
      3.,
      eq2$a,
      eq2$omega,
      eq2$tsin,
      eq2$tcos,
      eq2$alpha,
      eq2$beta,
      eq2$b0,
      eq2$b1,
      eq2$b2,
      eq2$a0,
      eq2$a1,
      eq2$a2);
    init$megafilter_init (
      60.,
      0.5,
      bass,
      3.,
      eq3$a,
      eq3$omega,
      eq3$tsin,
      eq3$tcos,
      eq3$alpha,
      eq3$beta,
      eq3$b0,
      eq3$b1,
      eq3$b2,
      eq3$a0,
      eq3$a1,
      eq3$a2);
    init$megafilter_init (
      1500.,
      2.,
      middle * 0.75,
      3.,
      eq4$a,
      eq4$omega,
      eq4$tsin,
      eq4$tcos,
      eq4$alpha,
      eq4$beta,
      eq4$b0,
      eq4$b1,
      eq4$b2,
      eq4$a0,
      eq4$a1,
      eq4$a2);
    init$megafilter_init (
      450.,
      0.5,
      middle * 1.5,
      3.,
      eq5$a,
      eq5$omega,
      eq5$tsin,
      eq5$tcos,
      eq5$alpha,
      eq5$beta,
      eq5$b0,
      eq5$b1,
      eq5$b2,
      eq5$a0,
      eq5$a1,
      eq5$a2);
    init$megafilter_init (
      160.,
      1.,
      -middle / 2.,
      3.,
      eq6$a,
      eq6$omega,
      eq6$tsin,
      eq6$tcos,
      eq6$alpha,
      eq6$beta,
      eq6$b0,
      eq6$b1,
      eq6$b2,
      eq6$a0,
      eq6$a1,
      eq6$a2);
    init$megafilter_init (
      350.,
      2.,
      middle * 3.,
      3.,
      eq7$a,
      eq7$omega,
      eq7$tsin,
      eq7$tcos,
      eq7$alpha,
      eq7$beta,
      eq7$b0,
      eq7$b1,
      eq7$b2,
      eq7$a0,
      eq7$a1,
      eq7$a2);
    init$megafilter_init (
      6000.,
      0.5,
      treble * 3.,
      3.,
      eq8$a,
      eq8$omega,
      eq8$tsin,
      eq8$tcos,
      eq8$alpha,
      eq8$beta,
      eq8$b0,
      eq8$b1,
      eq8$b2,
      eq8$a0,
      eq8$a1,
      eq8$a2);
    init$megafilter_init (
      1600.,
      2.,
      treble,
      3.,
      eq12$a,
      eq12$omega,
      eq12$tsin,
      eq12$tcos,
      eq12$alpha,
      eq12$beta,
      eq12$b0,
      eq12$b1,
      eq12$b2,
      eq12$a0,
      eq12$a1,
      eq12$a2);
    init$megafilter_init (
      2700.,
      3.,
      -treble,
      3.,
      eq11$a,
      eq11$omega,
      eq11$tsin,
      eq11$tcos,
      eq11$alpha,
      eq11$beta,
      eq11$b0,
      eq11$b1,
      eq11$b2,
      eq11$a0,
      eq11$a1,
      eq11$a2);
    init$megafilter_init (
      1200.,
      1.5,
      treble,
      2.,
      eq9$a,
      eq9$omega,
      eq9$tsin,
      eq9$tcos,
      eq9$alpha,
      eq9$beta,
      eq9$b0,
      eq9$b1,
      eq9$b2,
      eq9$a0,
      eq9$a1,
      eq9$a2);
    init$megafilter_init (
      2700.,
      2.,
      treble * 4.,
      3.,
      eq10$a,
      eq10$omega,
      eq10$tsin,
      eq10$tcos,
      eq10$alpha,
      eq10$beta,
      eq10$b0,
      eq10$b1,
      eq10$b2,
      eq10$a0,
      eq10$a1,
      eq10$a2);
    init$compressor_init (30., 60. * speed, 3., c1$attack, c1$release, c1$d);
    init$compressor_init (10., 60. * speed, 2., c2$attack, c2$release, c2$d);
    init$compressor_init (5., 40. * speed, 4., c3$attack, c3$release, c3$d);
    init$compressor_init (0., 60. * speed, 3., c4$attack, c4$release, c4$d);
    ;
  }
  //----------------------------------------------------------------------------
public:
  template <class T>
  void process_block_replacing (std::array<T*, 2> chnls, uint samples)
  {
    double hi        = 0.;
    double low       = 0.;
    double mid       = 0.;
    double mtr1      = 0.;
    double mtr2      = 0.;
    double mtr3      = 0.;
    double mtr4      = 0.;
    double norm      = 0.;
    double process   = 0.;
    double rms       = 0.;
    double sub       = 0.;
    double threshold = 0.;

    if (std::abs (sgn) > 0.001) {
      mtr1 = c1$env;
      mtr2 = c2$env;
      mtr3 = c3$env;
      mtr4 = c4$env;
    }
    else {
      mtr1 = ((mtr1 * 100.) + 1.) * 0.0099;
      mtr2 = ((mtr2 * 100.) + 1.) * 0.0099;
      mtr3 = ((mtr3 * 100.) + 1.) * 0.0099;
      mtr4 = ((mtr4 * 100.) + 1.) * 0.0099;
    }
    norm = (jsfx_rand (1.) * 0.0000000001);
    ;
    for (int $$i = 0, $$end = std::max (0, (int) (samples)); $$i < $$end;
         ++$$i) {
      T& spl0 = chnls[0][$$i];
      T& spl1 = chnls[1][$$i];
      sgn     = spl0 + norm;
      sgn     = init$megafilter (
        sgn,
        sb1$output,
        sb1$b0,
        sb1$b1,
        sb1$mx1,
        sb1$b2,
        sb1$mx2,
        sb1$a1,
        sb1$my1,
        sb1$a2,
        sb1$my2);
      sgn
        = init$overdrive (
            sgn,
            dirt,
            od$s1,
            od$rms,
            od$f1$output,
            od$f1$b0,
            od$f1$b1,
            od$f1$mx1,
            od$f1$b2,
            od$f1$mx2,
            od$f1$a1,
            od$f1$my1,
            od$f1$a2,
            od$f1$my2,
            od$f2$output,
            od$f2$b0,
            od$f2$b1,
            od$f2$mx1,
            od$f2$b2,
            od$f2$mx2,
            od$f2$a1,
            od$f2$my1,
            od$f2$a2,
            od$f2$my2,
            od$f3$output,
            od$f3$b0,
            od$f3$b1,
            od$f3$mx1,
            od$f3$b2,
            od$f3$mx2,
            od$f3$a1,
            od$f3$my1,
            od$f3$a2,
            od$f3$my2,
            od$f4$output,
            od$f4$b0,
            od$f4$b1,
            od$f4$mx1,
            od$f4$b2,
            od$f4$mx2,
            od$f4$a1,
            od$f4$my1,
            od$f4$a2,
            od$f4$my2)
        + sgn;
      sub = init$megafilter (
        sgn,
        sf$output,
        sf$b0,
        sf$b1,
        sf$mx1,
        sf$b2,
        sf$mx2,
        sf$a1,
        sf$my1,
        sf$a2,
        sf$my2);
      low = init$megafilter (
        sgn,
        lf1$output,
        lf1$b0,
        lf1$b1,
        lf1$mx1,
        lf1$b2,
        lf1$mx2,
        lf1$a1,
        lf1$my1,
        lf1$a2,
        lf1$my2);
      low = init$megafilter (
        low,
        lf2$output,
        lf2$b0,
        lf2$b1,
        lf2$mx1,
        lf2$b2,
        lf2$mx2,
        lf2$a1,
        lf2$my1,
        lf2$a2,
        lf2$my2);
      mid = init$megafilter (
        sgn,
        mf1$output,
        mf1$b0,
        mf1$b1,
        mf1$mx1,
        mf1$b2,
        mf1$mx2,
        mf1$a1,
        mf1$my1,
        mf1$a2,
        mf1$my2);
      mid = init$megafilter (
        mid,
        mf2$output,
        mf2$b0,
        mf2$b1,
        mf2$mx1,
        mf2$b2,
        mf2$mx2,
        mf2$a1,
        mf2$my1,
        mf2$a2,
        mf2$my2);
      hi = init$megafilter (
        sgn,
        hf1$output,
        hf1$b0,
        hf1$b1,
        hf1$mx1,
        hf1$b2,
        hf1$mx2,
        hf1$a1,
        hf1$my1,
        hf1$a2,
        hf1$my2);
      process
        = init$compressor (
            sub * profess,
            c1$env,
            c1$d,
            c1$attack,
            c1$release,
            c1$output,
            c1$e1$tmp,
            c1$e1$env,
            c1$e2$tmp,
            c1$e2$env,
            c1$e3$tmp,
            c1$e3$env)
        + init$compressor (
            low * profess,
            c2$env,
            c2$d,
            c2$attack,
            c2$release,
            c2$output,
            c2$e1$tmp,
            c2$e1$env,
            c2$e2$tmp,
            c2$e2$env,
            c2$e3$tmp,
            c2$e3$env)
        + init$compressor (
            mid * profess,
            c3$env,
            c3$d,
            c3$attack,
            c3$release,
            c3$output,
            c3$e1$tmp,
            c3$e1$env,
            c3$e2$tmp,
            c3$e2$env,
            c3$e3$tmp,
            c3$e3$env)
        + init$compressor (
            hi * profess,
            c4$env,
            c4$d,
            c4$attack,
            c4$release,
            c4$output,
            c4$e1$tmp,
            c4$e1$env,
            c4$e2$tmp,
            c4$e2$env,
            c4$e3$tmp,
            c4$e3$env);
      rmss += rmsw * (eel2_pow (process, 2.) - rmss);
      rms       = std::sqrt (rmss);
      rms       = std::max (rms, 0.1);
      threshold = rms * 5.01;
      if (eel2_ne (bass, 0.)) {
        if (bass > 0.) {
          process = init$megafilter (
            process,
            eq1$output,
            eq1$b0,
            eq1$b1,
            eq1$mx1,
            eq1$b2,
            eq1$mx2,
            eq1$a1,
            eq1$my1,
            eq1$a2,
            eq1$my2);
          process = init$megafilter (
            process,
            eq2$output,
            eq2$b0,
            eq2$b1,
            eq2$mx1,
            eq2$b2,
            eq2$mx2,
            eq2$a1,
            eq2$my1,
            eq2$a2,
            eq2$my2);
        }
        else {
          (process = init$megafilter (
             process,
             eq3$output,
             eq3$b0,
             eq3$b1,
             eq3$mx1,
             eq3$b2,
             eq3$mx2,
             eq3$a1,
             eq3$my1,
             eq3$a2,
             eq3$my2));
        }
      }
      if (eel2_ne (middle, 0.)) {
        if (middle > 0.) {
          process = init$megafilter (
            process,
            eq4$output,
            eq4$b0,
            eq4$b1,
            eq4$mx1,
            eq4$b2,
            eq4$mx2,
            eq4$a1,
            eq4$my1,
            eq4$a2,
            eq4$my2);
          process = init$megafilter (
            process,
            eq5$output,
            eq5$b0,
            eq5$b1,
            eq5$mx1,
            eq5$b2,
            eq5$mx2,
            eq5$a1,
            eq5$my1,
            eq5$a2,
            eq5$my2);
          process = init$megafilter (
            process,
            eq6$output,
            eq6$b0,
            eq6$b1,
            eq6$mx1,
            eq6$b2,
            eq6$mx2,
            eq6$a1,
            eq6$my1,
            eq6$a2,
            eq6$my2);
        }
        else {
          (process = init$megafilter (
             process,
             eq7$output,
             eq7$b0,
             eq7$b1,
             eq7$mx1,
             eq7$b2,
             eq7$mx2,
             eq7$a1,
             eq7$my1,
             eq7$a2,
             eq7$my2));
        }
      }
      if (eel2_ne (treble, 0.)) {
        if (treble > 0.) {
          process = init$megafilter (
            process,
            eq8$output,
            eq8$b0,
            eq8$b1,
            eq8$mx1,
            eq8$b2,
            eq8$mx2,
            eq8$a1,
            eq8$my1,
            eq8$a2,
            eq8$my2);
          process = init$megafilter (
            process,
            eq12$output,
            eq12$b0,
            eq12$b1,
            eq12$mx1,
            eq12$b2,
            eq12$mx2,
            eq12$a1,
            eq12$my1,
            eq12$a2,
            eq12$my2);
          process = init$megafilter (
            process,
            eq11$output,
            eq11$b0,
            eq11$b1,
            eq11$mx1,
            eq11$b2,
            eq11$mx2,
            eq11$a1,
            eq11$my1,
            eq11$a2,
            eq11$my2);
        }
        else {
          process = init$megafilter (
            process,
            eq9$output,
            eq9$b0,
            eq9$b1,
            eq9$mx1,
            eq9$b2,
            eq9$mx2,
            eq9$a1,
            eq9$my1,
            eq9$a2,
            eq9$my2);
          process = init$megafilter (
            process,
            eq10$output,
            eq10$b0,
            eq10$b1,
            eq10$mx1,
            eq10$b2,
            eq10$mx2,
            eq10$a1,
            eq10$my1,
            eq10$a2,
            eq10$my2);
        }
      }
      process = init$limiter (
        process,
        threshold,
        l1$th,
        l1$env,
        l1$e1$tmp,
        l1$e1$env,
        l1$e2$tmp,
        l1$e2$env,
        l1$e3$tmp,
        l1$e3$env);
      spl0 = process * output;
      spl1 = process * output;
      ;
    }
  }
  // functions for section "init"
private:
  //----------------------------------------------------------------------------
  double init$compressor (
    double  input,
    double& env,
    double& d,
    double& attack,
    double& release,
    double& output,
    double& e1$tmp,
    double& e1$env,
    double& e2$tmp,
    double& e2$env,
    double& e3$tmp,
    double& e3$env)
  {
    env = init$follower (std::abs (input) * d, attack, release, e1$tmp, e1$env);
    env = init$follower (env, 0., t20, e2$tmp, e2$env);
    env = init$follower (env, 0., t20, e3$tmp, e3$env);
    env = 1. / (env + boost);
    output = input * env;
    return output;
  }
  //----------------------------------------------------------------------------
  double init$compressor_init (
    double  att,
    double  rel,
    double  drive,
    double& attack,
    double& release,
    double& d)
  {
    attack  = std::exp (-1. / (jsfx_specialvar_get_srate() * att / 1000.));
    release = std::exp (-1. / (jsfx_specialvar_get_srate() * rel / 1000.));
    d       = drive;
    return d;
  }
  //----------------------------------------------------------------------------
  double init$follower (
    double  input,
    double  att,
    double  rel,
    double& tmp,
    double& env)
  {
    tmp = input;
    (env = rel * (env - tmp) + tmp);
    return [&] {
      if ((tmp > env)) {
        (env = att * (env - tmp) + tmp);
        return env;
      }
      else {
        return env;
      }
    }();
  }
  //----------------------------------------------------------------------------
  double init$limiter (
    double  input,
    double  threshold,
    double& th,
    double& env,
    double& e1$tmp,
    double& e1$env,
    double& e2$tmp,
    double& e2$env,
    double& e3$tmp,
    double& e3$env)
  {
    th = std::max (std::abs (input), threshold);
    th /= threshold;
    if (th > 1.) {
      limit_active = 1.;
    }
    env = init$follower (th, t01, t60, e1$tmp, e1$env);
    env = init$follower (env, 0., t20, e2$tmp, e2$env);
    env = init$follower (env, 0., t20, e3$tmp, e3$env);
    env = std::max (env, 1.);
    return input / env;
  }
  //----------------------------------------------------------------------------
  double init$megafilter (
    double  input,
    double& output,
    double& b0,
    double& b1,
    double& mx1,
    double& b2,
    double& mx2,
    double& a1,
    double& my1,
    double& a2,
    double& my2)
  {
    output = b0 * input + b1 * mx1 + b2 * mx2 - a1 * my1 - a2 * my2;
    mx2    = mx1;
    mx1    = input;
    my2    = my1;
    my1    = output;
    return my1;
  }
  //----------------------------------------------------------------------------
  double init$megafilter_init (
    double  freq,
    double  q,
    double  gain,
    double  type,
    double& a,
    double& omega,
    double& tsin,
    double& tcos,
    double& alpha,
    double& beta,
    double& b0,
    double& b1,
    double& b2,
    double& a0,
    double& a1,
    double& a2)
  {
    type  = std::max (type, 1.);
    type  = std::min (type, 8.);
    q     = std::max (q, 0.01);
    q     = std::min (q, 10.);
    freq  = std::max (freq, 0.1);
    freq  = std::min (freq, jsfx_specialvar_get_srate() / 2.);
    a     = std::pow (10.0, (gain / 40.0));
    omega = 2. * 3.141592653589793 * freq / jsfx_specialvar_get_srate();
    tsin  = std::sin (omega);
    tcos  = std::cos (omega);
    alpha = tsin / (2.0 * q);
    beta  = std::sqrt (a) / q;
    temp  = freq + q + gain + type;
    if (eel2_eq (type, 1.)) {
      b0 = (a * ((a + 1.0) - (a - 1.0) * tcos + beta * tsin));
      b1 = (2.0 * a * ((a - 1.0) - (a + 1.0) * tcos));
      b2 = (a * ((a + 1.0) - (a - 1.0) * tcos - beta * tsin));
      a0 = ((a + 1.0) + (a - 1.0) * tcos + beta * tsin);
      a1 = (-2.0 * ((a - 1.0) + (a + 1.0) * tcos));
      a2 = ((a + 1.0) + (a - 1.0) * tcos - beta * tsin);
    }
    if (eel2_eq (type, 2.)) {
      b0 = (a * ((a + 1.0) + (a - 1.0) * tcos + beta * tsin));
      b1 = (-2.0 * a * ((a - 1.0) + (a + 1.0) * tcos));
      b2 = (a * ((a + 1.0) + (a - 1.0) * tcos - beta * tsin));
      a0 = ((a + 1.0) - (a - 1.0) * tcos + beta * tsin);
      a1 = (2.0 * ((a - 1.0) - (a + 1.0) * tcos));
      a2 = ((a + 1.0) - (a - 1.0) * tcos - beta * tsin);
    }
    if (eel2_eq (type, 3.)) {
      b0 = 1.0 + alpha * a;
      b1 = -2.0 * tcos;
      b2 = 1.0 - alpha * a;
      a0 = 1.0 + alpha / a;
      a1 = -2.0 * tcos;
      a2 = 1.0 - alpha / a;
    }
    if (eel2_eq (type, 4.)) {
      b0 = (1. - tcos) / 2.;
      b1 = 1. - tcos;
      b2 = (1. - tcos) / 2.;
      a0 = 1. + alpha;
      a1 = -2. * tcos;
      a2 = 1. - alpha;
    }
    if (eel2_eq (type, 5.)) {
      b0 = (1. + tcos) / 2.;
      b1 = -(1. + tcos);
      b2 = (1. + tcos) / 2.;
      a0 = 1. + alpha;
      a1 = -2. * tcos;
      a2 = 1. - alpha;
    }
    if (eel2_eq (type, 6.)) {
      b0 = alpha;
      b1 = 0.0;
      b2 = -alpha;
      a0 = 1.0 + alpha;
      a1 = -2.0 * tcos;
      a2 = 1.0 - alpha;
    }
    if (eel2_eq (type, 7.)) {
      b0 = 1.0;
      b1 = -2.0 * tcos;
      b2 = 1.0;
      a0 = 1.0 + alpha;
      a1 = -2.0 * tcos;
      a2 = 1.0 - alpha;
    }
    if (eel2_eq (type, 8.)) {
      b0 = 1.0 - alpha;
      b1 = -2.0 * tcos;
      b2 = 1.0 + alpha;
      a0 = 1.0 + alpha;
      a1 = -2.0 * tcos;
      a2 = 1.0 - alpha;
    }
    b0 /= a0;
    b1 /= a0;
    b2 /= a0;
    a1 /= a0;
    a2 /= a0;
    return a2;
  }
  //----------------------------------------------------------------------------
  double init$overdrive (
    double  input,
    double  gain,
    double& s1,
    double& rms,
    double& f1$output,
    double& f1$b0,
    double& f1$b1,
    double& f1$mx1,
    double& f1$b2,
    double& f1$mx2,
    double& f1$a1,
    double& f1$my1,
    double& f1$a2,
    double& f1$my2,
    double& f2$output,
    double& f2$b0,
    double& f2$b1,
    double& f2$mx1,
    double& f2$b2,
    double& f2$mx2,
    double& f2$a1,
    double& f2$my1,
    double& f2$a2,
    double& f2$my2,
    double& f3$output,
    double& f3$b0,
    double& f3$b1,
    double& f3$mx1,
    double& f3$b2,
    double& f3$mx2,
    double& f3$a1,
    double& f3$my1,
    double& f3$a2,
    double& f3$my2,
    double& f4$output,
    double& f4$b0,
    double& f4$b1,
    double& f4$mx1,
    double& f4$b2,
    double& f4$mx2,
    double& f4$a1,
    double& f4$my1,
    double& f4$a2,
    double& f4$my2)
  {
    return [&] {
      if (gain) {
        input = init$megafilter (
          input,
          f1$output,
          f1$b0,
          f1$b1,
          f1$mx1,
          f1$b2,
          f1$mx2,
          f1$a1,
          f1$my1,
          f1$a2,
          f1$my2);
        s1 += rmsw * (eel2_pow (input, 2.) - s1);
        rms = std::sqrt (s1);
        rms = 0.0001 / (rms + 0.0001) * 100.;
        rms = std::min (rms, 5.623);
        input *= rms;
        input = std::atan (input * gain * 800.) * (0.03 + gain / 100.);
        input = init$megafilter (
          input,
          f2$output,
          f2$b0,
          f2$b1,
          f2$mx1,
          f2$b2,
          f2$mx2,
          f2$a1,
          f2$my1,
          f2$a2,
          f2$my2);
        input = init$megafilter (
          input,
          f3$output,
          f3$b0,
          f3$b1,
          f3$mx1,
          f3$b2,
          f3$mx2,
          f3$a1,
          f3$my1,
          f3$a2,
          f3$my2);
        input = init$megafilter (
          input,
          f4$output,
          f4$b0,
          f4$b1,
          f4$mx1,
          f4$b2,
          f4$mx2,
          f4$a1,
          f4$my1,
          f4$a2,
          f4$my2);
        return input;
      }
      else {
#if 0
        return 0. / 0.;
#else
        // same classic hard to fix on jsfx2cpp issue
        return input;
#endif
      }
    }();
  }
}; /* bass_professor */
}} // namespace artv::sonic_anomaly

#pragma once
// Generated by jsfx2cpp.py. To be manually corrected.
// includes for environment function calls
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wunused-value"

#include <algorithm>
#include <cmath>
#include <cstring>
#include <vector>

#include <juce_audio_processors/juce_audio_processors.h>

#include "artv-common/dsp/own/classes/plugin_context.hpp"
#include "artv-common/dsp/types.hpp"
#include "artv-common/juce/parameter_definitions.hpp"
#include "artv-common/juce/parameter_types.hpp"
#include "artv-common/misc/mp11.hpp"
#include "artv-common/misc/range.hpp"
#include "artv-common/misc/short_ints.hpp"
#include "artv-common/misc/util.hpp"

namespace artv { namespace sonic_anomaly {

struct slax {
public:
  //----------------------------------------------------------------------------
  static constexpr dsp_types dsp_type  = dsp_types::dynamics;
  static constexpr bus_types bus_type  = bus_types::stereo;
  static constexpr uint      n_inputs  = 1;
  static constexpr uint      n_outputs = 1;
  //----------------------------------------------------------------------------
private:
  // definitions for environment function calls
  static double eel2_eq (double lhs, double rhs)
  {
    return (double) (std::fabs (lhs - rhs) < 0.00001);
  }
  static double eel2_pow (double lhs, double rhs)
  {
    return std::pow (lhs, rhs);
  }

  std::vector<float> heapmem;
  inline float&      heap (std::size_t value) { return heapmem[value]; }
  void               heap_reset (std::size_t s)
  { /*heap_reset has to be set after manual analysis of the mem requirements*/
    heapmem.resize (s);
    std::memset (heapmem.data(), 0, heapmem.size() * sizeof heapmem[0]);
  }

  //----------------------------------------------------------------------------
  double jsfx_specialvar_get_srate() { return _plugcontext->get_sample_rate(); }
  //----------------------------------------------------------------------------
public:
#if 0
  void set_slider1_slider (float v)
  {
    // Original slider line: slider1:0<0,10,0.1>-Peak
    // Range: min:0.0, max:10.0, default: 0.0, step: 0.1
    if (v == slider1) {
      return;
    }
    slider1 = v;
    slider();
  }
#else
  // Snippet for parameter boilerplate in the authors framework....
  struct peak_tag {};

  void set (peak_tag, float v)
  {
    // Original slider line: slider1:0<0,10,0.1>-Peak
    // Range: min:0.0, max:10.0, default: 0.0, step: 0.1
    if (v == slider1) {
      return;
    }
    slider1 = v;
    slider();
  }

  static constexpr auto get_parameter (peak_tag)
  {
    // Original slider line: slider1:0<0,10,0.1>-Peak
    return float_param ("", 0.0, 10.0, 0.0, 0.1);
  }

#endif
#if 0
  void set_slider2_slider (float v)
  {
    // Original slider line: slider2:0<0,10,0.1>-Gain
    // Range: min:0.0, max:10.0, default: 0.0, step: 0.1
    if (v == slider2) {
      return;
    }
    slider2 = v;
    slider();
  }
#else
  // Snippet for parameter boilerplate in the authors framework....
  struct gain_tag {};

  void set (gain_tag, float v)
  {
    // Original slider line: slider2:0<0,10,0.1>-Gain
    // Range: min:0.0, max:10.0, default: 0.0, step: 0.1
    if (v == slider2) {
      return;
    }
    slider2 = v;
    slider();
  }

  static constexpr auto get_parameter (gain_tag)
  {
    // Original slider line: slider2:0<0,10,0.1>-Gain
    return float_param ("", 0.0, 10.0, 0.0, 0.1);
  }

#endif
#if 0
  void set_slider3_slider (float v)
  {
    // Original slider line: slider3:5<0,10,0.1>-Comp/Lim
    // Range: min:0.0, max:10.0, default: 5.0, step: 0.1
    if (v == slider3) {
      return;
    }
    slider3 = v;
    slider();
  }
#else
  // Snippet for parameter boilerplate in the authors framework....
  struct comp_lim_tag {};

  void set (comp_lim_tag, float v)
  {
    // Original slider line: slider3:5<0,10,0.1>-Comp/Lim
    // Range: min:0.0, max:10.0, default: 5.0, step: 0.1
    if (v == slider3) {
      return;
    }
    slider3 = v;
    slider();
  }

  static constexpr auto get_parameter (comp_lim_tag)
  {
    // Original slider line: slider3:5<0,10,0.1>-Comp/Lim
    return float_param ("", 0.0, 10.0, 5.0, 0.1);
  }

#endif
#if 0
  void set_slider4_slider (float v)
  {
    // Original slider line: slider4:10<0,10,0.1>-Emphasis
    // Range: min:0.0, max:10.0, default: 10.0, step: 0.1
    if (v == slider4) {
      return;
    }
    slider4 = v;
    slider();
  }
#else
  // Snippet for parameter boilerplate in the authors framework....
  struct emphasis_tag {};

  void set (emphasis_tag, float v)
  {
    // Original slider line: slider4:10<0,10,0.1>-Emphasis
    // Range: min:0.0, max:10.0, default: 10.0, step: 0.1
    if (v == slider4) {
      return;
    }
    slider4 = v;
    slider();
  }

  static constexpr auto get_parameter (emphasis_tag)
  {
    // Original slider line: slider4:10<0,10,0.1>-Emphasis
    return float_param ("", 0.0, 10.0, 10.0, 0.1);
  }

#endif
#if 0
  void set_slider5_slider (float v)
  {
    // Original slider line: slider5:1<0,2,1{Flat,Fat 1,Fat 2}>-Mode
    // Range: min:0.0, max:2.0, default: 1.0, step: 1.0
    if (v == slider5) {
      return;
    }
    slider5 = v;
    slider();
  }
#else
  // Snippet for parameter boilerplate in the authors framework....
  struct mode_tag {};

  void set (mode_tag, float v)
  {
    // Original slider line: slider5:1<0,2,1{Flat,Fat 1,Fat 2}>-Mode
    // Range: min:0.0, max:2.0, default: 1.0, step: 1.0
    if (v == slider5) {
      return;
    }
    slider5 = v;
    slider();
  }

  static constexpr auto get_parameter (mode_tag)
  {
    // Original slider line: slider5:1<0,2,1{Flat,Fat 1,Fat 2}>-Mode
    return choice_param (0, make_cstr_array ("Flat", "Fat 1", "Fat 2"));
  }

#endif
#if 0
#else
  // Snippet for parameter boilerplate in the authors framework....
  using parameters
    = mp_list<peak_tag, gain_tag, comp_lim_tag, emphasis_tag, mode_tag>;
#endif
private:
  //----------------------------------------------------------------------------
  // global/stateful variables for section "init"
  double buildstr;
  double cb1$checked;
  double cb2$checked;
  double cb3$checked;
  double e$a;
  double e$a2;
  double e$r;
  double e$r2;
  double e$s;
  double f0$n0;
  double f0$weight;
  double f1$n0;
  double f1$weight;
  double f2$n0;
  double f2$weight;
  double f3$n0;
  double f3$weight;
  double f4$n0;
  double f4$weight;
  double fr$weight;
  double hbx;
  double hby;
  double lut0$end;
  double lut0$i;
  double lut0$invstep;
  double lut0$len;
  double lut0$maxval;
  double lut0$start;
  double lut0$v;
  double lutmem;
  double mtr$weight;
  double peaktmp;
  double slider1;
  double slider2;
  double slider3;
  double slider4;
  double slider5;
  double sn$maxscount;
  double sn$out;
  double splsniffer$timeout;
  double sr$weight;
  double t005;
  double t01;
  double t05;
  double t10;
  double t100;
  double t1000;
  double t20;
  double t200;
  double t2000;
  double t50;
  double t500;
  double t60;
  double w1;
  double w2;
  double w3;
  //----------------------------------------------------------------------------
  void init_init_variables()
  {
    buildstr           = 0;
    cb1$checked        = 0;
    cb2$checked        = 0;
    cb3$checked        = 0;
    e$a                = 0;
    e$a2               = 0;
    e$r                = 0;
    e$r2               = 0;
    e$s                = 0;
    f0$n0              = 0;
    f0$weight          = 0;
    f1$n0              = 0;
    f1$weight          = 0;
    f2$n0              = 0;
    f2$weight          = 0;
    f3$n0              = 0;
    f3$weight          = 0;
    f4$n0              = 0;
    f4$weight          = 0;
    fr$weight          = 0;
    hbx                = 0;
    hby                = 0;
    lut0$end           = 0;
    lut0$i             = 0;
    lut0$invstep       = 0;
    lut0$len           = 0;
    lut0$maxval        = 0;
    lut0$start         = 0;
    lut0$v             = 0;
    lutmem             = 0;
    mtr$weight         = 0;
    peaktmp            = 0;
    slider1            = 0;
    slider2            = 0;
    slider3            = 0;
    slider4            = 0;
    slider5            = 0;
    sn$maxscount       = 0;
    sn$out             = 0;
    splsniffer$timeout = 0;
    sr$weight          = 0;
    t005               = 0;
    t01                = 0;
    t05                = 0;
    t10                = 0;
    t100               = 0;
    t1000              = 0;
    t20                = 0;
    t200               = 0;
    t2000              = 0;
    t50                = 0;
    t500               = 0;
    t60                = 0;
    w1                 = 0;
    w2                 = 0;
    w3                 = 0;
  }
  //----------------------------------------------------------------------------
  // global/stateful variables for section "block"
  double cl;
  double driver$s;
  double e$e;
  double e$tmp;
  double emphasis;
  double env;
  double f0$out;
  double f1$out;
  double f3$out;
  double f4$out;
  double fr$rms;
  double gain;
  double init;
  double lut0$floorindex;
  double lut0$frac;
  double lut0$hi;
  double lut0$index;
  double lut0$lo;
  double mode;
  double ofe;
  double outl;
  double outr;
  double peak;
  double sn$in$max;
  double sn$splcount;
  double sr$rms;
  //----------------------------------------------------------------------------
  void init_block_variables()
  {
    cl              = 0;
    driver$s        = 0;
    e$e             = 0;
    e$tmp           = 0;
    emphasis        = 0;
    env             = 0;
    f0$out          = 0;
    f1$out          = 0;
    f3$out          = 0;
    f4$out          = 0;
    fr$rms          = 0;
    gain            = 0;
    init            = 0;
    lut0$floorindex = 0;
    lut0$frac       = 0;
    lut0$hi         = 0;
    lut0$index      = 0;
    lut0$lo         = 0;
    mode            = 0;
    ofe             = 0;
    outl            = 0;
    outr            = 0;
    peak            = 0;
    sn$in$max       = 0;
    sn$splcount     = 0;
    sr$rms          = 0;
  }
  //----------------------------------------------------------------------------
  plugin_context* _plugcontext;

public:
  void reset (plugin_context& pc)
  {
    _plugcontext = &pc;

    slider1 = 0.0;
    slider2 = 0.0;
    slider3 = 5.0;
    slider4 = 10.0;
    slider5 = 1.0;
    !0.; /* jsfx2cpp strings unsupported: was: "#define VAL(A) (A) */
    ;
    buildstr = 0.; /* jsfx2cpp strings unsupported: was: "Build 170206" */
    ;
    t005  = std::exp (-1. / (jsfx_specialvar_get_srate() * 0.0005));
    t01   = std::exp (-1. / (jsfx_specialvar_get_srate() * 0.001));
    t05   = std::exp (-1. / (jsfx_specialvar_get_srate() * 0.005));
    t10   = std::exp (-1. / (jsfx_specialvar_get_srate() * 0.01));
    t20   = std::exp (-1. / (jsfx_specialvar_get_srate() * 0.02));
    t50   = std::exp (-1. / (jsfx_specialvar_get_srate() * 0.05));
    t60   = std::exp (-1. / (jsfx_specialvar_get_srate() * 0.06));
    t100  = std::exp (-1. / (jsfx_specialvar_get_srate() * 0.1));
    t200  = std::exp (-1. / (jsfx_specialvar_get_srate() * 0.2));
    t500  = std::exp (-1. / (jsfx_specialvar_get_srate() * 0.5));
    t1000 = std::exp (-1. / (jsfx_specialvar_get_srate() * 1.));
    t2000 = std::exp (-1. / (jsfx_specialvar_get_srate() * 2.));

#if 0
    init$fillenvlut (
      1000.,
      11001.,
      0.01,
      lut0$len,
      lut0$maxval,
      lut0$start,
      lut0$end,
      lut0$invstep,
      lut0$i,
      lut0$v);
#else
    constexpr int curve_lut_size = 2000;
    heap_reset (curve_lut_size);
    init$fillenvlut (
      0.,
      curve_lut_size,
      0.01,
      lut0$len,
      lut0$maxval,
      lut0$start,
      lut0$end,
      lut0$invstep,
      lut0$i,
      lut0$v);
#endif
    splsniffer$timeout = jsfx_specialvar_get_srate() / 4.;
    init$rms_init (10., fr$weight);
    init$rms_init (1000., sr$weight);
    init$hflf_init (60., f0$n0, f0$weight);
    init$hflf_init (16000., f1$n0, f1$weight);
    init$hflf_init (16000., f2$n0, f2$weight);
    init$hflf_init (200., f3$n0, f3$weight);
    init$hflf_init (400., f4$n0, f4$weight);
    w1 = 1. - std::exp (-1. / (20. / 1000. * jsfx_specialvar_get_srate()));
    w2 = 1. - std::exp (-1. / (10. / 1000. * jsfx_specialvar_get_srate()));
    w3 = 1. - std::exp (-1. / (22.6643 / 1000. * jsfx_specialvar_get_srate()));
    init$rms_init (0.066, mtr$weight);
    peaktmp = 1.;
    init$followerinit (0., 20., 20., e$a, e$r, e$s, e$a2, e$r2);
    sn$maxscount = 2000.;
    sn$out       = 1.;
    hbx          = 200.;
    hby          = 150.;
    ;
  }
  //----------------------------------------------------------------------------
private:
  void slider()
  {
#if 0
    double s1$value = 0.;
    double s2$value = 0.;
    double s3$value = 0.;
    double s4$value = 0.;
    s1$value        = slider1;
    s2$value        = slider2;
    s3$value        = slider3;
    s4$value        = slider4;
#endif
    init$processsliders();
    ;
  }
  //----------------------------------------------------------------------------
  double fr$s = 0.;
  double sr$s = 0.;
  //----------------------------------------------------------------------------
public:
  template <class T>
  void process (crange<T*> outs, crange<T const*> ins, uint samples)
  {
    assert (outs.size() >= (n_outputs * (uint) bus_type));
    assert (ins.size() >= (n_inputs * (uint) bus_type));
    double boost  = 0.;
    double cut    = 0.;
    double fenv   = 0.;
    double ienv   = 0.;
    double in     = 0.;
    double invenv = 0.;
    double m      = 0.;
    double mtrenv = 0.;
    double of     = 0.;
    double s      = 0.;
    double senv   = 0.;

    double wenv = 0.;

    if (!init) {
      if (std::max (ins[0][0], ins[1][0]) > 0.001) {
        (fr$s = sr$s = 1.);
      }
      init = 1.;
    }
    for (int $$i = 0, $$end = samples; $$i < $$end; ++$$i) {
      auto& spl0 = outs[0][$$i];
      auto& spl1 = outs[1][$$i];
      spl0       = ins[0][$$i];
      spl1       = ins[1][$$i];

      if (
        init$samplesniffer (
          std::abs (spl0) + std::abs (spl1),
          sn$splcount,
          sn$in$max,
          sn$maxscount,
          sn$out)
        || env < 0.999) {
        in = [&] {
          if (std::abs (outl) < std::abs (outr)) {
            return outr;
          }
          else {
            return outl;
          }
        }();
        in += (init$lfcut (in, f1$n0, f1$weight, f1$out) * emphasis);
        in = std::abs (init$lfcut (in, f0$n0, f0$weight, f0$out)) * peak;
        wenv
          = eel2_pow (init$follower (in, e$tmp, e$s, e$e, e$r, e$r2), 2.) * 0.2;
        fr$weight = init$interpolate (w2, w1, (1. / (wenv + 1.)));
        ienv      = init$rms (in, fr$s, fr$weight, fr$rms);
        fenv      = init$getlutval (
          ienv,
          lut0$index,
          lut0$invstep,
          lut0$end,
          lut0$floorindex,
          lut0$start,
          lut0$lo,
          lut0$hi,
          lut0$frac);
        (driver$s += w3 * (fenv - driver$s));
        fenv   = driver$s;
        senv   = eel2_pow (init$rms (in, sr$s, sr$weight, sr$rms), cl) + 1.;
        env    = std::max ((senv * fenv), senv);
        env    = 1. / env;
        m      = (spl0 + spl1) * 0.5;
        s      = (spl0 - spl1) * 0.5;
        invenv = 1. - env;
        if (eel2_eq (mode, 1.)) {
          boost = init$hfcut (m, f3$n0, f3$weight, f3$out);
          m += boost * invenv * 0.5;
          s *= invenv * 0.5 + 1.;
        }
        if (eel2_eq (mode, 2.)) {
          boost = init$hfcut (m, f3$n0, f3$weight, f3$out);
          cut   = init$hfcut (m, f4$n0, f4$weight, f4$out);
          m += boost * invenv;
          m -= cut * invenv * 0.708;
          s *= invenv * 0.5 + 1.;
        }
        spl0 = (m + s);
        spl1 = (m - s);
        outl = (spl0 * env * 0.9) + (spl0 * 0.1);
        outr = (spl1 * env * 0.9) + (spl1 * 0.1);
        spl0 = outl * gain;
        spl1 = outr * gain;
        of   = std::max (std::abs (spl0), std::abs (spl1));
        of   = std::max (of, 0.989) - 0.989 + 1.;
        ofe  = std::max (of, ofe * t2000);
        spl0 /= ofe;
        spl1 /= ofe;
      }
      else {
        spl0 *= gain;
        spl1 *= gain;
      }
      mtrenv = env;
      ;
    }
  }
  // functions for section "init"
private:
  //----------------------------------------------------------------------------
  double init$curve (double input)
  {
    return [&] {
      if (std::abs (input) < 1.) {
        return input - (2. * eel2_pow (input, 3.)) * 0.3333
          + eel2_pow (input, 6.) * 0.16666;
      }
      else {
        return 0.501;
      }
    }();
  }
  //----------------------------------------------------------------------------
  double init$fillenvlut (
    double  start,
    double  end,
    double  step,
    double& $len,
    double& $maxval,
    double& $start,
    double& $end,
    double& $invstep,
    double& $i,
    double& $v)
  {
    $len     = end - start;
    $maxval  = $len * step;
    $start   = start;
    $end     = end;
    $invstep = 1. / step;
    lutmem   = start;
    $i       = 0.;
    return [&] {
      double $loop_ret_0 = {};
      for (int $$i = 0, $$end = std::max (0, (int) ($len)); $$i < $$end;
           ++$$i) {
        $v                 = $i * step;
        heap (lutmem + $i) = $v / init$curve ($v);
        $i += 1.;
        $loop_ret_0 = $i;
      }
      return $loop_ret_0;
    }();
  }
  //----------------------------------------------------------------------------
  double init$follower (
    double  in,
    double& $tmp,
    double& $s,
    double& $e,
    double& $r,
    double& $r2)
  {
    $tmp = std::max (in + $s * ($tmp - in), in);
    return [&] {
      if ($e < $tmp) {
        ($e = $tmp);
        return $e;
      }
      else {
        ($e = $r * $e + $r2 * $tmp);
        return $e;
      }
    }();
  }
  //----------------------------------------------------------------------------
  double init$followerinit (
    double  attack,
    double  release,
    double  smoothing,
    double& $a,
    double& $r,
    double& $s,
    double& $a2,
    double& $r2)
  {
    $a  = std::exp (-1. / (jsfx_specialvar_get_srate() * attack / 1000.));
    $r  = std::exp (-1. / (jsfx_specialvar_get_srate() * release / 1000.));
    $s  = std::exp (-1. / (jsfx_specialvar_get_srate() * smoothing / 1000.));
    $a2 = 1. - $a;
    $r2 = 1. - $r;
    return $r2;
  }
  //----------------------------------------------------------------------------
  double init$getlutval (
    double  in,
    double& $index,
    double& $invstep,
    double& $end,
    double& $floorindex,
    double& $start,
    double& $lo,
    double& $hi,
    double& $frac)
  {
    $index      = std::max (std::min (in * $invstep, $end), 1.);
    $floorindex = std::floor ($index);
    lutmem      = $start;
    $lo         = heap (lutmem + $floorindex);
    $hi         = heap (lutmem + ($floorindex + 1.));
    $frac       = $index - $floorindex;
    return init$interpolate ($lo, $hi, $frac);
  }
  //----------------------------------------------------------------------------
  double init$hfcut (double input, double& $n0, double& $weight, double& $out)
  {
    ($n0 += ((input - $n0 + 0.000000001) * $weight));
    $out = $n0;
    return $out;
  }
  //----------------------------------------------------------------------------
  double init$hflf_init (double freq, double& $n0, double& $weight)
  {
    $n0     = 0.;
    $weight = 1.
      - std::exp (-2. * 3.141592653589793 * freq / jsfx_specialvar_get_srate());
    return $weight;
  }
  //----------------------------------------------------------------------------
  double init$interpolate (double a, double b, double x)
  {
    return a + ((b - a) * x);
  }
  //----------------------------------------------------------------------------
  double init$lfcut (double input, double& $n0, double& $weight, double& $out)
  {
    ($n0 += ((input - $n0 + 0.000000001) * $weight));
    $out = input - $n0;
    return $out;
  }
  //----------------------------------------------------------------------------
  double init$processsliders()
  {
    peak = eel2_pow (
      10.,
      (init$interpolate (0., 50., eel2_pow ((slider1 / 10.), 0.66)) / 20.));
    gain = eel2_pow (
      10., (init$interpolate (0., 40., eel2_pow ((slider2 / 10.), 2.)) / 20.));
    cl       = init$interpolate (1., 10., (slider3 / 10.));
    emphasis = init$interpolate (0., 10., (slider4 / 10.));
    w2
      = 1.
      - std::exp (
          -1.
          / (init$interpolate (15., 5., (slider3 / 10.)) / 1000. * jsfx_specialvar_get_srate()));
    mode = slider5;
    if (eel2_eq (mode, 0.)) {
      cb1$checked = 1.;
      cb2$checked = 0.;
      cb3$checked = 0.;
    }
    if (eel2_eq (mode, 1.)) {
      cb1$checked = 0.;
      cb2$checked = 1.;
      cb3$checked = 0.;
    }
    return [&] {
      if (eel2_eq (mode, 2.)) {
        cb1$checked = 0.;
        cb2$checked = 0.;
        cb3$checked = 1.;
        return cb3$checked;
      }
      else {
        return 0. / 0.;
      }
    }();
  }
  //----------------------------------------------------------------------------
  double init$rms (double input, double& $s, double& $weight, double& $rms)
  {
    $s += $weight * (eel2_pow (input, 2.) - $s);
    $rms = std::sqrt ($s);
    return $rms;
  }
  //----------------------------------------------------------------------------
  double init$rms_init (double weight_ms, double& $weight)
  {
    $weight
      = 1. - std::exp (-1. / (weight_ms / 1000. * jsfx_specialvar_get_srate()));
    return $weight;
  }
  //----------------------------------------------------------------------------
  double init$samplesniffer (
    double  input,
    double& $splcount,
    double& $in$max,
    double& $maxscount,
    double& $out)
  {
    $splcount += 1.;
    $in$max = std::max (std::abs (input), $in$max);
    if (($splcount > $maxscount)) {
      if ($in$max > 0.00000001) {
        $out       = 1.;
        $maxscount = splsniffer$timeout;
      }
      else {
        $out       = 0.;
        $maxscount = 2.;
      }
      $in$max   = 0.;
      $splcount = 0.;
    }
    return $out;
  }
}; /* jsfx_process */
}} // namespace artv::sonic_anomaly

#pragma GCC diagnostic pop

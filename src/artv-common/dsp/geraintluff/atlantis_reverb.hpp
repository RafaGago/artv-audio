#pragma once

// REMINDER: to generate this I had to comment the UI imports.
// From commit 7ecb9004b77fcaa43b4f98bcd158cc2c968f5814

// Generated by jsfx2cpp.py. To be manually corrected.
// includes for environment function calls

#include <algorithm>
#include <cmath>
#include <cstdint>
#include <cstdlib>
#include <cstring>
#include <limits>
#include <vector>
// slider1:wet_db=-12<-60,12>-Wet (dB)
// slider2:dry_db=0<-60,12>-Dry (dB)
// slider3:window_ms=200<10,500>-Grain size (ms)
// slider4:decay_seconds=0.3<0.01,5>-Decay Period (s)
// slider5:high_damping_hz=6000<100,18000>-High Damping (Hz)
// slider6:low_damping_hz=120<20,500>-Low Damping (Hz)
// slider7:damping_strength=3<1,100>-Damping (strength)
// slider8:shimmer_factor=0<0,1>-Shimmer
// slider9:shimmer_tone=0<0,0.3>-Shimmer tone
// slider10:compressor_threshold_db=0<-60,0>-Compressor threshold
// slider11:compressor_ratio=2<1,10>-Compressor ratio
// slider12:release_decay_seconds=0.2<0.01,5>-Release Decay Period (s)
// slider13:release_mode=0<0,1,1{sustain,release}>-Release mode
// slider14:release_cc64=0<0,1,1{off,on}>-Release MIDI sustain (CC-64)
// slider15:detune_cents_per_second=0<0,1200>-Detune rate (cents/second)
// slider16:detune_shift_bias=0<-1,1>-Detune shift (up/down)

#include <juce_audio_processors/juce_audio_processors.h>

#include "artv-common/dsp/jsfx_engine/jsfx_engine.hpp"
#include "artv-common/dsp/own/classes/jsfx.hpp"
#include "artv-common/dsp/own/classes/misc.hpp"
#include "artv-common/dsp/own/classes/plugin_context.hpp"
#include "artv-common/dsp/types.hpp"
#include "artv-common/juce/parameter_definitions.hpp"
#include "artv-common/juce/parameter_types.hpp"
#include "artv-common/misc/misc.hpp"
#include "artv-common/misc/mp11.hpp"
#include "artv-common/misc/range.hpp"
#include "artv-common/misc/short_ints.hpp"

namespace artv { namespace geraint_luff {

class atlantis_reverb {
public:
  //----------------------------------------------------------------------------
  static constexpr dsp_types dsp_type  = dsp_types::reverb;
  static constexpr bus_types bus_type  = bus_types::stereo;
  static constexpr uint      n_inputs  = 1;
  static constexpr uint      n_outputs = 1;
  //----------------------------------------------------------------------------
  // definitions for environment function calls
private:
  static double eel2_and (double lhs, double rhs)
  {
    return (double) ((uint64_t) lhs & (uint64_t) rhs);
  }
  static double eel2_eq (double lhs, double rhs)
  {
    return (double) (std::abs (lhs - rhs) < 0.00001);
  }
  static bool   eel2_ne (double lhs, double rhs) { return !eel2_eq (lhs, rhs); }
  static double eel2_rshift (double lhs, double rhs)
  {
    return (double) ((uint32_t) lhs >> (uint32_t) rhs);
  }

  jsfx::fft jsfx_ffts;
  void      jsfx_fft (float start_index, uint size)
  {
    jsfx_ffts.get_fft (size)->forward (
      make_crange (&heap (start_index), size * 2));
  }
  void jsfx_ifft (float start_index, uint size)
  {
    jsfx_ffts.get_fft (size)->backward (
      make_crange (&heap (start_index), size * 2));
  }

  void jsfx_fft_ipermute (double start_index, uint size)
  {
    jsfx_ffts.get_fft (size)->reorder_before_backward (
      make_crange (&heap (start_index), size * 2));
  }
  void jsfx_fft_permute (double start_index, uint size)
  {
    jsfx_ffts.get_fft (size)->reorder_after_forward (
      make_crange (&heap (start_index), size * 2));
  }

  using simdwrapper = simd_mem<float, 32 / sizeof (float), 32>;
  std::vector<simdwrapper> heapmem;

  inline float& heap (std::size_t value)
  {
    // only GCC and Clang
    return heapmem[value / simdwrapper::n_elems][value % simdwrapper::n_elems];
  }

  void heap_reset (std::size_t s)
  { /*heap_reset has to be set after manual analysis of the mem requirements*/
    assert ((s % simdwrapper::n_elems) == 0);
    heapmem.resize (s / simdwrapper::n_elems);
    std::memset (heapmem.data(), 0, heapmem.size() * sizeof heapmem[0]);
  }

  void jsfx_memset (size_t idx, int val, size_t size)
  {
    std::memset (&heap (idx), val, size * sizeof heapmem[0][0]);
  }
#if 0
  void jsfx_midirecv (double offset, double& msg1, double& msg2, double& msg3)
  { /* TODO: stub, implement */
  }
  void jsfx_midisend (double offset, double msg1, double msg2)
  { /* TODO: stub, implement */
  }
  void jsfx_midisend (double offset, double msg1, double msg2, double msg3)
  { /* TODO: stub, implement */
  }
#endif
  double jsfx_rand (double maxv = 1.) { return jsfx_engine::rand (maxv); }

public:
  //----------------------------------------------------------------------------
  // stubs for JSFX special variables
#if 0
  double jsfx_specialvar_get_samplesblock()
  {
    return 0.; /* TODO: stub for getting JSFX var "samplesblock" */
  }
#endif
  float  sample_rate = 0;
  double jsfx_specialvar_get_srate() { return sample_rate; }

  //----------------------------------------------------------------------------
  // stubs for sliders
#if 0
  double get_slider_compressor_ratio()
  {
    // TODO: stub, add code for getting "compressor_ratio"
    // Range: min:1.0, max:10.0, default: 2.0, step: None
    // Original line: slider11:compressor_ratio=2<1,10>-Compressor ratio
    return 0.;
  }
#else
  // Snippet for parameter boilerplate in the authors framework....
  double get_slider_compressor_ratio()
  {
    // Range: min:1.0, max:10.0, default: 2.0, step: None
    return compressor_ratiop;
  }

  float compressor_ratiop = 2.0;

  struct compressor_ratio_tag {};

  void set (compressor_ratio_tag, float v)
  {
    if (v == compressor_ratiop) {
      return;
    }
    compressor_ratiop = v;
    slider();
  }

  static constexpr auto get_parameter (compressor_ratio_tag)
  {
    // Original slider line: slider11:compressor_ratio=2<1,10>-Compressor ratio
    return float_param ("", 1.0, 10.0, 2.0, 0.1, 0.3);
  }
#endif
#if 0
  double get_slider_compressor_threshold_db()
  {
    // TODO: stub, add code for getting "compressor_threshold_db"
    // Range: min:-60.0, max:0.0, default: 0.0, step: None
    // Original line: slider10:compressor_threshold_db=0<-60,0>-Compressor
    // threshold
    return 0.;
  }
#else
  // Snippet for parameter boilerplate in the authors framework....
  double get_slider_compressor_threshold_db()
  {
    // Range: min:-60.0, max:0.0, default: 0.0, step: None
    return compressor_threshold_dbp;
  }

  float compressor_threshold_dbp = 0.0;

  struct compressor_threshold_db_tag {};

  void set (compressor_threshold_db_tag, float v)
  {
    if (v == compressor_threshold_dbp) {
      return;
    }
    compressor_threshold_dbp = v;
    slider();
  }

  static constexpr auto get_parameter (compressor_threshold_db_tag)
  {
    // Original slider line:
    // slider10:compressor_threshold_db=0<-60,0>-Compressor threshold
    return float_param ("dB", -60.0, 0.0, 0.0, 0.1, 1.5);
  }
#endif
#if 0
  double get_slider_damping_strength()
  {
    // TODO: stub, add code for getting "damping_strength"
    // Range: min:1.0, max:100.0, default: 3.0, step: None
    // Original line: slider7:damping_strength=3<1,100>-Damping (strength)
    return 0.;
  }
#else
  // Snippet for parameter boilerplate in the authors framework....
  double get_slider_damping_strength()
  {
    // Range: min:1.0, max:100.0, default: 3.0, step: None
    return damping_strengthp;
  }

  float damping_strengthp = 3.0;

  struct damping_strength_tag {};

  void set (damping_strength_tag, float v)
  {
    if (v == damping_strengthp) {
      return;
    }
    damping_strengthp = v;
    slider();
  }

  static constexpr auto get_parameter (damping_strength_tag)
  {
    // Original slider line: slider7:damping_strength=3<1,100>-Damping
    // (strength)
    return float_param ("%", 1.0, 100.0, 3.0, 1.);
  }
#endif
#if 0
  double get_slider_decay_seconds()
  {
    // TODO: stub, add code for getting "decay_seconds"
    // Range: min:0.01, max:5.0, default: 0.3, step: None
    // Original line: slider4:decay_seconds=0.3<0.01,5>-Decay Period (s)
    return 0.;
  }
#else
  // Snippet for parameter boilerplate in the authors framework....
  double get_slider_decay_seconds()
  {
    // Range: min:0.01, max:5.0, default: 0.3, step: None
    return decay_secondsp;
  }

  float decay_secondsp = 0.3;

  struct decay_seconds_tag {};

  void set (decay_seconds_tag, float v)
  {
    if (v == decay_secondsp) {
      return;
    }
    decay_secondsp = v;
    slider();
  }

  static constexpr auto get_parameter (decay_seconds_tag)
  {
    // Original slider line: slider4:decay_seconds=0.3<0.01,5>-Decay Period (s)
    return float_param ("sec", 0.01, 5.0, 0.3, 0.01, 0.6);
  }
#endif
#if 0
  double get_slider_detune_cents_per_second()
  {
    // TODO: stub, add code for getting "detune_cents_per_second"
    // Range: min:0.0, max:1200.0, default: 0.0, step: None
    // Original line: slider15:detune_cents_per_second=0<0,1200>-Detune rate
    // (cents/second)
    return 0.;
  }
#else
  // Snippet for parameter boilerplate in the authors framework....
  double get_slider_detune_cents_per_second()
  {
    // Range: min:0.0, max:1200.0, default: 0.0, step: None
    return detune_cents_per_secondp;
  }

  float detune_cents_per_secondp = 0.0;

  struct detune_cents_per_second_tag {};

  void set (detune_cents_per_second_tag, float v)
  {
    if (v == detune_cents_per_secondp) {
      return;
    }
    detune_cents_per_secondp = v;
    slider();
  }

  static constexpr auto get_parameter (detune_cents_per_second_tag)
  {
    // Original slider line: slider15:detune_cents_per_second=0<0,1200>-Detune
    // rate (cents/second)
    return float_param ("Cents/s", 0.0, 1200.0, 0.0, 1, 0.5);
  }
#endif
#if 0
  double get_slider_detune_shift_bias()
  {
    // TODO: stub, add code for getting "detune_shift_bias"
    // Range: min:-1.0, max:1.0, default: 0.0, step: None
    // Original line: slider16:detune_shift_bias=0<-1,1>-Detune shift (up/down)
    return 0.;
  }
#else
  // Snippet for parameter boilerplate in the authors framework....
  double get_slider_detune_shift_bias()
  {
    // Range: min:-1.0, max:1.0, default: 0.0, step: None
    return detune_shift_biasp;
  }

  float detune_shift_biasp = 0.0;

  struct detune_shift_bias_tag {};

  void set (detune_shift_bias_tag, float v)
  {
    if (v == detune_shift_biasp) {
      return;
    }
    detune_shift_biasp = v;
    slider();
  }

  static constexpr auto get_parameter (detune_shift_bias_tag)
  {
    // Original slider line: slider16:detune_shift_bias=0<-1,1>-Detune shift
    // (up/down)
    return float_param ("", -1.0, 1.0, 0.0, 0.001);
  }
#endif
#if 0
  double get_slider_dry_db()
  {
    // TODO: stub, add code for getting "dry_db"
    // Range: min:-60.0, max:12.0, default: 0.0, step: None
    // Original line: slider2:dry_db=0<-60,12>-Dry (dB)
    return 0.;
  }
#else
  // Snippet for parameter boilerplate in the authors framework....
  double get_slider_dry_db()
  {
    // Range: min:-60.0, max:12.0, default: 0.0, step: None
    return dry_dbp;
  }

  float dry_dbp = -150.0;

  struct dry_db_tag {};

  void set (dry_db_tag, float v)
  {
    v = v > -60. ? v : -150.;
    if (v == dry_dbp) {
      return;
    }
    dry_dbp = v;
    slider();
  }

  static constexpr auto get_parameter (dry_db_tag)
  {
    // Original slider line: slider2:dry_db=0<-60,12>-Dry (dB)
    return float_param ("dB", -60.0, 12.0, -60., 0.1);
  }
#endif
#if 0
  double get_slider_high_damping_hz()
  {
    // TODO: stub, add code for getting "high_damping_hz"
    // Range: min:100.0, max:18000.0, default: 6000.0, step: None
    // Original line: slider5:high_damping_hz=6000<100,18000>-High Damping (Hz)
    return 0.;
  }
#else
  // Snippet for parameter boilerplate in the authors framework....
  double get_slider_high_damping_hz()
  {
    // Range: min:100.0, max:18000.0, default: 6000.0, step: None
    return high_damping_hzp;
  }

  float high_damping_hzp = 6000.0;

  struct high_damping_hz_tag {};

  void set (high_damping_hz_tag, float v)
  {
    v = midi_note_to_hz (v);
    if (v == high_damping_hzp) {
      return;
    }
    high_damping_hzp = v;
    slider();
  }

  static constexpr auto get_parameter (high_damping_hz_tag)
  {
    // Original slider line: slider5:high_damping_hz=6000<100,18000>-High
    // Damping (Hz)
    return frequency_parameter (100.0, 18000.0, 6000.0);
  }
#endif
#if 0
  double get_slider_low_damping_hz()
  {
    // TODO: stub, add code for getting "low_damping_hz"
    // Range: min:20.0, max:500.0, default: 120.0, step: None
    // Original line: slider6:low_damping_hz=120<20,500>-Low Damping (Hz)
    return 0.;
  }
#else
  // Snippet for parameter boilerplate in the authors framework....
  double get_slider_low_damping_hz()
  {
    // Range: min:20.0, max:500.0, default: 120.0, step: None
    return low_damping_hzp;
  }

  float low_damping_hzp = 120.0;

  struct low_damping_hz_tag {};

  void set (low_damping_hz_tag, float v)
  {
    v = midi_note_to_hz (v);
    if (v == low_damping_hzp) {
      return;
    }
    low_damping_hzp = v;
    slider();
  }

  static constexpr auto get_parameter (low_damping_hz_tag)
  {
    // Original slider line: slider6:low_damping_hz=120<20,500>-Low Damping (Hz)
    return frequency_parameter (200.0, 500.0, 120.0);
  }
#endif
#if 1
  double get_slider_release_cc64()
  {
    // TODO: stub, add code for getting "release_cc64"
    // Range: min:0.0, max:1.0, default: 0.0, step: 1.0
    // Original line: slider14:release_cc64=0<0,1,1{off,on}>-Release MIDI
    // sustain (CC-64)
    return 0.;
  }
#else
  // Snippet for parameter boilerplate in the authors framework....
  double get_slider_release_cc64()
  {
    // Range: min:0.0, max:1.0, default: 0.0, step: 1.0
    return release_cc64p;
  }

  float release_cc64p = 0.0;

  struct release_cc64_tag {};

  void set (release_cc64_tag, float v)
  {
    if (v == release_cc64p) {
      return;
    }
    release_cc64p = v;
    slider();
  }

  static constexpr auto get_parameter (release_cc64_tag)
  {
    // Original slider line: slider14:release_cc64=0<0,1,1{off,on}>-Release MIDI
    // sustain (CC-64)
    return float_param ("", 0.0, 1.0, 0.0, 1.0);
  }
#endif
#if 1
  double get_slider_release_decay_seconds()
  {
    // TODO: stub, add code for getting "release_decay_seconds"
    // Range: min:0.01, max:5.0, default: 0.2, step: None
    // Original line: slider12:release_decay_seconds=0.2<0.01,5>-Release Decay
    // Period (s)
    return 0.01;
  }
#else
  // Snippet for parameter boilerplate in the authors framework....
  double get_slider_release_decay_seconds()
  {
    // Range: min:0.01, max:5.0, default: 0.2, step: None
    return release_decay_secondsp;
  }

  float release_decay_secondsp = 0.2;

  struct release_decay_seconds_tag {};

  void set (release_decay_seconds_tag, float v)
  {
    if (v == release_decay_secondsp) {
      return;
    }
    release_decay_secondsp = v;
    slider();
  }

  static constexpr auto get_parameter (release_decay_seconds_tag)
  {
    // Original slider line: slider12:release_decay_seconds=0.2<0.01,5>-Release
    // Decay Period (s)
    return float_param ("sec", 0.01, 5.0, 0.2, 0.01, 0.7);
  }
#endif
#if 1
  double get_slider_release_mode()
  {
    // TODO: stub, add code for getting "release_mode"
    // Range: min:0.0, max:1.0, default: 0.0, step: 1.0
    // Original line: slider13:release_mode=0<0,1,1{sustain,release}>-Release
    // mode
    return 0.;
  }
#else
  // Snippet for parameter boilerplate in the authors framework....
  double get_slider_release_mode()
  {
    // Range: min:0.0, max:1.0, default: 0.0, step: 1.0
    return release_modep;
  }

  float release_modep = 0.0;

  struct release_mode_tag {};

  void set (release_mode_tag, float v)
  {
    if (v == release_modep) {
      return;
    }
    release_modep = v;
    slider();
  }

  static constexpr auto get_parameter (release_mode_tag)
  {
    // Original slider line:
    // slider13:release_mode=0<0,1,1{sustain,release}>-Release mode
    return float_param ("", 0.0, 1.0, 0.0, 1.0);
  }
#endif
#if 0
  double get_slider_shimmer_factor()
  {
    // TODO: stub, add code for getting "shimmer_factor"
    // Range: min:0.0, max:1.0, default: 0.0, step: None
    // Original line: slider8:shimmer_factor=0<0,1>-Shimmer
    return 0.;
  }
#else
  // Snippet for parameter boilerplate in the authors framework....
  double get_slider_shimmer_factor()
  {
    // Range: min:0.0, max:1.0, default: 0.0, step: None
    return shimmer_factorp;
  }

  float shimmer_factorp = 0.0;

  struct shimmer_factor_tag {};

  void set (shimmer_factor_tag, float v)
  {
    if (v == shimmer_factorp) {
      return;
    }
    shimmer_factorp = v;
    slider();
  }

  static constexpr auto get_parameter (shimmer_factor_tag)
  {
    // Original slider line: slider8:shimmer_factor=0<0,1>-Shimmer
    return float_param ("", 0.0, 1.0, 0.0, 0.01);
  }
#endif
#if 0
  double get_slider_shimmer_tone()
  {
    // TODO: stub, add code for getting "shimmer_tone"
    // Range: min:0.0, max:0.3, default: 0.0, step: None
    // Original line: slider9:shimmer_tone=0<0,0.3>-Shimmer tone
    return 0.;
  }
#else
  // Snippet for parameter boilerplate in the authors framework....
  double get_slider_shimmer_tone()
  {
    // Range: min:0.0, max:0.3, default: 0.0, step: None
    return shimmer_tonep;
  }

  float shimmer_tonep = 0.0;

  struct shimmer_tone_tag {};

  void set (shimmer_tone_tag, float v)
  {
    if (v == shimmer_tonep) {
      return;
    }
    shimmer_tonep = v;
    slider();
  }

  static constexpr auto get_parameter (shimmer_tone_tag)
  {
    // Original slider line: slider9:shimmer_tone=0<0,0.3>-Shimmer tone
    return float_param ("", 0.0, 0.3, 0.0, 0.01);
  }
#endif
#if 0
  double get_slider_wet_db()
  {
    // TODO: stub, add code for getting "wet_db"
    // Range: min:-60.0, max:12.0, default: -12.0, step: None
    // Original line: slider1:wet_db=-12<-60,12>-Wet (dB)
    return 0.;
  }
#else
  // Snippet for parameter boilerplate in the authors framework....
  double get_slider_wet_db()
  {
    // Range: min:-60.0, max:12.0, default: -12.0, step: None
    return wet_dbp;
  }

  float wet_dbp = -12.0;

  struct wet_db_tag {};

  void set (wet_db_tag, float v)
  {
    if (v == wet_dbp) {
      return;
    }
    wet_dbp = v;
    slider();
  }

  static constexpr auto get_parameter (wet_db_tag)
  {
    // Original slider line: slider1:wet_db=-12<-60,12>-Wet (dB)
    return float_param ("dB", -60.0, 12.0, 6., 0.1);
  }
#endif
#if 0
  double get_slider_window_ms()
  {
    // TODO: stub, add code for getting "window_ms"
    // Range: min:10.0, max:500.0, default: 200.0, step: None
    // Original line: slider3:window_ms=200<10,500>-Grain size (ms)
    return 0.;
  }
#else
  // Snippet for parameter boilerplate in the authors framework....
  double get_slider_window_ms()
  {
    // Range: min:10.0, max:500.0, default: 200.0, step: None
    return window_msp;
  }

  float window_msp = 200.0;

  struct window_ms_tag {};

  void set (window_ms_tag, float v)
  {
    if (v == window_msp) {
      return;
    }
    window_msp = v;
    slider();
  }

  static constexpr auto get_parameter (window_ms_tag)
  {
    // Original slider line: slider3:window_ms=200<10,500>-Grain size (ms)
    return float_param ("ms", 10.0, 500.0, 200.0, 0.1, 0.8);
  }
#endif

  using parameters = mp_list<
    // release_decay_seconds_tag,
    compressor_ratio_tag,
    compressor_threshold_db_tag,
    damping_strength_tag,
    decay_seconds_tag,
    detune_cents_per_second_tag,
    detune_shift_bias_tag,
    dry_db_tag,
    high_damping_hz_tag,
    low_damping_hz_tag,
    shimmer_factor_tag,
    shimmer_tone_tag,
    wet_db_tag,
    window_ms_tag>;

  void set_slider_high_damping_hz (double v)
  {
    // TODO: stub, add code for setting "high_damping_hz"
    // Range: min:100.0, max:18000.0, default: 6000.0, step: None
  }

  void set_slider_low_damping_hz (double v)
  {
    // TODO: stub, add code for setting "low_damping_hz"
    // Range: min:20.0, max:500.0, default: 120.0, step: None
  }

  void set_slider_release_mode (double v)
  {
    // TODO: stub, add code for setting "release_mode"
    // Range: min:0.0, max:1.0, default: 0.0, step: 1.0
  }

private:
  //----------------------------------------------------------------------------
  // global/stateful variables for section "init"
  double buffer_length;
#if 0
  double display_spectrum_buffer;
#endif
  double energy_buffer;
  double fft_buffer;
  double freemem;
  double input_buffer;
  double interval_index;
  double max_fft_size;
  double midi_cc64;
  double output_buffer;
  double release_buffer;
  double srate;
  double window_buffer;
  double window_overlap_factor;
  //----------------------------------------------------------------------------
  void init_init_variables()
  {
    buffer_length = 0;
#if 0
    display_spectrum_buffer = 0;
#endif
    energy_buffer         = 0;
    fft_buffer            = 0;
    freemem               = 0;
    input_buffer          = 0;
    interval_index        = 0;
    max_fft_size          = 0;
    midi_cc64             = 0;
    output_buffer         = 0;
    release_buffer        = 0;
    srate                 = 0;
    window_buffer         = 0;
    window_overlap_factor = 0;
  }
  //----------------------------------------------------------------------------
  // global/stateful variables for section "slider"
  double action_release;
  //----------------------------------------------------------------------------
  void init_slider_variables() { action_release = 0; }
  //----------------------------------------------------------------------------
  // global/stateful variables for section "block"
  double buffer_pos;
  double compressor_ratio_inv;
  double compressor_threshold_power;
  double current;
  double current_energy;
  double current_release;
  double damped_extra_interval_factor;
  double decay;
  double decay_interval_factor;
  double detune_factor_down;
  double detune_factor_up;
  double display_power;
  double display_power_compressed;
  double extra_decay;
  double fft_size;
  double high_damping_index_high;
  double high_damping_index_low;
  double low_damping_index_high;
  double low_damping_index_low;
  double midi_msg1;
  double midi_msg2;
  double midi_msg3;
  double octave_up_rate_perinterval;
  double offset;
  double phase1;
  double phase2;
  double prev_fft_size;
  double prev_window_samples;
  double release_current;
  double release_decay_interval_factor;
  double shimmer_double;
  double shimmer_remainder;
  double shimmer_triple;
  double window_samples;
  //----------------------------------------------------------------------------
  void init_block_variables()
  {
    buffer_pos                    = 0;
    compressor_ratio_inv          = 0;
    compressor_threshold_power    = 0;
    current                       = 0;
    current_energy                = 0;
    current_release               = 0;
    damped_extra_interval_factor  = 0;
    decay                         = 0;
    decay_interval_factor         = 0;
    detune_factor_down            = 0;
    detune_factor_up              = 0;
    display_power                 = 0;
    display_power_compressed      = 0;
    extra_decay                   = 0;
    fft_size                      = 0;
    high_damping_index_high       = 0;
    high_damping_index_low        = 0;
    low_damping_index_high        = 0;
    low_damping_index_low         = 0;
    midi_msg1                     = 0;
    midi_msg2                     = 0;
    midi_msg3                     = 0;
    octave_up_rate_perinterval    = 0;
    offset                        = 0;
    phase1                        = 0;
    phase2                        = 0;
    prev_fft_size                 = 0;
    prev_window_samples           = 0;
    release_current               = 0;
    release_decay_interval_factor = 0;
    shimmer_double                = 0;
    shimmer_remainder             = 0;
    shimmer_triple                = 0;
    window_samples                = 0;
  }
  //----------------------------------------------------------------------------
public:
  void reset (plugin_context& pc)
  {
    sample_rate = pc.get_sample_rate();
    init_init_variables();
    init_slider_variables();
    init_block_variables();
    interval_index = 0.;
    if (!jsfx_specialvar_get_srate()) {
      srate = 44100.;
    }
    window_overlap_factor = 4.;
    max_fft_size          = 32768.;
    buffer_length         = max_fft_size * 2.;
    freemem               = 0.;
    (fft_buffer = freemem);
    freemem = fft_buffer + max_fft_size * 2.;
    (energy_buffer = freemem);
    freemem = energy_buffer + max_fft_size;
    (release_buffer = freemem);
    freemem = release_buffer + max_fft_size;
    (input_buffer = freemem);
    freemem = input_buffer + buffer_length;
    (output_buffer = freemem);
    freemem = output_buffer + buffer_length;
    (window_buffer = freemem);
    freemem = window_buffer + max_fft_size;
#if 0
    (display_spectrum_buffer = freemem);
    freemem = display_spectrum_buffer + max_fft_size;
#endif
    heap_reset (freemem);
    jsfx_memset (energy_buffer, 0., max_fft_size);
    jsfx_memset (release_buffer, 0., max_fft_size);
    jsfx_memset (input_buffer, 0., buffer_length);
    jsfx_memset (output_buffer, 0., buffer_length);
#if 0
    freemem = ui_setup (freemem) /*TODO: unknown call */;
    ;
    midi_cc64 = 0.;
    set_slider_release_mode (0.);
    ;
#endif
    slider();
  }

private:
  //----------------------------------------------------------------------------
  void slider()
  {
    if (get_slider_release_mode()) {
      (action_release = 1.);
    }
  }

public:
  //----------------------------------------------------------------------------
  template <class T>
  void process (crange<T*> outs, crange<T const*> ins, uint samples)
  {
    assert (outs.size() >= (n_outputs * (uint) bus_type));
    assert (ins.size() >= (n_inputs * (uint) bus_type));

    double decay_intervals           = 0.;
    double detune_cents_per_interval = 0.;
    double dry_factor                = 0.;
    double high_damping_index        = 0.;
    double i                         = 0.;
    double interval_samples          = 0.;
    double low_damping_index         = 0.;
    double midi_channel              = 0.;
    double midi_type                 = 0.;
    double octave_up_rate_persecond  = 0.;
    double release_decay_intervals   = 0.;
    double wet_factor                = 0.;

    window_samples = std::min (
      32760.,
      std::ceil (jsfx_specialvar_get_srate() * 0.001 * get_slider_window_ms()));
    fft_size = std::pow (
      2., std::ceil (std::log (window_samples + 1.) / std::log (2.)));
    interval_samples = std::ceil (window_samples / window_overlap_factor);
    decay_intervals  = jsfx_specialvar_get_srate() * get_slider_decay_seconds()
      / interval_samples;
    decay_interval_factor   = std::exp (-1. / decay_intervals);
    release_decay_intervals = jsfx_specialvar_get_srate()
      * std::min (get_slider_release_decay_seconds(),
                  get_slider_decay_seconds())
      / interval_samples;
    release_decay_interval_factor = std::exp (-1. / release_decay_intervals);
    damped_extra_interval_factor
      = std::pow (decay_interval_factor, get_slider_damping_strength() - 1.);
    detune_cents_per_interval = get_slider_detune_cents_per_second()
      / jsfx_specialvar_get_srate() * interval_samples;
    detune_factor_up = (std::pow (2., detune_cents_per_interval / 1200.) - 1.)
      * 0.5 * (1. + get_slider_detune_shift_bias());
    detune_factor_down = (std::pow (2., detune_cents_per_interval / 1200.) - 1.)
      * 0.5 * (1. - get_slider_detune_shift_bias());
    wet_factor = std::pow (10., get_slider_wet_db() / 20.);
    dry_factor = std::pow (10., get_slider_dry_db() / 20.);
    if (
      eel2_ne (prev_fft_size, fft_size)
      || eel2_ne (prev_window_samples, window_samples)) {
      jsfx_memset (energy_buffer, 0., max_fft_size);
      prev_fft_size       = fft_size;
      prev_window_samples = window_samples;
      i                   = 0.;
      for (int $$i = 0, $$end = std::max (0, (int) (window_samples));
           $$i < $$end;
           ++$$i) {
        heap (window_buffer + i) = init$window ((i + 0.5) / window_samples);
        i += 1.;
      }
    }
    octave_up_rate_persecond = std::pow (8., get_slider_shimmer_factor()) - 1.;
    octave_up_rate_perinterval = std::min (
      0.75,
      octave_up_rate_persecond / jsfx_specialvar_get_srate()
        * interval_samples);
    shimmer_double
      = octave_up_rate_perinterval * (1. - get_slider_shimmer_tone() / 1.58);
    shimmer_triple
      = octave_up_rate_perinterval / 1.58 * get_slider_shimmer_tone();
    shimmer_remainder = (1. - shimmer_double - shimmer_triple);
    set_slider_low_damping_hz (std::max (
      20.,
      std::min (get_slider_low_damping_hz(), get_slider_high_damping_hz())));
    set_slider_high_damping_hz (std::min (
      18000.,
      std::max (get_slider_low_damping_hz(), get_slider_high_damping_hz())));
    high_damping_index
      = get_slider_high_damping_hz() / jsfx_specialvar_get_srate() * fft_size;
    high_damping_index_low  = high_damping_index * 0.75;
    high_damping_index_high = high_damping_index * 1.5;
    low_damping_index
      = get_slider_low_damping_hz() / jsfx_specialvar_get_srate() * fft_size;
    low_damping_index_low  = low_damping_index * 0.5;
    low_damping_index_high = low_damping_index * 1.5;
    compressor_threshold_power
      = std::pow (10., get_slider_compressor_threshold_db() / 10.);
    compressor_ratio_inv = 1. / get_slider_compressor_ratio();

#if 0 // MIDI not implemented
    while (jsfx_midirecv (offset, midi_msg1, midi_msg2, midi_msg3)) {
      jsfx_midisend (offset, midi_msg1, midi_msg2, midi_msg3);
      midi_type    = eel2_rshift (midi_msg1, 4.);
      midi_channel = eel2_and (midi_msg1, ((double) 0x0f));
      if (eel2_eq (midi_type, 11.)) {
        if (eel2_eq (midi_msg2, 121.)) {
          (midi_cc64 = 0.);
        }
        else {
          if (eel2_eq (midi_msg2, 64.)) {
            midi_cc64 = midi_msg3;
            if (
              get_slider_release_cc64() && midi_cc64 < 64.
              && get_slider_release_decay_seconds()
                < get_slider_decay_seconds()) {
              (action_release = 1.);
            }
          }
        }
      }
    }
    if (
      get_slider_release_cc64() && midi_cc64 < 64.
      && get_slider_release_decay_seconds() < get_slider_decay_seconds()) {
      (action_release = 1.);
    };
#endif
    for (int $$i = 0, $$end = std::max (0, (int) samples); $$i < $$end; ++$$i) {
      auto& spl0 = outs[0][$$i];
      auto& spl1 = outs[1][$$i];
      spl0       = ins[0][$$i];
      spl1       = ins[1][$$i];

      heap (input_buffer + buffer_pos)        = spl0;
      heap (input_buffer + (buffer_pos + 1.)) = spl1;
      interval_index += 1.;
      if (interval_index >= interval_samples) {
        interval_index = 0.;
        block$reverb_block();
      }
      spl0 = spl0 * dry_factor + heap (output_buffer + buffer_pos) * wet_factor;
      spl1 = spl1 * dry_factor
        + heap (output_buffer + (buffer_pos + 1.)) * wet_factor;
      heap (output_buffer + buffer_pos)        = 0.;
      heap (output_buffer + (buffer_pos + 1.)) = 0.;
      buffer_pos += 2.;
      if (buffer_pos >= buffer_length) {
        buffer_pos = 0.;
      };
    }
  }
  // functions for section "init"
  //----------------------------------------------------------------------------
  double init$window (double r)
  {
    double c = 0.;
    double s = 0.;
    s        = std::sin (r * 3.141592653589793);
    c        = std::cos (r * 3.141592653589793);
    return s * s / std::sqrt (s * s * s * s + c * c * c * c);
  }
  // functions for section "block"
  //----------------------------------------------------------------------------
  double block$reverb_block()
  {
    double w           = 0.;
    double real        = 0.;
    double real2       = 0.;
    double mag         = 0.;
    double mult_factor = 0.;
    double i           = 0.;
    double r           = 0.;
    double imag        = 0.;
    double mag2sum     = 0.;
    double imag2       = 0.;
    double i2          = 0.;
    // double r2          = 0.;
    double mag2 = 0.;

    if (action_release || get_slider_release_mode()) {
      action_release = 0.;
      if (get_slider_release_decay_seconds() < get_slider_decay_seconds()) {
        i = 0.;
        for (int $$i = 0, $$end = std::max (0, (int) (fft_size / 2.));
             $$i < $$end;
             ++$$i) {
          heap (release_buffer + i) += heap (energy_buffer + i);
          heap (energy_buffer + i) = 0.;
          i += 1.;
        }
      }
    }

    if (get_slider_detune_cents_per_second()) {
      i               = 1.;
      current_energy  = heap (energy_buffer + i);
      current_release = heap (release_buffer + i);
      for (int $$i = 0, $$end = std::max (0, (int) (fft_size / 2. - 1.));
           $$i < $$end;
           ++$$i) {
        r                        = 1. / (detune_factor_up * i + 1.);
        heap (energy_buffer + i) = current_energy * r;
        current_energy
          = heap (energy_buffer + (i + 1.)) + current_energy * (1. - r);
        heap (release_buffer + i) = current_release * r;
        current_release
          = heap (release_buffer + (i + 1.)) + current_release * (1. - r);
        i += 1.;
      }
      current_energy  = heap (energy_buffer + i);
      current_release = heap (release_buffer + i);
      for (int $$i = 0, $$end = std::max (0, (int) (fft_size / 2. - 1.));
           $$i < $$end;
           ++$$i) {
        r                        = 1. / (detune_factor_down * i + 1.);
        heap (energy_buffer + i) = current_energy * r;
        current_energy
          = heap (energy_buffer + (i - 1.)) + current_energy * (1. - r);
        heap (release_buffer + i) = current_release * r;
        current_release
          = heap (release_buffer + (i - 1.)) + current_release * (1. - r);
        i -= 1.;
      }
      heap (energy_buffer + i)               = current_energy;
      heap (release_buffer + i)              = current_release;
      heap (energy_buffer + (fft_size / 2.)) = 0.;
      heap (energy_buffer) = heap (energy_buffer + (fft_size / 2.));
      heap (release_buffer + (fft_size / 2.)) = 0.;
      heap (release_buffer) = heap (release_buffer + (fft_size / 2.));
    }
    i       = 0.;
    mag2sum = 0.;
    for (int $$i = 0, $$end = std::max (0, (int) (window_samples)); $$i < $$end;
         ++$$i) {
      w  = heap (window_buffer + (eel2_rshift (i, 1.)));
      i2 = buffer_pos - window_samples * 2. + i;
      if (i2 < 0.) {
        i2 += buffer_length;
      }
      real                         = heap (input_buffer + i2) * w;
      imag                         = heap (input_buffer + (i2 + 1.)) * w;
      heap (fft_buffer + i)        = real;
      heap (fft_buffer + (i + 1.)) = real;
      mag2sum += real * real + imag * imag;
      i += 2.;
    }
    for (int $$i = 0, $$end = std::max (0, (int) (fft_size - window_samples));
         $$i < $$end;
         ++$$i) {
      heap (fft_buffer + i)        = 0.;
      heap (fft_buffer + (i + 1.)) = 0.;
      i += 2.;
    }
    jsfx_fft (fft_buffer, fft_size);
    jsfx_fft_permute (fft_buffer, fft_size);
    i           = 1.;
    mult_factor = 0.5 / window_overlap_factor
      * std::pow (window_samples / (fft_size * fft_size), 2.);
    mult_factor *= window_samples / (0.1 * jsfx_specialvar_get_srate());
    mag2          = mag2sum * std::sqrt (2.) / window_samples;
    display_power = mag2;
    if (mag2 > compressor_threshold_power) {
      mult_factor *= std::pow (
        mag2 / compressor_threshold_power, compressor_ratio_inv - 1.);
      display_power_compressed = display_power
        * std::pow (mag2 / compressor_threshold_power,
                    compressor_ratio_inv - 1.);
    }
    else {
      (display_power_compressed = display_power);
    }
    heap (fft_buffer + (fft_size + 1.)) = 0.;
    heap (fft_buffer + fft_size)        = heap (fft_buffer + (fft_size + 1.));
    heap (fft_buffer + 1.)              = heap (fft_buffer + fft_size);
    heap (fft_buffer)                   = heap (fft_buffer + 1.);
    for (int $$i = 0, $$end = std::max (0, (int) (fft_size / 2. - 1.));
         $$i < $$end;
         ++$$i) {
      i2    = fft_size - i;
      real  = heap (fft_buffer + (2. * i));
      imag  = heap (fft_buffer + (2. * i + 1.));
      real2 = heap (fft_buffer + (2. * i2));
      imag2 = heap (fft_buffer + (2. * i2 + 1.));
      mag2  = (real * real + imag * imag + real2 * real2 + imag2 * imag2)
        * mult_factor;
#if 0
      heap (display_spectrum_buffer + i) = mag2;
#endif
      decay       = decay_interval_factor;
      extra_decay = [&] {
        if (i <= high_damping_index_low) {
          return 1.;
        }
        else {
          return [&] {
            if (i >= high_damping_index_high) {
              return damped_extra_interval_factor;
            }
            else {
              r = (i - high_damping_index_low)
                / (high_damping_index_high - high_damping_index_low);
              return 1. + (damped_extra_interval_factor - 1.) * r * r;
            }
          }();
        }
      }();
      if (i < low_damping_index_high) {
        if (i > low_damping_index_low) {
          r = (i - low_damping_index_high)
            / (low_damping_index_low - low_damping_index_high);
          extra_decay *= 1. + (damped_extra_interval_factor - 1.) * r * r;
        }
        else {
          (extra_decay *= damped_extra_interval_factor);
        }
      }
      heap (energy_buffer + i)
        = (heap (energy_buffer + i) * decay + mag2) * extra_decay;
      heap (release_buffer + i) *= release_decay_interval_factor * extra_decay;
      i += 1.;
    }
    if (octave_up_rate_perinterval) {
      i = fft_size / 2. - 1.;
      for (int $$i = 0, $$end = std::max (0, (int) (fft_size / 2. - 2.));
           $$i < $$end;
           ++$$i) {
        current         = heap (energy_buffer + i);
        release_current = heap (release_buffer + i);
        if (get_slider_shimmer_tone()) {
          if (2. * i + 1. < fft_size / 2.) {
            heap (energy_buffer + (2. * i - 1.))
              += 0.25 * shimmer_double * current;
            heap (energy_buffer + (2. * i)) += 0.5 * shimmer_double * current;
            heap (energy_buffer + (2. * i + 1.))
              += 0.25 * shimmer_double * current;
            heap (release_buffer + (2. * i - 1.))
              += 0.25 * shimmer_double * release_current;
            heap (release_buffer + (2. * i))
              += 0.5 * shimmer_double * release_current;
            heap (release_buffer + (2. * i + 1.))
              += 0.25 * shimmer_double * release_current;
          }
          if (3. * i + 1. < fft_size / 2.) {
            heap (energy_buffer + (3. * i - 2.))
              += 0.11 * shimmer_triple * current;
            heap (energy_buffer + (3. * i - 1.))
              += 0.22 * shimmer_triple * current;
            heap (energy_buffer + (3. * i)) += 0.34 * shimmer_triple * current;
            heap (energy_buffer + (3. * i + 1.))
              += 0.22 * shimmer_triple * current;
            heap (energy_buffer + (3. * i + 2.))
              += 0.21 * shimmer_triple * current;
            heap (release_buffer + (3. * i - 2.))
              += 0.11 * shimmer_triple * release_current;
            heap (release_buffer + (3. * i - 1.))
              += 0.22 * shimmer_triple * release_current;
            heap (release_buffer + (3. * i))
              += 0.34 * shimmer_triple * release_current;
            heap (release_buffer + (3. * i + 1.))
              += 0.22 * shimmer_triple * release_current;
            heap (release_buffer + (3. * i + 2.))
              += 0.21 * shimmer_triple * release_current;
          }
        }
        else {
          if (2. * i + 1. < fft_size / 2.) {
            heap (energy_buffer + (2. * i - 1.))
              += 0.25 * shimmer_double * current;
            heap (energy_buffer + (2. * i)) += 0.5 * shimmer_double * current;
            heap (energy_buffer + (2. * i + 1.))
              += 0.25 * shimmer_double * current;
            heap (release_buffer + (2. * i - 1.))
              += 0.25 * shimmer_double * release_current;
            heap (release_buffer + (2. * i))
              += 0.5 * shimmer_double * release_current;
            heap (release_buffer + (2. * i + 1.))
              += 0.25 * shimmer_double * release_current;
          }
        }
        heap (energy_buffer + i)  = shimmer_remainder * current;
        heap (release_buffer + i) = shimmer_remainder * release_current;
        i -= 1.;
      }
    }
    i = 1.;
    for (int $$i = 0, $$end = std::max (0, (int) (fft_size / 2. - 1.));
         $$i < $$end;
         ++$$i) {
      i2   = fft_size - i;
      mag2 = heap (energy_buffer + i) + heap (release_buffer + i);
      mag  = std::sqrt (mag2);
#if 0
      phase1 = jsfx_rand() * 2. * 3.141592653589793;
      phase2 = jsfx_rand() * 2. * 3.141592653589793;
#else
      phase1 = jsfx_rand (2. * 3.141592653589793);
      phase2 = jsfx_rand (2. * 3.141592653589793);
#endif
      heap (fft_buffer + (2. * i))       = std::cos (phase1) * mag;
      heap (fft_buffer + (2. * i + 1.))  = std::sin (phase1) * mag;
      heap (fft_buffer + (2. * i2))      = std::cos (phase2) * mag;
      heap (fft_buffer + (2. * i2 + 1.)) = std::sin (phase2) * mag;
      i += 1.;
    }
    jsfx_fft_ipermute (fft_buffer, fft_size);
    jsfx_ifft (fft_buffer, fft_size);
    i = 0.;
    return [&] {
      double $$loop_ret_0 = {};
      for (int $$i = 0, $$end = std::max (0, (int) (window_samples));
           $$i < $$end;
           ++$$i) {
        w  = heap (window_buffer + (eel2_rshift (i, 1.)));
        i2 = buffer_pos + i;
        if (i2 >= buffer_length) {
          i2 -= buffer_length;
        }
        heap (output_buffer + i2) += heap (fft_buffer + i) * w;
        heap (output_buffer + (i2 + 1.)) += heap (fft_buffer + (i + 1.)) * w;
        i += 2.;
        $$loop_ret_0 = i;
      }
      return $$loop_ret_0;
    }();
  }
}; /* atlantis_reverb */

}} // namespace artv::geraint_luff

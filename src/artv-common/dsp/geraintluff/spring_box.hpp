#pragma once
// Generated by jsfx2cpp.py. To be manually corrected.
// includes for environment function calls

// REMINDER: to generate this I had to comment the UI imports.
// From commit 7ecb9004b77fcaa43b4f98bcd158cc2c968f5814

#include <algorithm>
#include <cmath>
#include <cstdlib>
#include <cstring>
#include <vector>

#include <juce_audio_processors/juce_audio_processors.h>

#include "artv-common/dsp/jsfx_engine/jsfx_engine.hpp"
#include "artv-common/dsp/own/plugin_context.hpp"
#include "artv-common/dsp/types.hpp"
#include "artv-common/juce/parameter_definitions.hpp"
#include "artv-common/juce/parameter_types.hpp"
#include "artv-common/misc/bits.hpp"
#include "artv-common/misc/mp11.hpp"
#include "artv-common/misc/short_ints.hpp"
#include "artv-common/misc/util.hpp"

namespace artv { namespace geraint_luff {

class spring_box {
public:
  //----------------------------------------------------------------------------
  static constexpr dsp_types dsp_type = dsp_types::delay;
  //----------------------------------------------------------------------------
private:
  // definitions for environment function calls
  static double eel2_eq (double lhs, double rhs)
  {
    return (double) (std::abs (lhs - rhs) < 0.00001);
  }
  static bool eel2_ne (double lhs, double rhs) { return !eel2_eq (lhs, rhs); }

  using heap_flt = float;
  std::vector<heap_flt> heapmem;
  inline heap_flt&      heap (std::size_t value) { return heapmem[value]; }
  void                  heap_reset (std::size_t s)
  {
    heapmem.resize (s);
    std::memset (heapmem.data(), 0, heapmem.size() * sizeof heapmem[0]);
  }

  static double jsfx_rand (double maxv = 1.)
  {
    return jsfx_engine::rand (maxv);
  }

  //----------------------------------------------------------------------------
  // stubs for JSFX special variables

  double jsfx_specialvar_get_srate() { return plugcontext->get_sample_rate(); }

  double jsfx_specialvar_get_tempo()
  {
    return plugcontext->get_play_state().bpm;
  }
  //----------------------------------------------------------------------------
public:
#if 0
  void set_slider1_slider (float v)
  {
    // Original slider line: slider1:50<1,1000,1>-density (ms)
    // Range: min:1.0, max:1000.0, default: 50.0, step: 1.0
    if (v == slider1) {
      return;
    }
    slider1 = v;
    slider();
  }
#else
  // Snippet for parameter boilerplate in the authors framework....
  struct density_tag {};

  float density_unsync = 50.;
  float density_sync   = 0.;
  void  set (density_tag, float v)
  {
    // Original slider line: slider1:50<1,1000,1>-density (ms)
    // Range: min:1.0, max:1000.0, default: 50.0, step: 1.0
    if (v == density_unsync) {
      return;
    }
    density_unsync = v;
    slider1        = std::min (density_unsync + density_sync, 1000.f);
    slider();
  }

  static constexpr auto get_parameter (density_tag)
  {
    // Original slider line: slider1:50<1,1000,1>-density (ms)
    return float_param ("ms", 1.0, 1000.0, 50.0, .1, 0.8);
  }

#if 1 // addon

  struct density_sync_tag {};

  void set (density_sync_tag, float v)
  {
    // Original slider line: slider1:50<1,1000,1>-density (ms)
    // Range: min:1.0, max:1000.0, default: 50.0, step: 1.0

    // syncing in 1/16 steps
    float sync_ms = (60. / (jsfx_specialvar_get_tempo() * 16.)) * 1000.;
    v             = (std::floor (v / sync_ms) * sync_ms)
      - -get_parameter (density_tag {}).min;

    if (v == density_sync) {
      return;
    }
    density_sync = v;
    slider1      = std::min (density_unsync + density_sync, 1000.f);
    slider();
  }

  static constexpr auto get_parameter (density_sync_tag)
  {
    // Original slider line: slider1:50<1,1000,1>-density (ms)
    return float_param ("ms", 0.0, 1000.0, 0.0, .1, 0.7);
  }

#endif

#endif
#if 0
  void set_slider2_slider (float v)
  {
    // Original slider line: slider2:60<0,99,1>-feedback
    // Range: min:0.0, max:99.0, default: 60.0, step: 1.0
    if (v == slider2) {
      return;
    }
    slider2 = v;
    slider();
  }
#else
  // Snippet for parameter boilerplate in the authors framework....
  struct feedback_tag {};

  void set (feedback_tag, float v)
  {
    // Original slider line: slider2:60<0,99,1>-feedback
    // Range: min:0.0, max:99.0, default: 60.0, step: 1.0
    if (v == slider2) {
      return;
    }
    slider2 = v;
    slider();
  }

  static constexpr auto get_parameter (feedback_tag)
  {
    // Original slider line: slider2:60<0,99,1>-feedback
    return float_param ("%", 0.0, 99.0, 60.0, 1.0);
  }

#endif
#if 0
  void set_slider3_slider (float v)
  {
    // Original slider line: slider3:80<0,95,1>-late-bias (%)
    // Range: min:0.0, max:95.0, default: 80.0, step: 1.0
    if (v == slider3) {
      return;
    }
    slider3 = v;
    slider();
  }
#else
  // Snippet for parameter boilerplate in the authors framework....
  struct late_bias_tag {};

  void set (late_bias_tag, float v)
  {
    // Original slider line: slider3:80<0,95,1>-late-bias (%)
    // Range: min:0.0, max:95.0, default: 80.0, step: 1.0
    if (v == slider3) {
      return;
    }
    slider3 = v;
    slider();
  }

  static constexpr auto get_parameter (late_bias_tag)
  {
    // Original slider line: slider3:80<0,95,1>-late-bias (%)
    return float_param ("%", 0.0, 95.0, 80.0, 1.0);
  }

#endif
#if 0
  void set_slider4_slider (float v)
  {
    // Original slider line: slider4:25<0,100,1>-wet (%)
    // Range: min:0.0, max:100.0, default: 25.0, step: 1.0
    if (v == slider4) {
      return;
    }
    slider4 = v;
    slider();
  }
#else
  // Snippet for parameter boilerplate in the authors framework....
  struct wet_tag {};

  void set (wet_tag, float v)
  {
    // Original slider line: slider4:25<0,100,1>-wet (%)
    // Range: min:0.0, max:100.0, default: 25.0, step: 1.0
    if (v == slider4) {
      return;
    }
    slider4 = v;
    slider();
  }

  static constexpr auto get_parameter (wet_tag)
  {
    // Original slider line: slider4:25<0,100,1>-wet (%)
    return float_param ("", 0.0, 100.0, 100.0, 1.0);
  }

#endif
#if 0
  void set_slider5_slider (float v)
  {
    // Original slider line: slider5:100<0,100,1>-dry (%)
    // Range: min:0.0, max:100.0, default: 100.0, step: 1.0
    if (v == slider5) {
      return;
    }
    slider5 = v;
    slider();
  }
#else
  // Snippet for parameter boilerplate in the authors framework....
  struct dry_tag {};

  void set (dry_tag, float v)
  {
    // Original slider line: slider5:100<0,100,1>-dry (%)
    // Range: min:0.0, max:100.0, default: 100.0, step: 1.0
    if (v == slider5) {
      return;
    }
    slider5 = v;
    slider();
  }

  static constexpr auto get_parameter (dry_tag)
  {
    // Original slider line: slider5:100<0,100,1>-dry (%)
    return float_param ("%", 0.0, 100.0, 0.0, 1.0);
  }

#endif
#if 0
  void set_slider6_slider (float v)
  {
    // Original slider line: slider6:0<0,1,1{even,long}>-room shape
    // Range: min:0.0, max:1.0, default: 0.0, step: 1.0
    if (v == slider6) {
      return;
    }
    slider6 = v;
    slider();
  }
#else
  // Snippet for parameter boilerplate in the authors framework....
  struct shape_tag {};

  void set (shape_tag, float v)
  {
    // Original slider line: slider6:0<0,1,1{even,long}>-room shape
    // Range: min:0.0, max:1.0, default: 0.0, step: 1.0
    if (v == slider6) {
      return;
    }
    slider6 = v;
    slider();
  }

  static constexpr auto get_parameter (shape_tag)
  {
    // Original slider line: slider6:0<0,1,1{even,long}>-room shape
    return choice_param (0, make_cstr_array ("even", "long"));
  }

#endif
#if 0
  void set_slider7_slider (float v)
  {
    // Original slider line: slider7:8000<100,20000,1>-filter (lowpass Hz)
    // Range: min:100.0, max:20000.0, default: 8000.0, step: 1.0
    if (v == slider7) {
      return;
    }
    slider7 = v;
    slider();
  }
#else
  // Snippet for parameter boilerplate in the authors framework....
  struct filter_tag {};

  void set (filter_tag, float v)
  {
    // Original slider line: slider7:8000<100,20000,1>-filter (lowpass Hz)
    // Range: min:100.0, max:20000.0, default: 8000.0, step: 1.0
    v = midi_note_to_hz (v);
    if (v == slider7) {
      return;
    }
    slider7 = v;
    slider();
  }

  static constexpr auto get_parameter (filter_tag)
  {
    // Original slider line: slider7:8000<100,20000,1>-filter (lowpass Hz)
    return frequency_parameter (100.0, 20000.0, 8000.0);
  }

#endif
#if 0
  void set_slider8_slider (float v)
  {
    // Original slider line: slider8:10<0,100,1>-detuning (cents)
    // Range: min:0.0, max:100.0, default: 10.0, step: 1.0
    if (v == slider8) {
      return;
    }
    slider8 = v;
    slider();
  }
#else
  // Snippet for parameter boilerplate in the authors framework....
  struct detune_tag {};

  void set (detune_tag, float v)
  {
    // Original slider line: slider8:10<0,100,1>-detuning (cents)
    // Range: min:0.0, max:100.0, default: 10.0, step: 1.0
    if (v == slider8) {
      return;
    }
    slider8 = v;
    slider();
  }

  static constexpr auto get_parameter (detune_tag)
  {
    // Original slider line: slider8:10<0,100,1>-detuning (cents)
    return float_param ("Cents", 0.0, 100.0, 10.0, 1.0);
  }

#endif
#if 0
  void set_slider9_slider (float v)
  {
    // Original slider line: slider9:2.5<0.1,10,0.1>-chorus speed (Hz)
    // Range: min:0.1, max:10.0, default: 2.5, step: 0.1
    if (v == slider9) {
      return;
    }
    slider9 = v;
    slider();
  }
#else
  // Snippet for parameter boilerplate in the authors framework....
  struct speed_tag {};

  void set (speed_tag, float v)
  {
    // Original slider line: slider9:2.5<0.1,10,0.1>-chorus speed (Hz)
    // Range: min:0.1, max:10.0, default: 2.5, step: 0.1
    if (v == slider9) {
      return;
    }
    slider9 = v;
    slider();
  }

  static constexpr auto get_parameter (speed_tag)
  {
    // Original slider line: slider9:2.5<0.1,10,0.1>-chorus speed (Hz)
    return float_param ("Hz", 0.1, 10.0, 2.5, 0.01);
  }

#endif
#if 0
  void set_chorus_alignment_slider (float v)
  {
    // Original slider line:
    // slider10:chorus_alignment=0<0,1,1{independent,linked}>-chorus phase
    // Range: min:0.0, max:1.0, default: 0.0, step: 1.0
    if (v == chorus_alignment) {
      return;
    }
    chorus_alignment = v;
    slider();
  }
#else
  // Snippet for parameter boilerplate in the authors framework....
  struct chorus_alignment_tag {};

  void set (chorus_alignment_tag, float v)
  {
    // Original slider line:
    // slider10:chorus_alignment=0<0,1,1{independent,linked}>-chorus phase
    // Range: min:0.0, max:1.0, default: 0.0, step: 1.0
    if (v == chorus_alignment) {
      return;
    }
    chorus_alignment = v;
    slider();
  }

  static constexpr auto get_parameter (chorus_alignment_tag)
  {
    // Original slider line:
    // slider10:chorus_alignment=0<0,1,1{independent,linked}>-chorus phase
    return choice_param (0, make_cstr_array ("independent", "linked"));
  }

#endif
  using parameters = mp_list<
    density_tag,
    density_sync_tag,
    feedback_tag,
    late_bias_tag,
    wet_tag,
    dry_tag,
    shape_tag,
    filter_tag,
    detune_tag,
    speed_tag,
    chorus_alignment_tag>;

private:
  //----------------------------------------------------------------------------
  // global/stateful variables for section "init"
  double chorus_alignment;
  double chorusphase1;
  double chorusphase2;
  double chorusphase3;
  double chorusphase4;
  double delay1a_allpass_x1;
  double delay1a_allpass_x2;
  double delay1a_allpass_y1;
  double delay1a_allpass_y2;
  double delay1a_buffer;
  double delay1a_buffer_length;
  double delay1a_config_interpolation_samples;
  double delay1a_interp_buffer;
  double delay1a_interp_offset;
  double delay1a_interp_samples;
  double delay1a_interp_scale;
  double delay1b_allpass_x1;
  double delay1b_allpass_x2;
  double delay1b_allpass_y1;
  double delay1b_allpass_y2;
  double delay1b_buffer;
  double delay1b_buffer_length;
  double delay1b_config_interpolation_samples;
  double delay1b_interp_buffer;
  double delay1b_interp_offset;
  double delay1b_interp_samples;
  double delay1b_interp_scale;
  double delay2a_allpass_x1;
  double delay2a_allpass_x2;
  double delay2a_allpass_y1;
  double delay2a_allpass_y2;
  double delay2a_buffer;
  double delay2a_buffer_length;
  double delay2a_config_interpolation_samples;
  double delay2a_interp_buffer;
  double delay2a_interp_offset;
  double delay2a_interp_samples;
  double delay2a_interp_scale;
  double delay2b_allpass_x1;
  double delay2b_allpass_x2;
  double delay2b_allpass_y1;
  double delay2b_allpass_y2;
  double delay2b_buffer;
  double delay2b_buffer_length;
  double delay2b_config_interpolation_samples;
  double delay2b_interp_buffer;
  double delay2b_interp_offset;
  double delay2b_interp_samples;
  double delay2b_interp_scale;
  double delay3a_allpass_x1;
  double delay3a_allpass_x2;
  double delay3a_allpass_y1;
  double delay3a_allpass_y2;
  double delay3a_buffer;
  double delay3a_buffer_length;
  double delay3a_config_interpolation_samples;
  double delay3a_interp_buffer;
  double delay3a_interp_offset;
  double delay3a_interp_samples;
  double delay3a_interp_scale;
  double delay3b_allpass_x1;
  double delay3b_allpass_x2;
  double delay3b_allpass_y1;
  double delay3b_allpass_y2;
  double delay3b_buffer;
  double delay3b_buffer_length;
  double delay3b_config_interpolation_samples;
  double delay3b_interp_buffer;
  double delay3b_interp_offset;
  double delay3b_interp_samples;
  double delay3b_interp_scale;
  double delay4a_allpass_x1;
  double delay4a_allpass_x2;
  double delay4a_allpass_y1;
  double delay4a_allpass_y2;
  double delay4a_buffer;
  double delay4a_buffer_length;
  double delay4a_config_interpolation_samples;
  double delay4a_interp_buffer;
  double delay4a_interp_offset;
  double delay4a_interp_samples;
  double delay4a_interp_scale;
  double delay4b_allpass_x1;
  double delay4b_allpass_x2;
  double delay4b_allpass_y1;
  double delay4b_allpass_y2;
  double delay4b_buffer;
  double delay4b_buffer_length;
  double delay4b_config_interpolation_samples;
  double delay4b_interp_buffer;
  double delay4b_interp_offset;
  double delay4b_interp_samples;
  double delay4b_interp_scale;
  double delayfactor1;
  double delayfactor2;
  double delayfactor3;
  double delayfactor4;
  double delaysamples1;
  double delaysamples1i;
  double delaysamples2;
  double delaysamples2i;
  double delaysamples3;
  double delaysamples3i;
  double delaysamples4;
  double delaysamples4i;
  double dry;
  double dry_step;
  double dry_value;
  double feedbackratio;
  double filterlx1;
  double filterlx2;
  double filterly1;
  double filterly2;
  double filterrx1;
  double filterrx2;
  double filterry1;
  double filterry2;
  double freemem;
  double gfx_ext_retina;
  double max_delay_samples;
  double maxdetunefactor;
  double mindetunefreq;
  double slider1;
  double slider2;
  double slider3;
  double slider4;
  double slider5;
  double slider6;
  double slider7;
  double slider8;
  double slider9;
  double wet;
  double wet_step;
  double wet_value;
  double writepos;
  //----------------------------------------------------------------------------
  void init_init_variables()
  {
    chorus_alignment                     = 0;
    chorusphase1                         = 0;
    chorusphase2                         = 0;
    chorusphase3                         = 0;
    chorusphase4                         = 0;
    delay1a_allpass_x1                   = 0;
    delay1a_allpass_x2                   = 0;
    delay1a_allpass_y1                   = 0;
    delay1a_allpass_y2                   = 0;
    delay1a_buffer                       = 0;
    delay1a_buffer_length                = 0;
    delay1a_config_interpolation_samples = 0;
    delay1a_interp_buffer                = 0;
    delay1a_interp_offset                = 0;
    delay1a_interp_samples               = 0;
    delay1a_interp_scale                 = 0;
    delay1b_allpass_x1                   = 0;
    delay1b_allpass_x2                   = 0;
    delay1b_allpass_y1                   = 0;
    delay1b_allpass_y2                   = 0;
    delay1b_buffer                       = 0;
    delay1b_buffer_length                = 0;
    delay1b_config_interpolation_samples = 0;
    delay1b_interp_buffer                = 0;
    delay1b_interp_offset                = 0;
    delay1b_interp_samples               = 0;
    delay1b_interp_scale                 = 0;
    delay2a_allpass_x1                   = 0;
    delay2a_allpass_x2                   = 0;
    delay2a_allpass_y1                   = 0;
    delay2a_allpass_y2                   = 0;
    delay2a_buffer                       = 0;
    delay2a_buffer_length                = 0;
    delay2a_config_interpolation_samples = 0;
    delay2a_interp_buffer                = 0;
    delay2a_interp_offset                = 0;
    delay2a_interp_samples               = 0;
    delay2a_interp_scale                 = 0;
    delay2b_allpass_x1                   = 0;
    delay2b_allpass_x2                   = 0;
    delay2b_allpass_y1                   = 0;
    delay2b_allpass_y2                   = 0;
    delay2b_buffer                       = 0;
    delay2b_buffer_length                = 0;
    delay2b_config_interpolation_samples = 0;
    delay2b_interp_buffer                = 0;
    delay2b_interp_offset                = 0;
    delay2b_interp_samples               = 0;
    delay2b_interp_scale                 = 0;
    delay3a_allpass_x1                   = 0;
    delay3a_allpass_x2                   = 0;
    delay3a_allpass_y1                   = 0;
    delay3a_allpass_y2                   = 0;
    delay3a_buffer                       = 0;
    delay3a_buffer_length                = 0;
    delay3a_config_interpolation_samples = 0;
    delay3a_interp_buffer                = 0;
    delay3a_interp_offset                = 0;
    delay3a_interp_samples               = 0;
    delay3a_interp_scale                 = 0;
    delay3b_allpass_x1                   = 0;
    delay3b_allpass_x2                   = 0;
    delay3b_allpass_y1                   = 0;
    delay3b_allpass_y2                   = 0;
    delay3b_buffer                       = 0;
    delay3b_buffer_length                = 0;
    delay3b_config_interpolation_samples = 0;
    delay3b_interp_buffer                = 0;
    delay3b_interp_offset                = 0;
    delay3b_interp_samples               = 0;
    delay3b_interp_scale                 = 0;
    delay4a_allpass_x1                   = 0;
    delay4a_allpass_x2                   = 0;
    delay4a_allpass_y1                   = 0;
    delay4a_allpass_y2                   = 0;
    delay4a_buffer                       = 0;
    delay4a_buffer_length                = 0;
    delay4a_config_interpolation_samples = 0;
    delay4a_interp_buffer                = 0;
    delay4a_interp_offset                = 0;
    delay4a_interp_samples               = 0;
    delay4a_interp_scale                 = 0;
    delay4b_allpass_x1                   = 0;
    delay4b_allpass_x2                   = 0;
    delay4b_allpass_y1                   = 0;
    delay4b_allpass_y2                   = 0;
    delay4b_buffer                       = 0;
    delay4b_buffer_length                = 0;
    delay4b_config_interpolation_samples = 0;
    delay4b_interp_buffer                = 0;
    delay4b_interp_offset                = 0;
    delay4b_interp_samples               = 0;
    delay4b_interp_scale                 = 0;
    delayfactor1                         = 0;
    delayfactor2                         = 0;
    delayfactor3                         = 0;
    delayfactor4                         = 0;
    delaysamples1                        = 0;
    delaysamples1i                       = 0;
    delaysamples2                        = 0;
    delaysamples2i                       = 0;
    delaysamples3                        = 0;
    delaysamples3i                       = 0;
    delaysamples4                        = 0;
    delaysamples4i                       = 0;
    dry                                  = 0;
    dry_step                             = 0;
    dry_value                            = 0;
    feedbackratio                        = 0;
    filterlx1                            = 0;
    filterlx2                            = 0;
    filterly1                            = 0;
    filterly2                            = 0;
    filterrx1                            = 0;
    filterrx2                            = 0;
    filterry1                            = 0;
    filterry2                            = 0;
    freemem                              = 0;
    gfx_ext_retina                       = 0;
    max_delay_samples                    = 0;
    maxdetunefactor                      = 0;
    mindetunefreq                        = 0;
    slider1                              = 0;
    slider2                              = 0;
    slider3                              = 0;
    slider4                              = 0;
    slider5                              = 0;
    slider6                              = 0;
    slider7                              = 0;
    slider8                              = 0;
    slider9                              = 0;
    wet                                  = 0;
    wet_step                             = 0;
    wet_value                            = 0;
    writepos                             = 0;
  }
  //----------------------------------------------------------------------------
  // global/stateful variables for section "block"
  double amp;
  double ampb;
  double buffersize;
  double chorusphasespeed1;
  double chorusphasespeed2;
  double chorusphasespeed3;
  double chorusphasespeed4;
  double chorussamples;
  double delay1a_index;
  double delay1b_index;
  double delay2a_index;
  double delay2b_index;
  double delay3a_index;
  double delay3b_index;
  double delay4a_index;
  double delay4b_index;
  double feedbacka;
  double feedbackb;
  double filter_a1_step;
  double filter_a1_value;
  double filter_a2_step;
  double filter_a2_value;
  double filter_b0_step;
  double filter_b0_value;
  double filter_b1_step;
  double filter_b1_value;
  double filter_b2_step;
  double filter_b2_value;
  //----------------------------------------------------------------------------
  void init_block_variables()
  {
    amp               = 0;
    ampb              = 0;
    buffersize        = 0;
    chorusphasespeed1 = 0;
    chorusphasespeed2 = 0;
    chorusphasespeed3 = 0;
    chorusphasespeed4 = 0;
    chorussamples     = 0;
    delay1a_index     = 0;
    delay1b_index     = 0;
    delay2a_index     = 0;
    delay2b_index     = 0;
    delay3a_index     = 0;
    delay3b_index     = 0;
    delay4a_index     = 0;
    delay4b_index     = 0;
    feedbacka         = 0;
    feedbackb         = 0;
    filter_a1_step    = 0;
    filter_a1_value   = 0;
    filter_a2_step    = 0;
    filter_a2_value   = 0;
    filter_b0_step    = 0;
    filter_b0_value   = 0;
    filter_b1_step    = 0;
    filter_b1_value   = 0;
    filter_b2_step    = 0;
    filter_b2_value   = 0;
  }
  //----------------------------------------------------------------------------
  plugin_context* plugcontext = nullptr;
  //----------------------------------------------------------------------------
public:
  void reset (plugin_context& pc)
  {
    plugcontext = &pc;
    init_init_variables();
    init_block_variables();
    _current_block_samples = pc.get_max_block_samples();

    slider1 = 50.0;
    slider2 = 60.0;
    slider3 = 80.0;
#if 0
    slider4 = 25.0;
    slider5  = 100.0;
#else
    slider4 = 100.0;
    slider5 = 0.0;
#endif
    slider6          = 0.0;
    slider7          = 8000.0;
    slider8          = 10.0;
    slider9          = 2.5;
    chorus_alignment = 0.0;
#if 0
    freemem           = ui_setup (0.) /*TODO: unknown call */;
#else
    freemem = 0.;
#endif
    gfx_ext_retina    = 1.;
    maxdetunefactor   = std::pow (2., 110. / 1200.) * std::exp (0.15);
    mindetunefreq     = 0.1;
    max_delay_samples = std::ceil (
      jsfx_specialvar_get_srate() * std::exp (0.3)
      + maxdetunefactor / mindetunefreq / (2. * 3.141592653589793)
        * jsfx_specialvar_get_srate()
      + 1.);
    /*              delay buff                  interp */
    heap_reset (((max_delay_samples + 4 + 1) + (64 * 4)) * 8);

    freemem = init_delay_init (
      freemem,
      max_delay_samples,
      delay1a_interp_samples,
      delay1a_config_interpolation_samples,
      delay1a_buffer_length,
      delay1a_buffer,
      delay1a_allpass_y2,
      delay1a_allpass_y1,
      delay1a_allpass_x2,
      delay1a_allpass_x1,
      delay1a_interp_scale,
      delay1a_interp_offset,
      delay1a_interp_buffer);
    freemem = init_delay_init (
      freemem,
      max_delay_samples,
      delay1b_interp_samples,
      delay1b_config_interpolation_samples,
      delay1b_buffer_length,
      delay1b_buffer,
      delay1b_allpass_y2,
      delay1b_allpass_y1,
      delay1b_allpass_x2,
      delay1b_allpass_x1,
      delay1b_interp_scale,
      delay1b_interp_offset,
      delay1b_interp_buffer);
    freemem = init_delay_init (
      freemem,
      max_delay_samples,
      delay2a_interp_samples,
      delay2a_config_interpolation_samples,
      delay2a_buffer_length,
      delay2a_buffer,
      delay2a_allpass_y2,
      delay2a_allpass_y1,
      delay2a_allpass_x2,
      delay2a_allpass_x1,
      delay2a_interp_scale,
      delay2a_interp_offset,
      delay2a_interp_buffer);
    freemem = init_delay_init (
      freemem,
      max_delay_samples,
      delay2b_interp_samples,
      delay2b_config_interpolation_samples,
      delay2b_buffer_length,
      delay2b_buffer,
      delay2b_allpass_y2,
      delay2b_allpass_y1,
      delay2b_allpass_x2,
      delay2b_allpass_x1,
      delay2b_interp_scale,
      delay2b_interp_offset,
      delay2b_interp_buffer);
    freemem = init_delay_init (
      freemem,
      max_delay_samples,
      delay3a_interp_samples,
      delay3a_config_interpolation_samples,
      delay3a_buffer_length,
      delay3a_buffer,
      delay3a_allpass_y2,
      delay3a_allpass_y1,
      delay3a_allpass_x2,
      delay3a_allpass_x1,
      delay3a_interp_scale,
      delay3a_interp_offset,
      delay3a_interp_buffer);
    freemem = init_delay_init (
      freemem,
      max_delay_samples,
      delay3b_interp_samples,
      delay3b_config_interpolation_samples,
      delay3b_buffer_length,
      delay3b_buffer,
      delay3b_allpass_y2,
      delay3b_allpass_y1,
      delay3b_allpass_x2,
      delay3b_allpass_x1,
      delay3b_interp_scale,
      delay3b_interp_offset,
      delay3b_interp_buffer);
    freemem = init_delay_init (
      freemem,
      max_delay_samples,
      delay4a_interp_samples,
      delay4a_config_interpolation_samples,
      delay4a_buffer_length,
      delay4a_buffer,
      delay4a_allpass_y2,
      delay4a_allpass_y1,
      delay4a_allpass_x2,
      delay4a_allpass_x1,
      delay4a_interp_scale,
      delay4a_interp_offset,
      delay4a_interp_buffer);
    freemem = init_delay_init (
      freemem,
      max_delay_samples,
      delay4b_interp_samples,
      delay4b_config_interpolation_samples,
      delay4b_buffer_length,
      delay4b_buffer,
      delay4b_allpass_y2,
      delay4b_allpass_y1,
      delay4b_allpass_x2,
      delay4b_allpass_x1,
      delay4b_interp_scale,
      delay4b_interp_offset,
      delay4b_interp_buffer);

    filterlx2     = 0.;
    filterlx1     = filterlx2;
    filterrx2     = 0.;
    filterrx1     = filterrx2;
    filterly2     = 0.;
    filterly1     = filterly2;
    filterry2     = 0.;
    filterry1     = filterry2;
    writepos      = 0.;
    delaysamples4 = 0.;
    delaysamples3 = delaysamples4;
    delaysamples2 = delaysamples3;
    delaysamples1 = delaysamples2;
    chorusphase1  = jsfx_rand() * 2. * 3.141592653589793;
    chorusphase2  = jsfx_rand() * 2. * 3.141592653589793;
    chorusphase3  = jsfx_rand() * 2. * 3.141592653589793;
    chorusphase4  = jsfx_rand() * 2. * 3.141592653589793;
    ;
    init_update();
    init_smoother_init (wet_value, wet, wet_step);
    init_smoother_init (dry_value, dry, dry_step);
    ;
  }
  //----------------------------------------------------------------------------
private:
  void slider() { init_update(); }
  uint _current_block_samples = 0;

public:
  //----------------------------------------------------------------------------
  template <class T>
  void process_block_replacing (std::array<T*, 2> chnls, uint block_samples)
  {
    _current_block_samples = block_samples;

    double d            = 0.;
    double echo1a       = 0.;
    double echo1b       = 0.;
    double echo2a       = 0.;
    double echo2b       = 0.;
    double echo3a       = 0.;
    double echo3b       = 0.;
    double echo4a       = 0.;
    double echo4b       = 0.;
    double filter_a0    = 0.;
    double filter_a1    = 0.;
    double filter_a2    = 0.;
    double filter_alpha = 0.;
    double filter_b0    = 0.;
    double filter_b1    = 0.;
    double filter_b2    = 0.;
    double filter_cosw0 = 0.;
    double filter_freq  = 0.;
    double filter_q     = 0.;
    double filter_w0    = 0.;
    double left         = 0.;
    double right        = 0.;
    double sine1        = 0.;
    double sine2        = 0.;
    double sine3        = 0.;
    double sine4        = 0.;
    double smoothing    = 0.;
    double x            = 0.;
    double y1a          = 0.;
    double y1b          = 0.;
    double y2a          = 0.;
    double y2b          = 0.;
    double y3a          = 0.;
    double y3b          = 0.;
    double y4a          = 0.;
    double y4b          = 0.;

    filter_q    = 0.5;
    filter_freq = slider7;
    filter_w0   = 2. * 3.141592653589793
      * std::min (0.49, filter_freq / jsfx_specialvar_get_srate());
    filter_cosw0 = std::cos (filter_w0);
    filter_alpha = std::sin (filter_w0) / (2. * filter_q);
    filter_a0    = 1. + filter_alpha;
    filter_a1    = (-2. * filter_cosw0) / filter_a0;
    filter_a2    = (1. - filter_alpha) / filter_a0;
    filter_b1    = (1. - filter_cosw0) / filter_a0;
    filter_b0    = filter_b1 / 2.;
    filter_b2    = filter_b0;
    smoothing    = init_smoother_block_1 (wet, wet_value, wet_step)
      + init_smoother_block_1 (dry, dry_value, dry_step)
      + init_smoother_block_1 (filter_a1, filter_a1_value, filter_a1_step)
      + init_smoother_block_1 (filter_a2, filter_a2_value, filter_a2_step)
      + init_smoother_block_1 (filter_b0, filter_b0_value, filter_b0_step)
      + init_smoother_block_1 (filter_b1, filter_b1_value, filter_b1_step)
      + init_smoother_block_1 (filter_b2, filter_b2_value, filter_b2_step);
    ;
    for (int __i = 0, __end = block_samples; __i < __end; ++__i) {
      auto& spl0 = chnls[0][__i];
      auto& spl1 = chnls[1][__i];

      if (smoothing) {
        init_smoother_sample (wet_value, wet_step);
        init_smoother_sample (dry_value, dry_step);
        init_smoother_sample (filter_a1_value, filter_a1_step);
        init_smoother_sample (filter_a2_value, filter_a2_step);
        init_smoother_sample (filter_b0_value, filter_b0_step);
        init_smoother_sample (filter_b1_value, filter_b1_step);
        init_smoother_sample (filter_b2_value, filter_b2_step);
      }
      if (chorus_alignment) {
        chorusphase1 += chorusphasespeed1;
        if (chorusphase1 > 2. * 3.141592653589793) {
          chorusphase1 -= 2. * 3.141592653589793;
        }
        sine1 = std::sin (chorusphase1);
        sine2 = std::cos (chorusphase2);
        sine3 = -sine1;
        sine4 = -sine2;
      }
      else {
        chorusphase1 += chorusphasespeed1;
        if (chorusphase1 > 2. * 3.141592653589793) {
          chorusphase1 -= 2. * 3.141592653589793;
        }
        chorusphase2 += chorusphasespeed2;
        if (chorusphase2 > 2. * 3.141592653589793) {
          chorusphase2 -= 2. * 3.141592653589793;
        }
        chorusphase3 += chorusphasespeed3;
        if (chorusphase3 > 2. * 3.141592653589793) {
          chorusphase3 -= 2. * 3.141592653589793;
        }
        chorusphase4 += chorusphasespeed4;
        if (chorusphase4 > 2. * 3.141592653589793) {
          chorusphase4 -= 2. * 3.141592653589793;
        }
        sine1 = std::sin (chorusphase1); // TODO: range "-+2pi". optimize!
        sine2 = std::sin (chorusphase2);
        sine3 = std::sin (chorusphase3);
        sine4 = std::sin (chorusphase4);
      }
      d      = delaysamples1 + (1. + sine1) * 0.5 * chorussamples - 1.;
      echo1a = init_delay_output_linear (
        d,
        delay1a_index,
        delay1a_interp_samples,
        delay1a_interp_offset,
        delay1a_buffer_length,
        delay1a_interp_scale,
        delay1a_interp_buffer,
        delay1a_buffer);
      echo1b = init_delay_output_linear (
        d,
        delay1b_index,
        delay1b_interp_samples,
        delay1b_interp_offset,
        delay1b_buffer_length,
        delay1b_interp_scale,
        delay1b_interp_buffer,
        delay1b_buffer);
      d      = delaysamples2 + (1. + sine2) * 0.5 * chorussamples - 1.;
      echo2a = init_delay_output_linear (
        d,
        delay2a_index,
        delay2a_interp_samples,
        delay2a_interp_offset,
        delay2a_buffer_length,
        delay2a_interp_scale,
        delay2a_interp_buffer,
        delay2a_buffer);
      echo2b = init_delay_output_linear (
        d,
        delay2b_index,
        delay2b_interp_samples,
        delay2b_interp_offset,
        delay2b_buffer_length,
        delay2b_interp_scale,
        delay2b_interp_buffer,
        delay2b_buffer);
      d      = delaysamples3 + (1. + sine3) * 0.5 * chorussamples - 1.;
      echo3a = init_delay_output_linear (
        d,
        delay3a_index,
        delay3a_interp_samples,
        delay3a_interp_offset,
        delay3a_buffer_length,
        delay3a_interp_scale,
        delay3a_interp_buffer,
        delay3a_buffer);
      echo3b = init_delay_output_linear (
        d,
        delay3b_index,
        delay3b_interp_samples,
        delay3b_interp_offset,
        delay3b_buffer_length,
        delay3b_interp_scale,
        delay3b_interp_buffer,
        delay3b_buffer);
      d      = delaysamples4 + (1. + sine4) * 0.5 * chorussamples - 1.;
      echo4a = init_delay_output_linear (
        d,
        delay4a_index,
        delay4a_interp_samples,
        delay4a_interp_offset,
        delay4a_buffer_length,
        delay4a_interp_scale,
        delay4a_interp_buffer,
        delay4a_buffer);
      echo4b = init_delay_output_linear (
        d,
        delay4b_index,
        delay4b_interp_samples,
        delay4b_interp_offset,
        delay4b_buffer_length,
        delay4b_interp_scale,
        delay4b_interp_buffer,
        delay4b_buffer);
      y1a   = 0.5 * (echo1a + echo2a - echo3a + echo4a);
      y1b   = 0.5 * (echo1b + echo2b - echo3b + echo4b);
      y2a   = -0.5 * (echo1a + echo2a + echo3a - echo4a);
      y2b   = -0.5 * (echo1b + echo2b + echo3b - echo4b);
      y3a   = 0.5 * (echo1a - echo2a - echo3a - echo4a);
      y3b   = 0.5 * (echo1b - echo2b - echo3b - echo4b);
      y4a   = 0.5 * (echo1a - echo2a + echo3a + echo4a);
      y4b   = 0.5 * (echo1b - echo2b + echo3b + echo4b);
      left  = spl0;
      right = spl1;
      init_delay_input (
        y1a * feedbacka + left * amp,
        delay1a_index,
        delay1a_buffer_length,
        delay1a_buffer);
      init_delay_input (
        y1b * feedbackb + left * ampb,
        delay1b_index,
        delay1b_buffer_length,
        delay1b_buffer);
      init_delay_input (
        y2a * feedbacka + right * amp,
        delay2a_index,
        delay2a_buffer_length,
        delay2a_buffer);
      init_delay_input (
        y2b * feedbackb + right * ampb,
        delay2b_index,
        delay2b_buffer_length,
        delay2b_buffer);
      init_delay_input (
        y3a * feedbacka + left * amp,
        delay3a_index,
        delay3a_buffer_length,
        delay3a_buffer);
      init_delay_input (
        y3b * feedbackb + left * ampb,
        delay3b_index,
        delay3b_buffer_length,
        delay3b_buffer);
      init_delay_input (
        y4a * feedbacka + right * amp,
        delay4a_index,
        delay4a_buffer_length,
        delay4a_buffer);
      init_delay_input (
        y4b * feedbackb + right * ampb,
        delay4b_index,
        delay4b_buffer_length,
        delay4b_buffer);
      left  = (y1a - y1b + y3a - y3b) * 0.71;
      right = (y2a - y2b + y4a - y4b) * 0.71;
      x     = left;
      left  = init_smoother_value (filter_b0_value) * x
        + init_smoother_value (filter_b1_value) * filterlx1
        + init_smoother_value (filter_b2_value) * filterlx2
        - init_smoother_value (filter_a1_value) * filterly1
        - init_smoother_value (filter_a2_value) * filterly2;
      filterlx2 = filterlx1;
      filterlx1 = x;
      filterly2 = filterly1;
      filterly1 = left;
      x         = right;
      right     = init_smoother_value (filter_b0_value) * x
        + init_smoother_value (filter_b1_value) * filterrx1
        + init_smoother_value (filter_b2_value) * filterrx2
        - init_smoother_value (filter_a1_value) * filterry1
        - init_smoother_value (filter_a2_value) * filterry2;
      filterrx2 = filterrx1;
      filterrx1 = x;
      filterry2 = filterry1;
      filterry1 = right;
      spl0      = spl0 * init_smoother_value (dry_value)
        + left * init_smoother_value (wet_value);
      spl1 = spl1 * init_smoother_value (dry_value)
        + right * init_smoother_value (wet_value);
      writepos += 1.;
      if (writepos >= buffersize) {
        writepos = 0.;
      };
    }
  }
  // functions for section "init"
private:
  //----------------------------------------------------------------------------
  double init_delay_init (
    double  freemem,
    double  max_delay_samples,
    double& _interp_samples,
    double& _config_interpolation_samples,
    double& _buffer_length,
    double& _buffer,
    double& _allpass_y2,
    double& _allpass_y1,
    double& _allpass_x2,
    double& _allpass_x1,
    double& _interp_scale,
    double& _interp_offset,
    double& _interp_buffer)
  {
    return init_delay_setup (
      freemem,
      max_delay_samples,
      _interp_samples,
      _config_interpolation_samples,
      _buffer_length,
      _buffer,
      _allpass_y2,
      _allpass_y1,
      _allpass_x2,
      _allpass_x1,
      _interp_scale,
      _interp_offset,
      _interp_buffer);
  }
  //----------------------------------------------------------------------------
  double init_delay_input (
    double  spl,
    double& _index,
    double& _buffer_length,
    double& _buffer)
  {
    _index += 1.;
    if (_index >= _buffer_length) {
      (_index = 0.);
    }
    heap (_buffer + _index) = spl;
    return heap (_buffer + _index);
  }
  //----------------------------------------------------------------------------
  double init_delay_output_linear (
    double  samples,
    double& _index,
    double& _interp_samples,
    double& _interp_offset,
    double& _buffer_length,
    double& _interp_scale,
    double& _interp_buffer,
    double& _buffer)
  {
    double sum          = 0.;
    double index2       = 0.;
    double interp_index = 0.;
    double index1       = 0.;
    double index        = 0.;
    double i            = 0.;
    double ratio        = 0.;
    index  = _index - std::max (_interp_samples, samples + _interp_offset - 1.);
    index1 = std::floor (index);
    ratio  = index - index1;

    while (index1 < 0.) {
      index1 += _buffer_length;
    }
    sum          = 0.;
    index        = index1;
    interp_index = std::floor ((1. - ratio) * _interp_scale);

    i = 0.;
    while (i < _interp_samples) {
      sum += heap (_interp_buffer + interp_index) * heap (_buffer + index);
      interp_index += _interp_scale;
      index += 1.;
      if (index >= _buffer_length) {
        (index = 0.);
      }
      i += 1.;
    }
    return sum;
  }
  //----------------------------------------------------------------------------
  double init_delay_setup (
    double  freemem,
    double  max_delay_samples,
    double& _interp_samples,
    double& _config_interpolation_samples,
    double& _buffer_length,
    double& _buffer,
    double& _allpass_y2,
    double& _allpass_y1,
    double& _allpass_x2,
    double& _allpass_x1,
    double& _interp_scale,
    double& _interp_offset,
    double& _interp_buffer)
  {
    double w        = 0.;
    double t        = 0.;
    double wr       = 0.;
    double i        = 0.;
    _interp_samples = [&] {
      if (_config_interpolation_samples) {
        return _config_interpolation_samples;
      }
      else {
        return 4.;
      }
    }();
    _buffer_length = std::ceil (max_delay_samples + _interp_samples + 1.);
    (_buffer = freemem);
    freemem = _buffer + _buffer_length;
    i       = 0.;
    while (i < _buffer_length) {
      heap (_buffer + i) = 0.;
      i += 1.;
    }
    _allpass_y2    = 0.;
    _allpass_y1    = _allpass_y2;
    _allpass_x2    = _allpass_y1;
    _allpass_x1    = _allpass_x2;
    _interp_scale  = 64.;
    _interp_offset = _interp_samples / 2.;
    (_interp_buffer = freemem);
    freemem = _interp_buffer + _interp_samples * _interp_scale;
    i       = 0.; // Why N lookup tables? Mem Locality?
    while (i < _interp_samples * _interp_scale) {
      wr = (i + 0.5) / (_interp_samples * _interp_scale);
      w  = 0.42 - 0.5 * std::cos (wr * 3.141592653589793 * 2.)
        + 0.08 * std::cos (wr * 3.141592653589793 * 4.);
      t                         = i / _interp_scale - _interp_offset;
      heap (_interp_buffer + i) = init_sinc (t * 3.141592653589793) * w;
      i += 1.;
    }
    return freemem;
  }
  //----------------------------------------------------------------------------
  double init_sinc (double x)
  {
    return [&] {
      if (std::abs (x) < 0.000001) {
        return 1.;
      }
      else {
        return std::sin (x) / x;
      }
    }();
  }
  //----------------------------------------------------------------------------
  double init_smoother_block_1 (double& this_, double& _value, double& _step)
  {
    return [&] {
      if (eel2_ne (this_, _value)) {
        _step = (this_ - _value) / (double) _current_block_samples;
        return 1.;
      }
      else {
        (_step = 0.);
        return _step;
      }
    }();
  }
  //----------------------------------------------------------------------------
  double init_smoother_init (double& _value, double& this_, double& _step)
  {
    _value = this_;
    _step  = 0.;
    return 1.;
  }
  //----------------------------------------------------------------------------
  double init_smoother_sample (double& _value, double& _step)
  {
    _value += _step;
    return _value;
  }
  //----------------------------------------------------------------------------
  double init_smoother_value (double& _value) { return _value; }
  //----------------------------------------------------------------------------
  double init_update()
  {
    double chorusfactor = 0.;
    double chorus       = 0.;
    double delay        = 0.;
    delayfactor1        = std::exp (0.3);
    delayfactor2        = std::exp (0.1);
    delayfactor3        = std::exp (-0.1);
    delayfactor4        = std::exp (-0.3);
    if (eel2_eq (slider6, 1.)) {
      delayfactor1 = std::exp (0.0);
      delayfactor2 = std::exp (0.04);
      delayfactor3 = std::exp (-0.09);
      delayfactor4 = std::exp (0.13);
    }
    delay          = slider1 * jsfx_specialvar_get_srate() / 1000.;
    delaysamples1  = std::min (max_delay_samples - 1., delay * delayfactor1);
    delaysamples2  = std::min (max_delay_samples - 1., delay * delayfactor2);
    delaysamples3  = std::min (max_delay_samples - 1., delay * delayfactor3);
    delaysamples4  = std::min (max_delay_samples - 1., delay * delayfactor4);
    delaysamples1i = std::ceil (delaysamples1);
    delaysamples2i = std::ceil (delaysamples2);
    delaysamples3i = std::ceil (delaysamples3);
    delaysamples4i = std::ceil (delaysamples4);
    chorus = slider9 * 2. * 3.141592653589793 / jsfx_specialvar_get_srate();
    chorusphasespeed4 = chorus;
    chorusphasespeed3 = chorusphasespeed4;
    if (chorus_alignment) {
      (chorusphasespeed1 = chorusphasespeed2 = chorusphasespeed3);
    }
    else {
      chorusphasespeed1 = chorus * std::exp (-0.15);
      chorusphasespeed2 = chorus * std::exp (-0.05);
      chorusphasespeed3 = chorus * std::exp (0.05);
      chorusphasespeed4 = chorus * std::exp (0.15);
    }
    chorusfactor  = std::pow (2., slider8 / 1200.) - 1.;
    chorussamples = chorusfactor * jsfx_specialvar_get_srate()
      / (slider9 * 2. * 3.141592653589793);
    feedbacka     = slider2 / 100.;
    feedbackratio = slider3 / 100.;
    feedbackb     = feedbacka * feedbackratio;
    dry           = slider5 / 100.;
    wet           = slider4 / 100.;
    amp           = (1. - feedbacka * feedbackratio) / (1. - feedbackratio);
    ampb          = amp * std::min (1., feedbackratio * 1.1);
    return ampb;
  }
}; /* jsfx_process */
}} // namespace artv::geraint_luff

#pragma once
// Generated by jsfx2cpp.py. To be manually corrected.
// includes for environment function calls
#include <juce_audio_processors/juce_audio_processors.h>

#include "artv-common/dsp/jsfx_engine/jsfx_engine.hpp"
#include "artv-common/dsp/own/classes/misc.hpp"
#include "artv-common/dsp/own/classes/plugin_context.hpp"
#include "artv-common/dsp/types.hpp"
#include "artv-common/juce/parameter_definitions.hpp"
#include "artv-common/juce/parameter_types.hpp"
#include "artv-common/misc/mp11.hpp"
#include "artv-common/misc/short_ints.hpp"
#include "artv-common/misc/util.hpp"

namespace artv { namespace chokehold {
class consolidator {
public:
  //----------------------------------------------------------------------------
  static constexpr dsp_types dsp_type = dsp_types::dynamics;
  //----------------------------------------------------------------------------
  // definitions for environment function calls
  static double eel2_eq (double lhs, double rhs)
  {
    return (double) (std::fabs (lhs - rhs) < 0.00001);
  }
  static double eel2_pow (double lhs, double rhs)
  {
    return std::pow (lhs, rhs);
  }

  //----------------------------------------------------------------------------
  // stubs for JSFX special variables

  double jsfx_specialvar_get_srate() { return plugcontext->get_sample_rate(); }

  //----------------------------------------------------------------------------

#if 0
  void set_operation_slider (float v)
  {
    // Original slider line: slider1:operation=2<0, 2,
    // {Gentle,Dynamic,Hard}>Operation Range: min:0.0, max:2.0, default: 2.0,
    // step: None
    if (v == operation) {
      return;
    }
    operation = v;
    slider();
  }
#else
  // Snippet for parameter boilerplate in the authors framework....
  struct operation_tag {};

  void set (operation_tag, int v)
  {
    // Original slider line: slider1:operation=2<0, 2,
    // {Gentle,Dynamic,Hard}>Operation Range: min:0.0, max:2.0, default: 2.0,
    // step: None
    if (v == (int) operation) {
      return;
    }
    operation = (float) v;
    slider();
  }

  static constexpr auto get_parameter (operation_tag)
  {
    // Original slider line: slider1:operation=2<0, 2,
    // {Gentle,Dynamic,Hard}>Operation
    return choice_param (2, make_cstr_array ("Gentle", "Dynamic", "Hard"));
  }

#endif
#if 0
  void set_dbgain_slider (float v)
  {
    // Original slider line: slider2:dBGain=0<0, 24, 0.01>Input boost [dB]
    // Range: min:0.0, max:24.0, default: 0.0, step: 0.01
    if (v == dbgain) {
      return;
    }
    dbgain = v;
    slider();
  }
#else
  // Snippet for parameter boilerplate in the authors framework....
  struct dbgain_tag {};

  void set (dbgain_tag, float v)
  {
    // Original slider line: slider2:dBGain=0<0, 24, 0.01>Input boost [dB]
    // Range: min:0.0, max:24.0, default: 0.0, step: 0.01
    if (v == dbgain) {
      return;
    }
    dbgain = v;
    slider();
  }

  static constexpr auto get_parameter (dbgain_tag)
  {
    // Original slider line: slider2:dBGain=0<0, 24, 0.01>Input boost [dB]
    return float_param ("dB", 0.0, 24.0, 0.0, 0.01);
  }

#endif
#if 0
  void set_scfreq_slider (float v)
  {
    // Original slider line: slider3:scFreq=75<20, 500, 1>SC high pass [Hz]
    // Range: min:20.0, max:500.0, default: 75.0, step: 1.0
    if (v == scfreq) {
      return;
    }
    scfreq = v;
    slider();
  }
#else
  // Snippet for parameter boilerplate in the authors framework....
  struct scfreq_tag {};

  void set (scfreq_tag, float v)
  {
    // Original slider line: slider3:scFreq=75<20, 500, 1>SC high pass [Hz]
    // Range: min:20.0, max:500.0, default: 75.0, step: 1.0
    v = midi_note_to_hz (v);
    if (v == scfreq) {
      return;
    }
    scfreq = v;
    slider();
  }

  static constexpr auto get_parameter (scfreq_tag)
  {
    // Original slider line: slider3:scFreq=75<20, 500, 1>SC high pass [Hz]
    return frequency_parameter (20.0, 500.0, 75.0);
  }

#endif
#if 0
  void set_midside_slider (float v)
  {
    // Original slider line: slider4:midSide=0<0,1,{Stereo (L+R),Mid/Side
    // (M+S)}>Channel routing Range: min:0.0, max:1.0, default: 0.0, step: None
    if (v == midside) {
      return;
    }
    midside = v;
    slider();
  }
#else
  // Snippet for parameter boilerplate in the authors framework....
  struct midside_tag {};

  void set (midside_tag, int v)
  {
    // Original slider line: slider4:midSide=0<0,1,{Stereo (L+R),Mid/Side
    // (M+S)}>Channel routing Range: min:0.0, max:1.0, default: 0.0, step: None
    if (v == (int) midside) {
      return;
    }
    midside = (float) v;
    slider();
  }

  static constexpr auto get_parameter (midside_tag)
  {
    // Original slider line: slider4:midSide=0<0,1,{Stereo (L+R),Mid/Side
    // (M+S)}>Channel routing
    return choice_param (0, make_cstr_array ("Stereo", "Mid/Side"));
  }

#endif
#if 0
  void set_linkamount_slider (float v)
  {
    // Original slider line: slider5:linkAmount=0<0, 100, 1>Stereo link [%]
    // Range: min:0.0, max:100.0, default: 0.0, step: 1.0
    if (v == linkamount) {
      return;
    }
    linkamount = v;
    slider();
  }
#else
  // Snippet for parameter boilerplate in the authors framework....
  struct linkamount_tag {};

  void set (linkamount_tag, float v)
  {
    // Original slider line: slider5:linkAmount=0<0, 100, 1>Stereo link [%]
    // Range: min:0.0, max:100.0, default: 0.0, step: 1.0
    if (v == linkamount) {
      return;
    }
    linkamount = v;
    slider();
  }

  static constexpr auto get_parameter (linkamount_tag)
  {
    // Original slider line: slider5:linkAmount=0<0, 100, 1>Stereo link [%]
    return float_param ("%", 0.0, 100.0, 0.0, 1.0);
  }

#endif
#if 0
  void set_dbtrim_slider (float v)
  {
    // Original slider line: slider6:dBTrim=0<-12, 12, 0.01>Makeup gain [dB]
    // Range: min:-12.0, max:12.0, default: 0.0, step: 0.01
    if (v == dbtrim) {
      return;
    }
    dbtrim = v;
    slider();
  }
#else
  // Snippet for parameter boilerplate in the authors framework....
  struct dbtrim_tag {};

  void set (dbtrim_tag, float v)
  {
    // Original slider line: slider6:dBTrim=0<-12, 12, 0.01>Makeup gain [dB]
    // Range: min:-12.0, max:12.0, default: 0.0, step: 0.01
    if (v == dbtrim) {
      return;
    }
    dbtrim = v;
    slider();
  }

  static constexpr auto get_parameter (dbtrim_tag)
  {
    // Original slider line: slider6:dBTrim=0<-12, 12, 0.01>Makeup gain [dB]
    return float_param ("dB", -12.0, 12.0, 0.0, 0.01);
  }

#endif
#if 0
  void set_pctmix_slider (float v)
  {
    // Original slider line: slider7:pctMix=100<0,100,0.01>Dry/wet mix [%]
    // Range: min:0.0, max:100.0, default: 100.0, step: 0.01
    if (v == pctmix) {
      return;
    }
    pctmix = v;
    slider();
  }
#else
  // Snippet for parameter boilerplate in the authors framework....
  struct pctmix_tag {};

  void set (pctmix_tag, float v)
  {
    // Original slider line: slider7:pctMix=100<0,100,0.01>Dry/wet mix [%]
    // Range: min:0.0, max:100.0, default: 100.0, step: 0.01
    if (v == pctmix) {
      return;
    }
    pctmix = v;
    slider();
  }

  static constexpr auto get_parameter (pctmix_tag)
  {
    // Original slider line: slider7:pctMix=100<0,100,0.01>Dry/wet mix [%]
    return float_param ("%", 0.0, 100.0, 100.0, 0.01);
  }

  // self made
  struct drive_tag {};

  void set (drive_tag, float v)
  {
    set (dbgain_tag {}, v);
    set (dbtrim_tag {}, std::max (-v, get_parameter (dbtrim_tag {}).min));
  }

  static constexpr auto get_parameter (drive_tag)
  {
    return get_parameter (dbgain_tag {});
  }

#endif
#if 0
#else
  // Snippet for parameter boilerplate in the authors framework....
  using parameters = mp_list<
    operation_tag,
    dbgain_tag,
    scfreq_tag,
    midside_tag,
    linkamount_tag,
    dbtrim_tag,
    pctmix_tag,
    drive_tag>;
#endif
private:
  //----------------------------------------------------------------------------
  // global/stateful variables for section "init"
  double dbgain;
  double dbtrim;
  double floatfloor;
  double halfpi;
  double linkamount;
  double m_ln10_20;
  double midside;
  double operation;
  double pctmix;
  double rcpsqrt2;
  double scfreq;
  //----------------------------------------------------------------------------
  void init_init_variables()
  {
    dbgain     = 0;
    dbtrim     = 0;
    floatfloor = 0;
    halfpi     = 0;
    linkamount = 0;
    m_ln10_20  = 0;
    midside    = 0;
    operation  = 0;
    pctmix     = 0;
    rcpsqrt2   = 0;
    scfreq     = 0;
  }
  //----------------------------------------------------------------------------
  // global/stateful variables for section "slider"
  double comp1l$attrel$coeffatt;
  double comp1l$attrel$coeffrel;
  double comp1l$calc$knee;
  double comp1l$calc$kneelower;
  double comp1l$calc$kneeupper;
  double comp1l$calc$kneewidth;
  double comp1l$calc$ratio;
  double comp1l$calc$threshold;
  double comp1r$attrel$coeffatt;
  double comp1r$attrel$coeffrel;
  double comp1r$calc$knee;
  double comp1r$calc$kneelower;
  double comp1r$calc$kneeupper;
  double comp1r$calc$kneewidth;
  double comp1r$calc$ratio;
  double comp1r$calc$threshold;
  double comp2l$attrel$coeffatt;
  double comp2l$attrel$coeffrel;
  double comp2l$calc$knee;
  double comp2l$calc$kneelower;
  double comp2l$calc$kneeupper;
  double comp2l$calc$kneewidth;
  double comp2l$calc$ratio;
  double comp2l$calc$threshold;
  double comp2r$attrel$coeffatt;
  double comp2r$attrel$coeffrel;
  double comp2r$calc$knee;
  double comp2r$calc$kneelower;
  double comp2r$calc$kneeupper;
  double comp2r$calc$kneewidth;
  double comp2r$calc$ratio;
  double comp2r$calc$threshold;
  double comp3l$attrel$coeffatt;
  double comp3l$attrel$coeffrel;
  double comp3l$calc$knee;
  double comp3l$calc$kneelower;
  double comp3l$calc$kneeupper;
  double comp3l$calc$kneewidth;
  double comp3l$calc$ratio;
  double comp3l$calc$threshold;
  double comp3r$attrel$coeffatt;
  double comp3r$attrel$coeffrel;
  double comp3r$calc$knee;
  double comp3r$calc$kneelower;
  double comp3r$calc$kneeupper;
  double comp3r$calc$kneewidth;
  double comp3r$calc$ratio;
  double comp3r$calc$threshold;
  double drywet;
  double filter1l$a1;
  double filter1l$a2;
  double filter1l$a3;
  double filter1l$m0;
  double filter1l$m1;
  double filter1l$m2;
  double filter1r$a1;
  double filter1r$a2;
  double filter1r$a3;
  double filter1r$m0;
  double filter1r$m1;
  double filter1r$m2;
  double filter2l$a1;
  double filter2l$a2;
  double filter2l$a3;
  double filter2l$m0;
  double filter2l$m1;
  double filter2l$m2;
  double filter2r$a1;
  double filter2r$a2;
  double filter2r$a3;
  double filter2r$m0;
  double filter2r$m1;
  double filter2r$m2;
  double filter3l$a1;
  double filter3l$a2;
  double filter3l$a3;
  double filter3l$m0;
  double filter3l$m1;
  double filter3l$m2;
  double filter3r$a1;
  double filter3r$a2;
  double filter3r$a3;
  double filter3r$m0;
  double filter3r$m1;
  double filter3r$m2;
  double gainin;
  double gainout;
  double lnkmix;
  double splmix;
  double wetdry;
  //----------------------------------------------------------------------------
  void init_slider_variables()
  {
    comp1l$attrel$coeffatt = 0;
    comp1l$attrel$coeffrel = 0;
    comp1l$calc$knee       = 0;
    comp1l$calc$kneelower  = 0;
    comp1l$calc$kneeupper  = 0;
    comp1l$calc$kneewidth  = 0;
    comp1l$calc$ratio      = 0;
    comp1l$calc$threshold  = 0;
    comp1r$attrel$coeffatt = 0;
    comp1r$attrel$coeffrel = 0;
    comp1r$calc$knee       = 0;
    comp1r$calc$kneelower  = 0;
    comp1r$calc$kneeupper  = 0;
    comp1r$calc$kneewidth  = 0;
    comp1r$calc$ratio      = 0;
    comp1r$calc$threshold  = 0;
    comp2l$attrel$coeffatt = 0;
    comp2l$attrel$coeffrel = 0;
    comp2l$calc$knee       = 0;
    comp2l$calc$kneelower  = 0;
    comp2l$calc$kneeupper  = 0;
    comp2l$calc$kneewidth  = 0;
    comp2l$calc$ratio      = 0;
    comp2l$calc$threshold  = 0;
    comp2r$attrel$coeffatt = 0;
    comp2r$attrel$coeffrel = 0;
    comp2r$calc$knee       = 0;
    comp2r$calc$kneelower  = 0;
    comp2r$calc$kneeupper  = 0;
    comp2r$calc$kneewidth  = 0;
    comp2r$calc$ratio      = 0;
    comp2r$calc$threshold  = 0;
    comp3l$attrel$coeffatt = 0;
    comp3l$attrel$coeffrel = 0;
    comp3l$calc$knee       = 0;
    comp3l$calc$kneelower  = 0;
    comp3l$calc$kneeupper  = 0;
    comp3l$calc$kneewidth  = 0;
    comp3l$calc$ratio      = 0;
    comp3l$calc$threshold  = 0;
    comp3r$attrel$coeffatt = 0;
    comp3r$attrel$coeffrel = 0;
    comp3r$calc$knee       = 0;
    comp3r$calc$kneelower  = 0;
    comp3r$calc$kneeupper  = 0;
    comp3r$calc$kneewidth  = 0;
    comp3r$calc$ratio      = 0;
    comp3r$calc$threshold  = 0;
    drywet                 = 0;
    filter1l$a1            = 0;
    filter1l$a2            = 0;
    filter1l$a3            = 0;
    filter1l$m0            = 0;
    filter1l$m1            = 0;
    filter1l$m2            = 0;
    filter1r$a1            = 0;
    filter1r$a2            = 0;
    filter1r$a3            = 0;
    filter1r$m0            = 0;
    filter1r$m1            = 0;
    filter1r$m2            = 0;
    filter2l$a1            = 0;
    filter2l$a2            = 0;
    filter2l$a3            = 0;
    filter2l$m0            = 0;
    filter2l$m1            = 0;
    filter2l$m2            = 0;
    filter2r$a1            = 0;
    filter2r$a2            = 0;
    filter2r$a3            = 0;
    filter2r$m0            = 0;
    filter2r$m1            = 0;
    filter2r$m2            = 0;
    filter3l$a1            = 0;
    filter3l$a2            = 0;
    filter3l$a3            = 0;
    filter3l$m0            = 0;
    filter3l$m1            = 0;
    filter3l$m2            = 0;
    filter3r$a1            = 0;
    filter3r$a2            = 0;
    filter3r$a3            = 0;
    filter3r$m0            = 0;
    filter3r$m1            = 0;
    filter3r$m2            = 0;
    gainin                 = 0;
    gainout                = 0;
    lnkmix                 = 0;
    splmix                 = 0;
    wetdry                 = 0;
  }
  //----------------------------------------------------------------------------
  // global/stateful variables for section "block"
  double comp1l$attrel$envelope;
  double comp1l$gr;
  double comp1r$attrel$envelope;
  double comp1r$gr;
  double comp2l$attrel$envelope;
  double comp2l$gr;
  double comp2r$attrel$envelope;
  double comp2r$gr;
  double comp3l$attrel$envelope;
  double comp3l$gr;
  double comp3r$attrel$envelope;
  double comp3r$gr;
  double filter1l$ic1eq;
  double filter1l$ic2eq;
  double filter1l$v1;
  double filter1l$v2;
  double filter1l$v3;
  double filter1r$ic1eq;
  double filter1r$ic2eq;
  double filter1r$v1;
  double filter1r$v2;
  double filter1r$v3;
  double filter2l$ic1eq;
  double filter2l$ic2eq;
  double filter2l$v1;
  double filter2l$v2;
  double filter2l$v3;
  double filter2r$ic1eq;
  double filter2r$ic2eq;
  double filter2r$v1;
  double filter2r$v2;
  double filter2r$v3;
  double filter3l$ic1eq;
  double filter3l$ic2eq;
  double filter3l$v1;
  double filter3l$v2;
  double filter3l$v3;
  double filter3r$ic1eq;
  double filter3r$ic2eq;
  double filter3r$v1;
  double filter3r$v2;
  double filter3r$v3;
  //----------------------------------------------------------------------------
  void init_block_variables()
  {
    comp1l$attrel$envelope = 0;
    comp1l$gr              = 0;
    comp1r$attrel$envelope = 0;
    comp1r$gr              = 0;
    comp2l$attrel$envelope = 0;
    comp2l$gr              = 0;
    comp2r$attrel$envelope = 0;
    comp2r$gr              = 0;
    comp3l$attrel$envelope = 0;
    comp3l$gr              = 0;
    comp3r$attrel$envelope = 0;
    comp3r$gr              = 0;
    filter1l$ic1eq         = 0;
    filter1l$ic2eq         = 0;
    filter1l$v1            = 0;
    filter1l$v2            = 0;
    filter1l$v3            = 0;
    filter1r$ic1eq         = 0;
    filter1r$ic2eq         = 0;
    filter1r$v1            = 0;
    filter1r$v2            = 0;
    filter1r$v3            = 0;
    filter2l$ic1eq         = 0;
    filter2l$ic2eq         = 0;
    filter2l$v1            = 0;
    filter2l$v2            = 0;
    filter2l$v3            = 0;
    filter2r$ic1eq         = 0;
    filter2r$ic2eq         = 0;
    filter2r$v1            = 0;
    filter2r$v2            = 0;
    filter2r$v3            = 0;
    filter3l$ic1eq         = 0;
    filter3l$ic2eq         = 0;
    filter3l$v1            = 0;
    filter3l$v2            = 0;
    filter3l$v3            = 0;
    filter3r$ic1eq         = 0;
    filter3r$ic2eq         = 0;
    filter3r$v1            = 0;
    filter3r$v2            = 0;
    filter3r$v3            = 0;
  }
  //----------------------------------------------------------------------------
  plugin_context* plugcontext;

public:
  void reset (plugin_context& pc)
  {
    plugcontext = &pc;
    init_init_variables();
    init_slider_variables();
    init_block_variables();

    operation  = 2.0;
    dbgain     = 0.0;
    scfreq     = 75.0;
    midside    = 0.0;
    linkamount = 0.0;
    dbtrim     = 0.0;
    pctmix     = 100.0;
    m_ln10_20  = 8.68588963806503655302257837833210164588794011607333;
    floatfloor = 0.0000000630957;
    halfpi     = 3.141592653589793 * 0.5;
    rcpsqrt2   = 0.7071067812;
    slider();
  }
  //----------------------------------------------------------------------------
  void slider()
  {
    double attack1    = 0.;
    double attack2    = 0.;
    double attack3    = 0.;
    double knee1      = 0.;
    double knee2      = 0.;
    double knee3      = 0.;
    double ratio1     = 0.;
    double ratio2     = 0.;
    double ratio3     = 0.;
    double release1   = 0.;
    double release2   = 0.;
    double release3   = 0.;
    double threshold1 = 0.;
    double threshold2 = 0.;
    double threshold3 = 0.;
    lnkmix            = linkamount * 0.01;
    splmix            = 1.0 - lnkmix;
    init$eqhp (
      scfreq,
      1.5,
      filter1l$a1,
      filter1l$a2,
      filter1l$a3,
      filter1l$m0,
      filter1l$m1,
      filter1l$m2);
    init$eqhp (
      scfreq,
      1.5,
      filter1r$a1,
      filter1r$a2,
      filter1r$a3,
      filter1r$m0,
      filter1r$m1,
      filter1r$m2);
    init$eqhp (
      scfreq,
      1.5,
      filter2l$a1,
      filter2l$a2,
      filter2l$a3,
      filter2l$m0,
      filter2l$m1,
      filter2l$m2);
    init$eqhp (
      scfreq,
      1.5,
      filter2r$a1,
      filter2r$a2,
      filter2r$a3,
      filter2r$m0,
      filter2r$m1,
      filter2r$m2);
    init$eqhp (
      scfreq,
      1.5,
      filter3l$a1,
      filter3l$a2,
      filter3l$a3,
      filter3l$m0,
      filter3l$m1,
      filter3l$m2);
    init$eqhp (
      scfreq,
      1.5,
      filter3r$a1,
      filter3r$a2,
      filter3r$a3,
      filter3r$m0,
      filter3r$m1,
      filter3r$m2);
    gainin  = init$dbtogain (dbgain);
    gainout = init$dbtogain (dbtrim);
    wetdry  = pctmix * 0.01;
    drywet  = 1.0 - wetdry;
    if (eel2_eq (operation, 0.)) {
      attack1    = 100.;
      release1   = 1000.;
      threshold1 = std::min (-(dbgain * 2.), 0.);
      ratio1     = 1.5;
      knee1      = 12.;
      attack2    = 25.;
      release2   = 1000.;
      threshold2 = std::min (-(dbgain * 0.5), 0.);
      ratio2     = 2.;
      knee2      = 12.;
      attack3    = 1.;
      release3   = 1000.;
      threshold3 = std::min (-(dbgain * 0.25), 0.);
      ratio3     = 3.;
      knee3      = 6.;
    }
    if (eel2_eq (operation, 1.)) {
      attack1    = 200.;
      release1   = 200.;
      threshold1 = std::min (-dbgain, 0.);
      ratio1     = 1.5;
      knee1      = 6.;
      attack2    = 20.;
      release2   = 50.;
      threshold2 = std::min (-dbgain, 0.);
      ratio2     = 2.;
      knee2      = 12.;
      attack3    = 1.;
      release3   = 1000.;
      threshold3 = std::min (-(dbgain * 0.75), 0.);
      ratio3     = 2.;
      knee3      = 3.;
    }
    if (eel2_eq (operation, 2.)) {
      attack1    = 150.;
      release1   = 10.;
      threshold1 = std::min (-(dbgain * 2.), 0.);
      ratio1     = 2.;
      knee1      = 12.;
      attack2    = 20.;
      release2   = 10.;
      threshold2 = std::min (-dbgain, 0.);
      ratio2     = 4.;
      knee2      = 12.;
      attack3    = 1.;
      release3   = 500.;
      threshold3 = std::min (-(dbgain * 0.5), 0.);
      ratio3     = 8.;
      knee3      = 3.;
    }
    init$compsetup (
      attack1,
      release1,
      threshold1,
      ratio1,
      knee1,
      comp1l$attrel$coeffatt,
      comp1l$attrel$coeffrel,
      comp1l$calc$threshold,
      comp1l$calc$ratio,
      comp1l$calc$knee,
      comp1l$calc$kneewidth,
      comp1l$calc$kneeupper,
      comp1l$calc$kneelower);
    init$compsetup (
      attack1,
      release1,
      threshold1,
      ratio1,
      knee1,
      comp1r$attrel$coeffatt,
      comp1r$attrel$coeffrel,
      comp1r$calc$threshold,
      comp1r$calc$ratio,
      comp1r$calc$knee,
      comp1r$calc$kneewidth,
      comp1r$calc$kneeupper,
      comp1r$calc$kneelower);
    init$compsetup (
      attack2,
      release2,
      threshold2,
      ratio2,
      knee2,
      comp2l$attrel$coeffatt,
      comp2l$attrel$coeffrel,
      comp2l$calc$threshold,
      comp2l$calc$ratio,
      comp2l$calc$knee,
      comp2l$calc$kneewidth,
      comp2l$calc$kneeupper,
      comp2l$calc$kneelower);
    init$compsetup (
      attack2,
      release2,
      threshold2,
      ratio2,
      knee2,
      comp2r$attrel$coeffatt,
      comp2r$attrel$coeffrel,
      comp2r$calc$threshold,
      comp2r$calc$ratio,
      comp2r$calc$knee,
      comp2r$calc$kneewidth,
      comp2r$calc$kneeupper,
      comp2r$calc$kneelower);
    init$compsetup (
      attack3,
      release3,
      threshold3,
      ratio3,
      knee3,
      comp3l$attrel$coeffatt,
      comp3l$attrel$coeffrel,
      comp3l$calc$threshold,
      comp3l$calc$ratio,
      comp3l$calc$knee,
      comp3l$calc$kneewidth,
      comp3l$calc$kneeupper,
      comp3l$calc$kneelower);
    init$compsetup (
      attack3,
      release3,
      threshold3,
      ratio3,
      knee3,
      comp3r$attrel$coeffatt,
      comp3r$attrel$coeffrel,
      comp3r$calc$threshold,
      comp3r$calc$ratio,
      comp3r$calc$knee,
      comp3r$calc$kneewidth,
      comp3r$calc$kneeupper,
      comp3r$calc$kneelower);
    ;
  }
  //----------------------------------------------------------------------------
  template <class T>
  void process_block_replacing (std::array<T*, 2> chnls, uint samples)
  {
    double dryl   = 0.;
    double dryr   = 0.;
    double keyl   = 0.;
    double keyr   = 0.;
    double linked = 0.;

    for (uint $$i = 0; $$i < samples; ++$$i) {
      auto& spl0 = chnls[0][$$i];
      auto& spl1 = chnls[1][$$i];
      dryl       = spl0;
      dryr       = spl1;
      spl0 *= gainin;
      spl1 *= gainin;
      if (eel2_eq (midside, 1.)) {
        keyl = init$lrtom (spl0, spl1);
        keyr = init$lrtos (spl0, spl1);
        spl0 = keyl;
        spl1 = keyr;
      }
      keyl = spl0;
      keyr = spl1;
      keyl = std::fabs (init$eqtick (
        keyl,
        filter1l$v3,
        filter1l$ic2eq,
        filter1l$v1,
        filter1l$a1,
        filter1l$ic1eq,
        filter1l$a2,
        filter1l$v2,
        filter1l$a3,
        filter1l$m0,
        filter1l$m1,
        filter1l$m2));
      keyr = std::fabs (init$eqtick (
        keyr,
        filter1r$v3,
        filter1r$ic2eq,
        filter1r$v1,
        filter1r$a1,
        filter1r$ic1eq,
        filter1r$a2,
        filter1r$v2,
        filter1r$a3,
        filter1r$m0,
        filter1r$m1,
        filter1r$m2));
      if (lnkmix > 0.) {
        linked = std::sqrt (std::sqrt (keyl) + std::sqrt (keyr)) * lnkmix;
        keyl *= splmix;
        keyr *= splmix;
        keyl += linked;
        keyr += linked;
      }
      spl0 *= init$comptick (
        keyl,
        comp1l$gr,
        comp1l$attrel$envelope,
        comp1l$attrel$coeffatt,
        comp1l$attrel$coeffrel,
        comp1l$calc$ratio,
        comp1l$calc$knee,
        comp1l$calc$kneelower,
        comp1l$calc$kneeupper,
        comp1l$calc$threshold);
      spl1 *= init$comptick (
        keyr,
        comp1r$gr,
        comp1r$attrel$envelope,
        comp1r$attrel$coeffatt,
        comp1r$attrel$coeffrel,
        comp1r$calc$ratio,
        comp1r$calc$knee,
        comp1r$calc$kneelower,
        comp1r$calc$kneeupper,
        comp1r$calc$threshold);
      keyl = spl0;
      keyr = spl1;
      keyl = std::fabs (init$eqtick (
        keyl,
        filter2l$v3,
        filter2l$ic2eq,
        filter2l$v1,
        filter2l$a1,
        filter2l$ic1eq,
        filter2l$a2,
        filter2l$v2,
        filter2l$a3,
        filter2l$m0,
        filter2l$m1,
        filter2l$m2));
      keyr = std::fabs (init$eqtick (
        keyr,
        filter2r$v3,
        filter2r$ic2eq,
        filter2r$v1,
        filter2r$a1,
        filter2r$ic1eq,
        filter2r$a2,
        filter2r$v2,
        filter2r$a3,
        filter2r$m0,
        filter2r$m1,
        filter2r$m2));
      if (lnkmix > 0.) {
        linked = std::sqrt (std::sqrt (keyl) + std::sqrt (keyr)) * lnkmix;
        keyl *= splmix;
        keyr *= splmix;
        keyl += linked;
        keyr += linked;
      }
      spl0 *= init$comptick (
        keyl,
        comp2l$gr,
        comp2l$attrel$envelope,
        comp2l$attrel$coeffatt,
        comp2l$attrel$coeffrel,
        comp2l$calc$ratio,
        comp2l$calc$knee,
        comp2l$calc$kneelower,
        comp2l$calc$kneeupper,
        comp2l$calc$threshold);
      spl1 *= init$comptick (
        keyr,
        comp2r$gr,
        comp2r$attrel$envelope,
        comp2r$attrel$coeffatt,
        comp2r$attrel$coeffrel,
        comp2r$calc$ratio,
        comp2r$calc$knee,
        comp2r$calc$kneelower,
        comp2r$calc$kneeupper,
        comp2r$calc$threshold);
      keyl = spl0;
      keyr = spl1;
      keyl = std::fabs (init$eqtick (
        keyl,
        filter3l$v3,
        filter3l$ic2eq,
        filter3l$v1,
        filter3l$a1,
        filter3l$ic1eq,
        filter3l$a2,
        filter3l$v2,
        filter3l$a3,
        filter3l$m0,
        filter3l$m1,
        filter3l$m2));
      keyr = std::fabs (init$eqtick (
        keyr,
        filter3r$v3,
        filter3r$ic2eq,
        filter3r$v1,
        filter3r$a1,
        filter3r$ic1eq,
        filter3r$a2,
        filter3r$v2,
        filter3r$a3,
        filter3r$m0,
        filter3r$m1,
        filter3r$m2));
      if (lnkmix > 0.) {
        linked = std::sqrt (std::sqrt (keyl) + std::sqrt (keyr)) * lnkmix;
        keyl *= splmix;
        keyr *= splmix;
        keyl += linked;
        keyr += linked;
      }
      spl0 *= init$comptick (
        keyl,
        comp3l$gr,
        comp3l$attrel$envelope,
        comp3l$attrel$coeffatt,
        comp3l$attrel$coeffrel,
        comp3l$calc$ratio,
        comp3l$calc$knee,
        comp3l$calc$kneelower,
        comp3l$calc$kneeupper,
        comp3l$calc$threshold);
      spl1 *= init$comptick (
        keyr,
        comp3r$gr,
        comp3r$attrel$envelope,
        comp3r$attrel$coeffatt,
        comp3r$attrel$coeffrel,
        comp3r$calc$ratio,
        comp3r$calc$knee,
        comp3r$calc$kneelower,
        comp3r$calc$kneeupper,
        comp3r$calc$threshold);
      if (eel2_eq (midside, 1.)) {
        keyl = spl0;
        keyr = spl1;
        spl0 = init$mstol (keyl, keyr);
        spl1 = init$mstor (keyl, keyr);
      }
      spl0 *= gainout;
      spl1 *= gainout;
      if (wetdry < 1.) {
        spl0 = drywet * dryl + wetdry * spl0;
        spl1 = drywet * dryr + wetdry * spl1;
      };
    }
  }
  // functions for section "init"
private:
  //----------------------------------------------------------------------------
  double init$attrelsetup (
    double  msattack,
    double  msrelease,
    double& $coeffatt,
    double& $coeffrel)
  {
    $coeffatt = std::exp (
      -1000. * init$fastreciprocal (msattack * jsfx_specialvar_get_srate()));
    $coeffrel = std::exp (
      -1000. * init$fastreciprocal (msrelease * jsfx_specialvar_get_srate()));
    return $coeffrel;
  }
  //----------------------------------------------------------------------------
  double init$attreltick (
    double  dbsample,
    double& $envelope,
    double& $coeffatt,
    double& $coeffrel)
  {
    double change = 0.;
    double above  = 0.;
    above         = (dbsample > $envelope);
    change        = $envelope - dbsample;
    $envelope     = (above * (dbsample + $coeffatt * change))
      + (!above * (dbsample + $coeffrel * change));
    return $envelope;
  }
  //----------------------------------------------------------------------------
  double init$compsetup (
    double  msattack,
    double  msrelease,
    double  dbthreshold,
    double  fullratio,
    double  dbknee,
    double& $attrel$coeffatt,
    double& $attrel$coeffrel,
    double& $calc$threshold,
    double& $calc$ratio,
    double& $calc$knee,
    double& $calc$kneewidth,
    double& $calc$kneeupper,
    double& $calc$kneelower)
  {
    init$attrelsetup (msattack, msrelease, $attrel$coeffatt, $attrel$coeffrel);
    return init$gaincalcsetup (
      dbthreshold,
      fullratio,
      dbknee,
      $calc$threshold,
      $calc$ratio,
      $calc$knee,
      $calc$kneewidth,
      $calc$kneeupper,
      $calc$kneelower);
  }
  //----------------------------------------------------------------------------
  double init$comptick (
    double  sample,
    double& $gr,
    double& $attrel$envelope,
    double& $attrel$coeffatt,
    double& $attrel$coeffrel,
    double& $calc$ratio,
    double& $calc$knee,
    double& $calc$kneelower,
    double& $calc$kneeupper,
    double& $calc$threshold)
  {
    init$attreltick (
      init$gaintodb (sample),
      $attrel$envelope,
      $attrel$coeffatt,
      $attrel$coeffrel);
    $gr = init$gaincalctick (
      $attrel$envelope,
      $calc$ratio,
      $calc$knee,
      $calc$kneelower,
      $calc$kneeupper,
      $calc$threshold);
    return $gr;
  }
  //----------------------------------------------------------------------------
  double init$dbtogain (double decibels)
  {
    return eel2_pow (10.0, (decibels / 20.0));
  }
  //----------------------------------------------------------------------------
  double init$eqhp (
    double  hz,
    double  q,
    double& $a1,
    double& $a2,
    double& $a3,
    double& $m0,
    double& $m1,
    double& $m2)
  {
    double g = 0.;
    double k = 0.;
    g        = std::tan (halfpi * (hz / jsfx_specialvar_get_srate()));
    k        = init$fastreciprocal (q);
    $a1      = init$fastreciprocal (1.0 + g * (g + k));
    $a2      = $a1 * g;
    $a3      = $a2 * g;
    $m0      = 1.0;
    $m1      = -k;
    $m2      = -1.0;
    return $m2;
  }
  //----------------------------------------------------------------------------
  double init$eqtick (
    double  sample,
    double& $v3,
    double& $ic2eq,
    double& $v1,
    double& $a1,
    double& $ic1eq,
    double& $a2,
    double& $v2,
    double& $a3,
    double& $m0,
    double& $m1,
    double& $m2)
  {
    $v3    = sample - $ic2eq;
    $v1    = $a1 * $ic1eq + $a2 * $v3;
    $v2    = $ic2eq + $a2 * $ic1eq + $a3 * $v3;
    $ic1eq = 2.0 * $v1 - $ic1eq;
    $ic2eq = 2.0 * $v2 - $ic2eq;
    return ($m0 * sample + $m1 * $v1 + $m2 * $v2);
  }
#if 1
  // Was missing, typical quake impl
  double invsqrt (double number)
  {
    double       y  = number;
    double       x2 = y * 0.5;
    std::int64_t i  = *(std::int64_t*) &y;
    // The magic number is for doubles is from
    // https://cs.uwaterloo.ca/~m32rober/rsqrt.pdf
    i = 0x5fe6eb50c7b537a9 - (i >> 1);
    y = *(double*) &i;
    y = y * (1.5 - (x2 * y * y)); // 1st iteration
    y = y * (1.5 - (x2 * y * y)); // 2nd iteration, this can be removed
    return y;
  }
#endif
  //----------------------------------------------------------------------------
  double init$fastreciprocal (double value)
  {
    double v = invsqrt (value);
    return v * v;
  }
  //----------------------------------------------------------------------------
  double init$gaincalcsetup (
    double  dbthreshold,
    double  fullratio,
    double  dbknee,
    double& $threshold,
    double& $ratio,
    double& $knee,
    double& $kneewidth,
    double& $kneeupper,
    double& $kneelower)
  {
    $threshold = dbthreshold;
    $ratio     = init$fastreciprocal (fullratio);
    $knee      = dbknee;
    $kneewidth = $knee * 0.5;
    $kneeupper = $threshold + $kneewidth;
    $kneelower = $threshold - $kneewidth;
    return $kneelower;
  }
  //----------------------------------------------------------------------------
  double init$gaincalctick (
    double  dbsample,
    double& $ratio,
    double& $knee,
    double& $kneelower,
    double& $kneeupper,
    double& $threshold)
  {
    double dbreduction = 0.;
    double slope       = 0.;
    dbreduction        = dbsample;
    slope              = 1.0 - $ratio;
    if (($knee > 0.0) && (dbsample > $kneelower) && (dbsample < $kneeupper)) {
      slope *= ((dbsample - $kneelower) / $knee) * 0.5;
      dbreduction = slope * ($kneelower - dbsample);
    }
    else {
      (dbreduction = std::min (0.0, slope * ($threshold - dbsample)));
    }
    return init$dbtogain (dbreduction);
  }
  //----------------------------------------------------------------------------
  double init$gaintodb (double floatv)
  {
    double below = 0.;
    floatv       = std::abs (floatv);
    below        = floatv < floatfloor;
    floatv       = below * floatfloor + !(below) *floatv;
    return (std::log (floatv) * m_ln10_20);
  }
  //----------------------------------------------------------------------------
  double init$lrtom (double sampleleft, double sampleright)
  {
    return (sampleleft + sampleright) * rcpsqrt2;
  }
  //----------------------------------------------------------------------------
  double init$lrtos (double sampleleft, double sampleright)
  {
    return (sampleleft - sampleright) * rcpsqrt2;
  }
  //----------------------------------------------------------------------------
  double init$mstol (double samplemid, double sampleside)
  {
    return (samplemid + sampleside) * rcpsqrt2;
  }
  //----------------------------------------------------------------------------
  double init$mstor (double samplemid, double sampleside)
  {
    return (samplemid - sampleside) * rcpsqrt2;
  }
}; /* jsfx_process */
}} // namespace artv::chokehold

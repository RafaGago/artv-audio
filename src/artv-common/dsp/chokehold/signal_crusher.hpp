#pragma once
// Generated by jsfx2cpp.py. To be manually corrected.
// includes for environment function calls
#include <algorithm>
#include <cmath>
#include <cstdlib>
#include <cstring>
#include <vector>

#include "artv-common/dsp/own/classes/plugin_context.hpp"
#include "artv-common/dsp/types.hpp"
#include "artv-common/juce/parameter_definitions.hpp"
#include "artv-common/juce/parameter_types.hpp"
#include "artv-common/misc/mp11.hpp"
#include "artv-common/misc/range.hpp"
#include "artv-common/misc/short_ints.hpp"
#include "artv-common/misc/util.hpp"

namespace artv { namespace chokehold {

class signal_crusher {
public:
  //----------------------------------------------------------------------------
  static constexpr dsp_types dsp_type  = dsp_types::distortion;
  static constexpr bus_types bus_type  = bus_types::stereo;
  static constexpr uint      n_inputs  = 1;
  static constexpr uint      n_outputs = 1;

private:
  //----------------------------------------------------------------------------

  //----------------------------------------------------------------------------
  // definitions for environment function calls
  static double eel2_eq (double lhs, double rhs)
  {
    return (double) (std::fabs (lhs - rhs) < 0.00001);
  }
  static bool   eel2_ne (double lhs, double rhs) { return !eel2_eq (lhs, rhs); }
  static double eel2_pow (double lhs, double rhs)
  {
    return std::pow (lhs, rhs);
  }

  static constexpr uint filter_states = 6;
  static constexpr uint filter_order  = 8;
  static constexpr uint filter_size   = filter_states * filter_order;
  static constexpr uint n_filters     = 4;

  std::array<float, filter_size * n_filters> heapmem;
  inline float& heap (std::size_t value) { return heapmem[value]; }
  void          heap_reset (std::size_t s)
  { /*heap_reset has to be set after manual analysis of the mem requirements*/
    std::memset (heapmem.data(), 0, heapmem.size() * sizeof heapmem[0]);
  }

  static double jsfx_rand (double maxv = 1.)
  { /* Notice that in some plugins you might require mt19937_64 or    similar.
       This is not a good random generator. */
    static constexpr double randmax = 1. / (double) RAND_MAX;
    return ((double) rand()) * randmax * maxv;
  }
  static double jsfx_sqr (double v) { return v * v; }

  //----------------------------------------------------------------------------
  // stubs for JSFX special variables

  double jsfx_specialvar_get_srate() { return plugcontext->get_sample_rate(); }

  //----------------------------------------------------------------------------
public:
#if 0
  void set_down_slider (float v)
  {
    // Original slider line: slider1:down=1<0,4,{Off,Repeat samples,Drop
    // samples,Linear interpolation,Cosine interpolation}> Downsampling Range:
    // min:0.0, max:4.0, default: 1.0, step: None
    if (v == down) {
      return;
    }
    down = v;
    slider();
  }
#else
  // Snippet for parameter boilerplate in the authors framework....
  struct down_tag {};

  void set (down_tag, int v)
  {
    // Original slider line: slider1:down=1<0,4,{Off,Repeat samples,Drop
    // samples,Linear interpolation,Cosine interpolation}> Downsampling Range:
    // min:0.0, max:4.0, default: 1.0, step: None
    if ((float) v == down) {
      return;
    }
    down = (float) v;
    slider();
  }

  static constexpr auto get_parameter (down_tag)
  {
    // Original slider line: slider1:down=1<0,4,{Off,Repeat samples,Drop
    // samples,Linear interpolation,Cosine interpolation}> Downsampling
    return choice_param (
      1,
      make_cstr_array (
        "Off",
        "Repeat Samples",
        "Drop Samples",
        "Linear Interp",
        "Cosine interp"));
  }

#endif
#if 0
  void set_dnfilt_slider (float v)
  {
    // Original slider line: slider2:dnFilt=1<0,2,{Off,Pre,Post}> Downsampling
    // filter Range: min:0.0, max:2.0, default: 1.0, step: None
    if (v == dnfilt) {
      return;
    }
    dnfilt = v;
    slider();
  }
#else
  // Snippet for parameter boilerplate in the authors framework....
  struct dnfilt_tag {};

  void set (dnfilt_tag, int v)
  {
    // Original slider line: slider2:dnFilt=1<0,2,{Off,Pre,Post}> Downsampling
    // filter Range: min:0.0, max:2.0, default: 1.0, step: None
    if ((float) v == dnfilt) {
      return;
    }
    dnfilt = (float) v;
    slider();
  }

  static constexpr auto get_parameter (dnfilt_tag)
  {
    // Original slider line: slider2:dnFilt=1<0,2,{Off,Pre,Post}> Downsampling
    // filter
    return choice_param (0, make_cstr_array ("Off", "Pre", "Post"));
  }

#endif
#if 0
  void set_up_slider (float v)
  {
    // Original slider line: slider3:up=0<0,2,{Off,Linear interpolation,Cosine
    // interpolation}> Reconstruction Range: min:0.0, max:2.0, default: 0.0,
    // step: None
    if (v == up) {
      return;
    }
    up = v;
    slider();
  }
#else
  // Snippet for parameter boilerplate in the authors framework....
  struct up_tag {};

  void set (up_tag, int v)
  {
    // Original slider line: slider3:up=0<0,2,{Off,Linear interpolation,Cosine
    // interpolation}> Reconstruction Range: min:0.0, max:2.0, default: 0.0,
    // step: None
    if ((float) v == up) {
      return;
    }
    up = (float) v;
    slider();
  }

  static constexpr auto get_parameter (up_tag)
  {
    // Original slider line: slider3:up=0<0,2,{Off,Linear interpolation,Cosine
    // interpolation}> Reconstruction
    return choice_param (
      0, make_cstr_array ("Off", "Linear Interp", "Cosine interp"));
  }

#endif
#if 0
  void set_upfilt_slider (float v)
  {
    // Original slider line: slider4:upFilt=0<0,2,{Off,Pre,Post}> Reconstruction
    // filter Range: min:0.0, max:2.0, default: 0.0, step: None
    if (v == upfilt) {
      return;
    }
    upfilt = v;
    slider();
  }
#else
  // Snippet for parameter boilerplate in the authors framework....
  struct upfilt_tag {};

  void set (upfilt_tag, int v)
  {
    // Original slider line: slider4:upFilt=0<0,2,{Off,Pre,Post}> Reconstruction
    // filter Range: min:0.0, max:2.0, default: 0.0, step: None
    if ((float) v == upfilt) {
      return;
    }
    upfilt = (float) v;
    slider();
  }

  static constexpr auto get_parameter (upfilt_tag)
  {
    // Original slider line: slider4:upFilt=0<0,2,{Off,Pre,Post}> Reconstruction
    // filter
    return choice_param (0, make_cstr_array ("Off", "Pre", "Post"));
  }

#endif
#if 0
  void set_ratio_slider (float v)
  {
    // Original slider line: slider5:ratio=20<32,1,1> Resampling factor [SR / x]
    // Range: min:32.0, max:1.0, default: 20.0, step: 1.0
    if (v == ratio) {
      return;
    }
    ratio = v;
    slider();
  }
#else
  // Snippet for parameter boilerplate in the authors framework....
  struct ratio_tag {};

  void set (ratio_tag, float v)
  {
    // Original slider line: slider5:ratio=20<32,1,1> Resampling factor [SR / x]
    // Range: min:32.0, max:1.0, default: 20.0, step: 1.0
    if (v == ratio) {
      return;
    }
    ratio = v;
    slider();
  }

  static constexpr auto get_parameter (ratio_tag)
  {
    // Original slider line: slider5:ratio=20<32,1,1> Resampling factor [SR / x]
    return float_param ("factor", 1.0, 32.0, 20.0, 1.0);
  }

#endif
#if 0
  void set_outsr_slider (float v)
  {
    // Original slider line: slider6:outSR=0<0,0,0.01> Downsampled to [Hz]
    // Range: min:0.0, max:0.0, default: 0.0, step: 0.01
    if (v == outsr) {
      return;
    }
    outsr = v;
    slider();
  }
#else
#if 0
  // Snippet for parameter boilerplate in the authors framework....
  struct outsr_tag {};

  void set (outsr_tag, float v)
  {
    // Original slider line: slider6:outSR=0<0,0,0.01> Downsampled to [Hz]
    // Range: min:0.0, max:0.0, default: 0.0, step: 0.01
    if (v == outsr) {
      return;
    }
    outsr = v;
    slider();
  }

  static constexpr auto get_parameter (outsr_tag)
  {
    // Original slider line: slider6:outSR=0<0,0,0.01> Downsampled to [Hz]
    return float_param ("", 0.0, 0.0, 0.0, 0.01);
  }
#endif
#endif
#if 0
  void set_bits_slider (float v)
  {
    // Original slider line: slider7:bits=10<0,24,0.001> Bit reduction
    // Range: min:0.0, max:24.0, default: 10.0, step: 0.001
    if (v == bits) {
      return;
    }
    bits = v;
    slider();
  }
#else
  // Snippet for parameter boilerplate in the authors framework....
  struct bits_tag {};

  void set (bits_tag, float v)
  {
    // Original slider line: slider7:bits=10<0,24,0.001> Bit reduction
    // Range: min:0.0, max:24.0, default: 10.0, step: 0.001
    if (v == bits) {
      return;
    }
    bits = v;
    slider();
  }

  static constexpr auto get_parameter (bits_tag)
  {
    // Original slider line: slider7:bits=10<0,24,0.001> Bit reduction
    return float_param ("", 0.0, 24.0, 10.0, 0.001);
  }

#endif
#if 0
  void set_dither_slider (float v)
  {
    // Original slider line: slider8:dither=100<0,100,0.01> Bit dithering [%]
    // Range: min:0.0, max:100.0, default: 100.0, step: 0.01
    if (v == dither) {
      return;
    }
    dither = v;
    slider();
  }
#else
  // Snippet for parameter boilerplate in the authors framework....
  struct dither_tag {};

  void set (dither_tag, float v)
  {
    // Original slider line: slider8:dither=100<0,100,0.01> Bit dithering [%]
    // Range: min:0.0, max:100.0, default: 100.0, step: 0.01
    if (v == dither) {
      return;
    }
    dither = v;
    slider();
  }

  static constexpr auto get_parameter (dither_tag)
  {
    // Original slider line: slider8:dither=100<0,100,0.01> Bit dithering [%]
    return float_param ("%", 0.0, 100.0, 100.0, 0.01);
  }

#endif
#if 0
  void set_blank_slider (float v)
  {
    // Original slider line: slider9:blank=1<0,1,{Off,On}> Auto blanking
    // Range: min:0.0, max:1.0, default: 1.0, step: None
    if (v == blank) {
      return;
    }
    blank = v;
    slider();
  }
#else
  // Snippet for parameter boilerplate in the authors framework....
  struct blank_tag {};

  void set (blank_tag, float v)
  {
    // Original slider line: slider9:blank=1<0,1,{Off,On}> Auto blanking
    // Range: min:0.0, max:1.0, default: 1.0, step: None
    if (v == blank) {
      return;
    }
    blank = v;
    slider();
  }

  static constexpr auto get_parameter (blank_tag)
  {
    // Original slider line: slider9:blank=1<0,1,{Off,On}> Auto blanking
    return choice_param (1, make_cstr_array ("Off", "On"));
  }

#endif
#if 0
#else
  // Snippet for parameter boilerplate in the authors framework....
  using parameters = mp_list<
    down_tag,
    dnfilt_tag,
    up_tag,
    upfilt_tag,
    ratio_tag,
#if 0
    outsr_tag,
#endif
    bits_tag,
    dither_tag,
    blank_tag>;
#endif
  //----------------------------------------------------------------------------
  // global/stateful variables for section "init"
private:
  double bits;
  double blank;
  double dither;
  double dnfilt;
  double down;
  double envautoblankr$attack;
  double envautoblankr$release;
  double evnautoblankl$attack;
  double evnautoblankl$release;
#if 0
  double outsr;
#endif
  double ratio;
  double up;
  double upfilt;
  //----------------------------------------------------------------------------
  void init_init_variables()
  {
    bits                  = 0;
    blank                 = 0;
    dither                = 0;
    dnfilt                = 0;
    down                  = 0;
    envautoblankr$attack  = 0;
    envautoblankr$release = 0;
    evnautoblankl$attack  = 0;
    evnautoblankl$release = 0;
#if 0
    outsr                 = 0;
#endif
    ratio  = 0;
    up     = 0;
    upfilt = 0;
  }
  //----------------------------------------------------------------------------
  // global/stateful variables for section "slider"
private:
  double bitslevel;
  double ditherlevel;
  double lpdownl$a;
  double lpdownl$d1;
  double lpdownl$d2;
  double lpdownl$stack;
  double lpdownl$w0;
  double lpdownl$w1;
  double lpdownl$w2;
  double lpdownr$a;
  double lpdownr$d1;
  double lpdownr$d2;
  double lpdownr$stack;
  double lpdownr$w0;
  double lpdownr$w1;
  double lpdownr$w2;
  double lpupl$a;
  double lpupl$d1;
  double lpupl$d2;
  double lpupl$stack;
  double lpupl$w0;
  double lpupl$w1;
  double lpupl$w2;
  double lpupr$a;
  double lpupr$d1;
  double lpupr$d2;
  double lpupr$stack;
  double lpupr$w0;
  double lpupr$w1;
  double lpupr$w2;
  double spl0$counterds;
  double spl0$counterus;
  double spl0$laststateus;
  double spl0$thisstateus;
  double spl1$counterds;
  double spl1$counterus;
  double spl1$laststateus;
  double spl1$thisstateus;
  //----------------------------------------------------------------------------
  void init_slider_variables()
  {
    bitslevel        = 0;
    ditherlevel      = 0;
    lpdownl$a        = 0;
    lpdownl$d1       = 0;
    lpdownl$d2       = 0;
    lpdownl$stack    = 0;
    lpdownl$w0       = 0;
    lpdownl$w1       = 0;
    lpdownl$w2       = 0;
    lpdownr$a        = 0;
    lpdownr$d1       = 0;
    lpdownr$d2       = 0;
    lpdownr$stack    = 0;
    lpdownr$w0       = 0;
    lpdownr$w1       = 0;
    lpdownr$w2       = 0;
    lpupl$a          = 0;
    lpupl$d1         = 0;
    lpupl$d2         = 0;
    lpupl$stack      = 0;
    lpupl$w0         = 0;
    lpupl$w1         = 0;
    lpupl$w2         = 0;
    lpupr$a          = 0;
    lpupr$d1         = 0;
    lpupr$d2         = 0;
    lpupr$stack      = 0;
    lpupr$w0         = 0;
    lpupr$w1         = 0;
    lpupr$w2         = 0;
    spl0$counterds   = 0;
    spl0$counterus   = 0;
    spl0$laststateus = 0;
    spl0$thisstateus = 0;
    spl1$counterds   = 0;
    spl1$counterus   = 0;
    spl1$laststateus = 0;
    spl1$thisstateus = 0;
  }
  //----------------------------------------------------------------------------
  // global/stateful variables for section "block"
private:
  double envautoblankl$attack;
  double envautoblankl$envelope;
  double envautoblankl$release;
  double envautoblankr$envelope;
  double spl0$laststateds;
  double spl0$statein;
  double spl0$stateout;
  double spl0$thisstateds;
  double spl1$laststateds;
  double spl1$statein;
  double spl1$stateout;
  double spl1$thisstateds;
  //----------------------------------------------------------------------------
  void init_block_variables()
  {
    envautoblankl$attack   = 0;
    envautoblankl$envelope = 0;
    envautoblankl$release  = 0;
    envautoblankr$envelope = 0;
    spl0$laststateds       = 0;
    spl0$statein           = 0;
    spl0$stateout          = 0;
    spl0$thisstateds       = 0;
    spl1$laststateds       = 0;
    spl1$statein           = 0;
    spl1$stateout          = 0;
    spl1$thisstateds       = 0;
  }
  //----------------------------------------------------------------------------
  plugin_context* plugcontext;

public:
  void reset (plugin_context& pc)
  {
    plugcontext = &pc;
    init_init_variables();
    init_block_variables();
    init_slider_variables();

    heap_reset (filter_size * n_filters);

    down   = 1.0;
    dnfilt = 1.0;
    up     = 0.0;
    upfilt = 0.0;
    ratio  = 20.0;
#if 0
    outsr  = 0.0;
#endif
    bits   = 10.0;
    dither = 100.0;
    blank  = 1.0;

    init$envsetup (10., 300., evnautoblankl$attack, evnautoblankl$release);
    init$envsetup (10., 300., envautoblankr$attack, envautoblankr$release);
    slider();
  }
  //----------------------------------------------------------------------------
private:
  void slider()
  {
    double downfiltercutoff = 0.;
    double spl0$stateds     = 0.;
    double spl1$stateds     = 0.;
    double upfiltercutoff   = 0.;
#if 0
    outsr                   = jsfx_specialvar_get_srate() / ratio;
#else
    double outsr = jsfx_specialvar_get_srate() / ratio;
#endif
    spl0$thisstateus = 0.;
    spl0$laststateus = spl0$thisstateus;
    spl0$counterus   = spl0$laststateus;
    spl0$stateds     = spl0$counterus;
    spl0$counterds   = spl0$stateds;
    spl1$thisstateus = 0.;
    spl1$laststateus = spl1$thisstateus;
    spl1$counterus   = spl1$laststateus;
    spl1$stateds     = spl1$counterus;
    spl1$counterds   = spl1$stateds;
    bitslevel        = 1.0 / eel2_pow (2.0, bits);
    ditherlevel      = dither * 0.01;
    downfiltercutoff = std::min (outsr / 2., 20000.);
    upfiltercutoff   = std::min (outsr / 2., 20000.);
    init$bwlp (
      downfiltercutoff,
#if 0
      8.,
      101000.,
#else
      (double) filter_order,
      (double) (0 * filter_size),
#endif
      lpdownl$a,
      lpdownl$d1,
      lpdownl$d2,
      lpdownl$w0,
      lpdownl$w1,
      lpdownl$w2,
      lpdownl$stack);
    init$bwlp (
      downfiltercutoff,
#if 0
      8.,
      102000.,
#else
      (double) filter_order,
      (double) (1 * filter_size),
#endif
      lpdownr$a,
      lpdownr$d1,
      lpdownr$d2,
      lpdownr$w0,
      lpdownr$w1,
      lpdownr$w2,
      lpdownr$stack);
    init$bwlp (
      upfiltercutoff,
#if 0
      8.,
      103000.,
#else
      (double) filter_order,
      (double) (2 * filter_size),
#endif
      lpupl$a,
      lpupl$d1,
      lpupl$d2,
      lpupl$w0,
      lpupl$w1,
      lpupl$w2,
      lpupl$stack);
    init$bwlp (
      upfiltercutoff,
#if 0
      8.,
      104000.,
#else
      (double) filter_order,
      (double) (3 * filter_size),
#endif
      lpupr$a,
      lpupr$d1,
      lpupr$d2,
      lpupr$w0,
      lpupr$w1,
      lpupr$w2,
      lpupr$stack);
    ;
  }
  //----------------------------------------------------------------------------
public:
  template <class T>
  void process (crange<T*> outs, crange<T const*> ins, uint samples)
  {
    assert (outs.size() >= (n_outputs * (uint) bus_type));
    assert (ins.size() >= (n_inputs * (uint) bus_type));

    auto up_cp     = up;
    auto down_cp   = down;
    auto dnfilt_cp = dnfilt;
    auto dn_cp     = down;
    auto upfilt_cp = upfilt;
    auto blank_cp  = blank;
    auto bits_cp   = bits;

    for (uint $$i = 0; $$i < samples; ++$$i) {
      auto& spl0 = outs[0][$$i];
      auto& spl1 = outs[1][$$i];
      spl0       = ins[0][$$i];
      spl1       = ins[1][$$i];

      init$envfollow (
        eel2_ne (spl0, 0.),
        envautoblankl$envelope,
        envautoblankl$attack,
        envautoblankl$release);
      init$envfollow (
        eel2_ne (spl1, 0.),
        envautoblankr$envelope,
        envautoblankr$attack,
        envautoblankr$release);
      if ((down_cp > 0.)) {
        if (eel2_eq (dnfilt_cp, 1.)) {
          spl0 = init$bwtick (
            spl0,
            lpdownl$stack,
            lpdownl$w0,
            lpdownl$d1,
            lpdownl$w1,
            lpdownl$d2,
            lpdownl$w2,
            lpdownl$a);
          spl1 = init$bwtick (
            spl1,
            lpdownr$stack,
            lpdownr$w0,
            lpdownr$d1,
            lpdownr$w1,
            lpdownr$d2,
            lpdownr$w2,
            lpdownr$a);
        }
        init$downsample (
          spl0$counterds, spl0$laststateds, spl0$thisstateds, spl0);
        init$downsample (
          spl1$counterds, spl1$laststateds, spl1$thisstateds, spl1);
        if (eel2_eq (dnfilt_cp, 2.)) {
          spl0 = init$bwtick (
            spl0,
            lpdownl$stack,
            lpdownl$w0,
            lpdownl$d1,
            lpdownl$w1,
            lpdownl$d2,
            lpdownl$w2,
            lpdownl$a);
          spl1 = init$bwtick (
            spl1,
            lpdownr$stack,
            lpdownr$w0,
            lpdownr$d1,
            lpdownr$w1,
            lpdownr$d2,
            lpdownr$w2,
            lpdownr$a);
        }
      }
      if ((up_cp > 0.)) {
        if (eel2_eq (upfilt_cp, 1.)) {
          spl0 = init$bwtick (
            spl0,
            lpupl$stack,
            lpupl$w0,
            lpupl$d1,
            lpupl$w1,
            lpupl$d2,
            lpupl$w2,
            lpupl$a);
          spl1 = init$bwtick (
            spl1,
            lpupr$stack,
            lpupr$w0,
            lpupr$d1,
            lpupr$w1,
            lpupr$d2,
            lpupr$w2,
            lpupr$a);
        }
        init$upsample (
          spl0$counterus, spl0$laststateus, spl0$thisstateus, spl0);
        init$upsample (
          spl1$counterus, spl1$laststateus, spl1$thisstateus, spl1);
        if (eel2_eq (upfilt_cp, 2.)) {
          spl0 = init$bwtick (
            spl0,
            lpupl$stack,
            lpupl$w0,
            lpupl$d1,
            lpupl$w1,
            lpupl$d2,
            lpupl$w2,
            lpupl$a);
          spl1 = init$bwtick (
            spl1,
            lpupr$stack,
            lpupr$w0,
            lpupr$d1,
            lpupr$w1,
            lpupr$d2,
            lpupr$w2,
            lpupr$a);
        }
      }
      if ((bits_cp < 24.)) {
        init$bitreduce (spl0);
        init$bitreduce (spl1);
        init$dithernoise (
          [&] {
            if (eel2_eq (blank_cp, 1.)) {
              return envautoblankl$envelope;
            }
            else {
              return 1.;
            }
          }(),
          spl0);
        init$dithernoise (
          [&] {
            if (eel2_eq (blank_cp, 1.)) {
              return envautoblankr$envelope;
            }
            else {
              return 1.;
            }
          }(),
          spl1);
      }
      init$dcblocker (spl0$stateout, spl0, spl0$statein);
      init$dcblocker (spl1$stateout, spl1, spl1$statein);
      init$clamp (1., spl0);
      init$clamp (1., spl1);
      ;
    }
  }
  // functions for section "init"
private:
  //----------------------------------------------------------------------------
  template <class T>
  T init$bitreduce (T& this$)
  {
    this$ = [&] {
      if ((std::abs (this$) < bitslevel)) {
        return (T) 0.;
      }
      else {
        return this$;
      }
    }();
    return this$;
  }
  //----------------------------------------------------------------------------
  double init$bwlp (
    double  hz,
    double  order,
    double  memoffset,
    double& $a,
    double& $d1,
    double& $d2,
    double& $w0,
    double& $w1,
    double& $w2,
    double& $stack)
  {
    double ar   = 0.;
    double a2   = 0.;
    double step = 0.;
    double rs2  = 0.;
    double a1   = 0.;
    double r    = 0.;
    double s2   = 0.;
    double ar2  = 0.;
    double ro4  = 0.;
    $a          = memoffset;
    $d1         = $a + order;
    $d2         = $d1 + order;
    $w0         = $d2 + order;
    $w1         = $w0 + order;
    $w2         = $w1 + order;
    $stack      = order;
    a1   = std::tan (3.141592653589793 * (hz / jsfx_specialvar_get_srate()));
    a2   = jsfx_sqr (a1);
    ro4  = 1.0 / (4.0 * order);
    step = 0.;
    return [&] {
      double $loop_ret_0 = {};
      while (step < order) {
        r   = std::sin (3.141592653589793 * (2.0 * step + 1.0) * ro4);
        ar2 = 2.0 * a1 * r;
        s2  = a2 + ar2 + 1.0;
        rs2 = 1.0 / s2;
        heap ($a + step)  = a2 * rs2;
        heap ($d1 + step) = 2.0 * (1.0 - a2) * rs2;
        heap ($d2 + step) = -(a2 - ar2 + 1.0) * rs2;
        step += 1.;
        $loop_ret_0 = step;
      }
      return $loop_ret_0;
    }();
  }
  //----------------------------------------------------------------------------
  double init$bwtick (
    double  sample,
    double& $stack,
    double& $w0,
    double& $d1,
    double& $w1,
    double& $d2,
    double& $w2,
    double& $a)
  {
    double output = 0.;
    double step   = 0.;
    output        = sample;
    step          = 0.;
    while (step < $stack) {
      heap ($w0 + step) = heap ($d1 + step) * heap ($w1 + step)
        + heap ($d2 + step) * heap ($w2 + step) + output;
      output = heap ($a + step)
        * (heap ($w0 + step) + 2.0 * heap ($w1 + step) + heap ($w2 + step));
      heap ($w2 + step) = heap ($w1 + step);
      heap ($w1 + step) = heap ($w0 + step);
      step += 1.;
    }
    return output;
  }
  //----------------------------------------------------------------------------
  template <class T>
  T init$clamp (double ceiling, T& this$)
  {
    this$ = std::max<T> (-ceiling, std::min<T> (ceiling, this$));
    return this$;
  }
  //----------------------------------------------------------------------------
  double init$cosineinterpolation (double y1, double y2, double mu)
  {
    double mu2 = 0.;
    mu2        = (1. - std::cos (mu * 3.141592653589793)) * 0.5;
    return (y1 * (1. - mu2) + y2 * mu2);
  }
  //----------------------------------------------------------------------------
  template <class T>
  T init$dcblocker (double& $stateout, T& this$, double& $statein)
  {
    $stateout *= 0.99988487;
    $stateout += this$ - $statein;
    $statein = this$;
    this$    = $stateout;
    return this$;
  }
  //----------------------------------------------------------------------------
  template <class T>
  T init$dithernoise (double envelope, T& this$)
  {
    this$ += envelope * ditherlevel * bitslevel * init$random (1.);
    return this$;
  }
  //----------------------------------------------------------------------------
  template <class T>
  T init$downsample (
    double& $counterds,
    double& $laststateds,
    double& $thisstateds,
    T&      this$)
  {
    $counterds += 1.;
    if (($counterds > ratio) || eel2_eq ($counterds, 1.)) {
      $laststateds = $thisstateds;
      $thisstateds = this$;
      $counterds   = 1.;
    }
    else {
      if (eel2_eq (down, 1.)) {
        (this$ = $thisstateds);
      }
      if (eel2_eq (down, 2.)) {
        (this$ = 0.);
      }
      if (eel2_eq (down, 3.)) {
        (this$ = init$linearinterpolation (
           $laststateds, $thisstateds, $counterds / ratio));
      }
      if (eel2_eq (down, 4.)) {
        (this$ = init$cosineinterpolation (
           $laststateds, $thisstateds, $counterds / ratio));
      }
    }
    return [&] {
      if (eel2_eq (down, 2.)) {
        this$ *= 1.0 + eel2_eq (down, 2.) / ratio;
        return this$;
      }
      else {
        return 0.f;
      }
    }();
  }
  //----------------------------------------------------------------------------
  double init$envfollow (
    double  sample,
    double& $envelope,
    double& $attack,
    double& $release)
  {
    double absolute = 0.;
    absolute        = std::abs (sample);
    $envelope =
      [&] {
        if ((absolute > $envelope)) {
          return $attack;
        }
        else {
          return $release;
        }
      }()
        * ($envelope - absolute)
      + absolute;
    return $envelope;
  }
  //----------------------------------------------------------------------------
  double init$envsetup (
    double  msattack,
    double  msrelease,
    double& $attack,
    double& $release)
  {
    $attack
      = std::pow (0.01, 1.0 / (msattack * jsfx_specialvar_get_srate() * 0.001));
    $release = std::pow (
      0.01, 1.0 / (msrelease * jsfx_specialvar_get_srate() * 0.001));
    return $release;
  }
  //----------------------------------------------------------------------------
  double init$linearinterpolation (double y1, double y2, double mu)
  {
    return (y1 * (1.0 - mu) + y2 * mu);
  }
  //----------------------------------------------------------------------------
  double init$random (double limit)
  {
    return jsfx_rand() * 2.0 * limit - limit;
  }
  //----------------------------------------------------------------------------
  template <class T>
  double init$upsample (
    double& $counterus,
    double& $laststateus,
    double& $thisstateus,
    T&      this$)
  {
    $counterus += 1.;
    return [&] {
      if (($counterus > ratio) || eel2_eq ($counterus, 1.)) {
        $laststateus = $thisstateus;
        $thisstateus = this$;
        $counterus   = 1.;
        return $counterus;
      }
      else {
        if (eel2_eq (up, 1.)) {
          this$ = init$linearinterpolation (
            $laststateus, $thisstateus, $counterus / ratio);
        }
        return [&] {
          if (eel2_eq (up, 2.)) {
            this$ = init$cosineinterpolation (
              $laststateus, $thisstateus, $counterus / ratio);
            return (double) this$;
          }
          else {
            return 0.;
          }
        }();
      }
    }();
  }
}; /* jsfx_process */
}} // namespace artv::chokehold

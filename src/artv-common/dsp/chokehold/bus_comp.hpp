#pragma once
// Generated by jsfx2cpp.py. To be manually corrected.
// includes for environment function calls
#include <algorithm>
#include <cmath>
#include <cstdint>
#include <cstdlib>
#include <cstring>
#include <vector>

#include "artv-common/dsp/jsfx_engine/jsfx_engine.hpp"
#include "artv-common/dsp/own/classes/misc.hpp"
#include "artv-common/dsp/own/classes/plugin_context.hpp"
#include "artv-common/dsp/types.hpp"
#include "artv-common/juce/parameter_definitions.hpp"
#include "artv-common/juce/parameter_types.hpp"
#include "artv-common/misc/mp11.hpp"
#include "artv-common/misc/short_ints.hpp"
#include "artv-common/misc/util.hpp"

#error "Untested!"

namespace artv { namespace chokehold {

class bus_comp {
public:
  static constexpr dsp_types dsp_type = dsp_types::dynamics;
  //----------------------------------------------------------------------------
private:
  //----------------------------------------------------------------------------
  // definitions for environment function calls
  static double eel2_eq (double lhs, double rhs)
  {
    return (double) (std::fabs (lhs - rhs) < 0.00001);
  }
  static bool   eel2_ne (double lhs, double rhs) { return !eel2_eq (lhs, rhs); }
  static double eel2_pow (double lhs, double rhs)
  {
    return std::pow (lhs, rhs);
  }
  std::vector<float> heapmem;
  inline float&      heap (std::size_t value) { return heapmem[value]; }
  void               heap_reset (std::size_t s)
  { /*heap_reset has to be set after manual analysis of the mem requirements*/
    heapmem.resize (s);
    std::memset (heapmem.data(), 0, heapmem.size() * sizeof heapmem[0]);
  }
  static double jsfx_invsqrt (double v)
  {
    double       y  = v;
    double       x2 = y * 0.5;
    std::int64_t i
      = *(std::int64_t*) &y; /* The magic number is for doubles is from
                                https://cs.uwaterloo.ca/~m32rober/rsqrt.pdf */
    i = 0x5fe6eb50c7b537a9 - (i >> 1);
    y = *(double*) &i;
    y = y * (1.5 - (x2 * y * y));
    y = y * (1.5 - (x2 * y * y));
    return y;
  }
  static double jsfx_rand (double maxv = 1.)
  { /* Notice that in some plugins you might require mt19937_64 or    similar.
       This is not a good random generator. */
    static constexpr double randmax = 1. / (double) RAND_MAX;
    return ((double) rand()) * randmax * maxv;
  }
  double jsfx_sign (double value)
  {
    auto v = *((uint64_t*) ((void*) &value));
    return (v == 0) ? 0. : (v & (1ull << 63)) ? -1. : 1.;
  }
  static double jsfx_sqr (double v) { return v * v; }

  //----------------------------------------------------------------------------
  double jsfx_specialvar_get_srate() { return plugcontext->get_sample_rate(); }

  //----------------------------------------------------------------------------
public:
#if 0
  void set_dbgain_slider (float v)
  {
    // Original slider line: slider1: dBGain=0<-12, 12, 0.01>Input gain [dB]
    // Range: min:-12.0, max:12.0, default: 0.0, step: 0.01
    if (v == dbgain) {
      return;
    }
    dbgain = v;
    slider();
  }
#else
  // Snippet for parameter boilerplate in the authors framework....
  struct dbgain_tag {};

  void set (dbgain_tag, float v)
  {
    // Original slider line: slider1: dBGain=0<-12, 12, 0.01>Input gain [dB]
    // Range: min:-12.0, max:12.0, default: 0.0, step: 0.01
    if (v == dbgain) {
      return;
    }
    dbgain = v;
    slider();
  }

  static constexpr auto get_parameter (dbgain_tag)
  {
    // Original slider line: slider1: dBGain=0<-12, 12, 0.01>Input gain [dB]
    return float_param ("dB", -12.0, 12.0, 0.0, 0.01);
  }

#endif
#if 0
  void set_compthresh_slider (float v)
  {
    // Original slider line: slider2: compThresh=0<-60, 0, 0.01>Threshold [dB]
    // Range: min:-60.0, max:0.0, default: 0.0, step: 0.01
    if (v == compthresh) {
      return;
    }
    compthresh = v;
    slider();
  }
#else
  // Snippet for parameter boilerplate in the authors framework....
  struct compthresh_tag {};

  void set (compthresh_tag, float v)
  {
    // Original slider line: slider2: compThresh=0<-60, 0, 0.01>Threshold [dB]
    // Range: min:-60.0, max:0.0, default: 0.0, step: 0.01
    if (v == compthresh) {
      return;
    }
    compthresh = v;
    slider();
  }

  static constexpr auto get_parameter (compthresh_tag)
  {
    // Original slider line: slider2: compThresh=0<-60, 0, 0.01>Threshold [dB]
    return float_param ("dB", -60.0, 0.0, 0.0, 0.01);
  }

#endif
#if 0
  void set_rawratio_slider (float v)
  {
    // Original slider line: slider3: rawRatio=3<0, 6, {1.5,2,3,4,5,10,20}>Ratio
    // Range: min:0.0, max:6.0, default: 3.0, step: None
    if (v == rawratio) {
      return;
    }
    rawratio = v;
    slider();
  }
#else
  // Snippet for parameter boilerplate in the authors framework....
  struct rawratio_tag {};

  void set (rawratio_tag, int v)
  {
    // Original slider line: slider3: rawRatio=3<0, 6, {1.5,2,3,4,5,10,20}>Ratio
    // Range: min:0.0, max:6.0, default: 3.0, step: None
    if ((float) v == rawratio) {
      return;
    }
    rawratio = (float) v;
    slider();
  }

  static constexpr auto get_parameter (rawratio_tag)
  {
    // Original slider line: slider3: rawRatio=3<0, 6, {1.5,2,3,4,5,10,20}>Ratio
    return choice_param (
      0, make_cstr_array ("1:1.5", "1:2", "1:3", "1:4", "1:5", "1:10", "1:20"));
  }

#endif
#if 0
  void set_rawattack_slider (float v)
  {
    // Original slider line: slider4: rawAttack=4<0, 5,
    // {0.1,0.3,1,3,10,30}>Attack [ms] Range: min:0.0, max:5.0, default: 4.0,
    // step: None
    if (v == rawattack) {
      return;
    }
    rawattack = v;
    slider();
  }
#else
  // Snippet for parameter boilerplate in the authors framework....
  struct rawattack_tag {};

  void set (rawattack_tag, float v)
  {
    // Original slider line: slider4: rawAttack=4<0, 5,
    // {0.1,0.3,1,3,10,30}>Attack [ms] Range: min:0.0, max:5.0, default: 4.0,
    // step: None
    if (v == rawattack) {
      return;
    }
    rawattack = v;
    slider();
  }

  static constexpr auto get_parameter (rawattack_tag)
  {
    // Original slider line: slider4: rawAttack=4<0, 5,
    // {0.1,0.3,1,3,10,30}>Attack [ms]
    return float_param ("ms", 0.0, 5.0, 4.0, 0.001);
  }

#endif
#if 0
  void set_rawrelease_slider (float v)
  {
    // Original slider line: slider5: rawRelease=6<0, 6,
    // {0.1,0.2,0.4,0.8,1.6,3.2,Auto}>Release [s] Range: min:0.0, max:6.0,
    // default: 6.0, step: None
    if (v == rawrelease) {
      return;
    }
    rawrelease = v;
    slider();
  }
#else
  // Snippet for parameter boilerplate in the authors framework....
  struct rawrelease_tag {};

  void set (rawrelease_tag, float v)
  {
    // Original slider line: slider5: rawRelease=6<0, 6,
    // {0.1,0.2,0.4,0.8,1.6,3.2,Auto}>Release [s] Range: min:0.0, max:6.0,
    // default: 6.0, step: None
    if (v == rawrelease) {
      return;
    }
    rawrelease = v;
    slider();
  }

  static constexpr auto get_parameter (rawrelease_tag)
  {
    // Original slider line: slider5: rawRelease=6<0, 6,
    // {0.1,0.2,0.4,0.8,1.6,3.2,Auto}>Release [s]
    return float_param ("ms", 0.0, 6.0, 6.0, 0.001);
  }

#endif
#if 0
  void set_sidechain_slider (float v)
  {
    // Original slider line: slider6: sidechain=0<0, 1, {Internal (inputs
    // 1+2),External (inputs 3+4)}>Sidechain Range: min:0.0, max:1.0, default:
    // 0.0, step: None
    if (v == sidechain) {
      return;
    }
    sidechain = v;
    slider();
  }
#else
  // Snippet for parameter boilerplate in the authors framework....
  struct sidechain_tag {};

  void set (sidechain_tag, float v)
  {
    // Original slider line: slider6: sidechain=0<0, 1, {Internal (inputs
    // 1+2),External (inputs 3+4)}>Sidechain Range: min:0.0, max:1.0, default:
    // 0.0, step: None
    if (v == sidechain) {
      return;
    }
    sidechain = v;
    slider();
  }

  static constexpr auto get_parameter (sidechain_tag)
  {
    // Original slider line: slider6: sidechain=0<0, 1, {Internal (inputs
    // 1+2),External (inputs 3+4)}>Sidechain
    return float_param ("", 0.0, 1.0, 0.0);
  }

#endif
#if 0
  void set_scfreq_slider (float v)
  {
    // Original slider line: slider7: scFreq=75<20, 500, 1>SC high pass [Hz]
    // Range: min:20.0, max:500.0, default: 75.0, step: 1.0
    if (v == scfreq) {
      return;
    }
    scfreq = v;
    slider();
  }
#else
  // Snippet for parameter boilerplate in the authors framework....
  struct scfreq_tag {};

  void set (scfreq_tag, float v)
  {
    // Original slider line: slider7: scFreq=75<20, 500, 1>SC high pass [Hz]
    // Range: min:20.0, max:500.0, default: 75.0, step: 1.0
    if (v == scfreq) {
      return;
    }
    scfreq = v;
    slider();
  }

  static constexpr auto get_parameter (scfreq_tag)
  {
    // Original slider line: slider7: scFreq=75<20, 500, 1>SC high pass [Hz]
    return float_param ("Hz", 20.0, 500.0, 75.0, 1.0);
  }

#endif
#if 0
  void set_midside_slider (float v)
  {
    // Original slider line: slider8: midSide=0<0,1,{Stereo (L+R),Mid/Side
    // (M+S)}>Channel routing Range: min:0.0, max:1.0, default: 0.0, step: None
    if (v == midside) {
      return;
    }
    midside = v;
    slider();
  }
#else
  // Snippet for parameter boilerplate in the authors framework....
  struct midside_tag {};

  void set (midside_tag, int v)
  {
    // Original slider line: slider8: midSide=0<0,1,{Stereo (L+R),Mid/Side
    // (M+S)}>Channel routing Range: min:0.0, max:1.0, default: 0.0, step: None
    if ((float) v == midside) {
      return;
    }
    midside = (float) v;
    slider();
  }

  static constexpr auto get_parameter (midside_tag)
  {
    // Original slider line: slider8: midSide=0<0,1,{Stereo (L+R),Mid/Side
    // (M+S)}>Channel routing
    return choice_param (0, make_cstr_array ("Stereo", "Mid/Side"), 8);
  }

#endif
#if 0
  void set_linkamount_slider (float v)
  {
    // Original slider line: slider9: linkAmount=100<0, 100, 1>Stereo link [%]
    // Range: min:0.0, max:100.0, default: 100.0, step: 1.0
    if (v == linkamount) {
      return;
    }
    linkamount = v;
    slider();
  }
#else
  // Snippet for parameter boilerplate in the authors framework....
  struct linkamount_tag {};

  void set (linkamount_tag, float v)
  {
    // Original slider line: slider9: linkAmount=100<0, 100, 1>Stereo link [%]
    // Range: min:0.0, max:100.0, default: 100.0, step: 1.0
    if (v == linkamount) {
      return;
    }
    linkamount = v;
    slider();
  }

  static constexpr auto get_parameter (linkamount_tag)
  {
    // Original slider line: slider9: linkAmount=100<0, 100, 1>Stereo link [%]
    return float_param ("%", 0.0, 100.0, 100.0, 1.0);
  }

#endif
#if 0
  void set_instability_slider (float v)
  {
    // Original slider line: slider10:instability=100<0,100,0.01>Instability [%]
    // Range: min:0.0, max:100.0, default: 100.0, step: 0.01
    if (v == instability) {
      return;
    }
    instability = v;
    slider();
  }
#else
  // Snippet for parameter boilerplate in the authors framework....
  struct instability_tag {};

  void set (instability_tag, float v)
  {
    // Original slider line: slider10:instability=100<0,100,0.01>Instability [%]
    // Range: min:0.0, max:100.0, default: 100.0, step: 0.01
    if (v == instability) {
      return;
    }
    instability = v;
    slider();
  }

  static constexpr auto get_parameter (instability_tag)
  {
    // Original slider line: slider10:instability=100<0,100,0.01>Instability [%]
    return float_param ("%", 0.0, 100.0, 100.0, 0.01);
  }

#endif
#if 0
  void set_saturation_slider (float v)
  {
    // Original slider line: slider11:saturation=100<0,100,0.01>Saturation [%]
    // Range: min:0.0, max:100.0, default: 100.0, step: 0.01
    if (v == saturation) {
      return;
    }
    saturation = v;
    slider();
  }
#else
  // Snippet for parameter boilerplate in the authors framework....
  struct saturation_tag {};

  void set (saturation_tag, float v)
  {
    // Original slider line: slider11:saturation=100<0,100,0.01>Saturation [%]
    // Range: min:0.0, max:100.0, default: 100.0, step: 0.01
    if (v == saturation) {
      return;
    }
    saturation = v;
    slider();
  }

  static constexpr auto get_parameter (saturation_tag)
  {
    // Original slider line: slider11:saturation=100<0,100,0.01>Saturation [%]
    return float_param ("%", 0.0, 100.0, 100.0, 0.01);
  }

#endif
#if 0
  void set_dbtrim_slider (float v)
  {
    // Original slider line: slider12:dBTrim=0<-24, 24, 0.01>Makeup gain [dB]
    // Range: min:-24.0, max:24.0, default: 0.0, step: 0.01
    if (v == dbtrim) {
      return;
    }
    dbtrim = v;
    slider();
  }
#else
  // Snippet for parameter boilerplate in the authors framework....
  struct dbtrim_tag {};

  void set (dbtrim_tag, float v)
  {
    // Original slider line: slider12:dBTrim=0<-24, 24, 0.01>Makeup gain [dB]
    // Range: min:-24.0, max:24.0, default: 0.0, step: 0.01
    if (v == dbtrim) {
      return;
    }
    dbtrim = v;
    slider();
  }

  static constexpr auto get_parameter (dbtrim_tag)
  {
    // Original slider line: slider12:dBTrim=0<-24, 24, 0.01>Makeup gain [dB]
    return float_param ("dB", -24.0, 24.0, 0.0, 0.01);
  }

#endif
#if 0
  void set_clip_slider (float v)
  {
    // Original slider line: slider13:clip=0<0,1,{Disabled,Hard clip 0
    // dBfs}>Clip output Range: min:0.0, max:1.0, default: 0.0, step: None
    if (v == clip) {
      return;
    }
    clip = v;
    slider();
  }
#else
  // Snippet for parameter boilerplate in the authors framework....
  struct clip_tag {};

  void set (clip_tag, int v)
  {
    // Original slider line: slider13:clip=0<0,1,{Disabled,Hard clip 0
    // dBfs}>Clip output Range: min:0.0, max:1.0, default: 0.0, step: None
    if ((float) v == clip) {
      return;
    }
    clip = (float) v;
    slider();
  }

  static constexpr auto get_parameter (clip_tag)
  {
    // Original slider line: slider13:clip=0<0,1,{Disabled,Hard clip 0
    // dBfs}>Clip output
    return choice_param (0, make_cstr_array ("No Clip", "Hard Clip"), 8);
  }

#endif
#if 0
  void set_pctmix_slider (float v)
  {
    // Original slider line: slider14:pctMix=100<0,100,0.01>Dry/wet mix [%]
    // Range: min:0.0, max:100.0, default: 100.0, step: 0.01
    if (v == pctmix) {
      return;
    }
    pctmix = v;
    slider();
  }
#else
  // Snippet for parameter boilerplate in the authors framework....
  struct pctmix_tag {};

  void set (pctmix_tag, float v)
  {
    // Original slider line: slider14:pctMix=100<0,100,0.01>Dry/wet mix [%]
    // Range: min:0.0, max:100.0, default: 100.0, step: 0.01
    if (v == pctmix) {
      return;
    }
    pctmix = v;
    slider();
  }

  static constexpr auto get_parameter (pctmix_tag)
  {
    // Original slider line: slider14:pctMix=100<0,100,0.01>Dry/wet mix [%]
    return float_param ("%", 0.0, 100.0, 100.0, 0.01);
  }

#endif
#if 0
#else
  // Snippet for parameter boilerplate in the authors framework....
  using parameters = mp11::mp_list<
    dbgain_tag,
    compthresh_tag,
    rawratio_tag,
    rawattack_tag,
    rawrelease_tag,
    sidechain_tag,
    scfreq_tag,
    midside_tag,
    linkamount_tag,
    instability_tag,
    saturation_tag,
    dbtrim_tag,
    clip_tag,
    pctmix_tag>;
#endif
  //----------------------------------------------------------------------------
  // global/stateful variables for section "init"
private:
  double clip;
  double compfeedback;
  double compthresh;
  double dbgain;
  double dbtrim;
  double floatfloor;
  double halfpi;
  double instability;
  double linkamount;
  double m_ln10_20;
  double midside;
  double noise;
  double noisefloor;
  double noisestate;
  double pctmix;
  double rawattack;
  double rawratio;
  double rawrelease;
  double rcpsqrt2;
  double satl$satenv$coeff;
  double satr$satenv$coeff;
  double satspeed;
  double saturation;
  double scfreq;
  double sidechain;
  //----------------------------------------------------------------------------
  void init_init_variables()
  {
    clip              = 0;
    compfeedback      = 0;
    compthresh        = 0;
    dbgain            = 0;
    dbtrim            = 0;
    floatfloor        = 0;
    halfpi            = 0;
    instability       = 0;
    linkamount        = 0;
    m_ln10_20         = 0;
    midside           = 0;
    noise             = 0;
    noisefloor        = 0;
    noisestate        = 0;
    pctmix            = 0;
    rawattack         = 0;
    rawratio          = 0;
    rawrelease        = 0;
    rcpsqrt2          = 0;
    satl$satenv$coeff = 0;
    satr$satenv$coeff = 0;
    satspeed          = 0;
    saturation        = 0;
    scfreq            = 0;
    sidechain         = 0;
  }
  //----------------------------------------------------------------------------
  // global/stateful variables for section "slider"
private:
  double compattack;
  double compl$attrel$coeffatt;
  double compl$attrel$coeffrel;
  double compl$attrelrel$coeffatt;
  double compl$attrelrel$coeffrel;
  double compl$attrelrel$release2$coeff;
  double compl$calc$knee;
  double compl$calc$kneelower;
  double compl$calc$kneeupper;
  double compl$calc$kneewidth;
  double compl$calc$ratio;
  double compl$calc$threshold;
  double compl$feedback;
  double compr$attrel$coeffatt;
  double compr$attrel$coeffrel;
  double compr$attrelrel$coeffatt;
  double compr$attrelrel$coeffrel;
  double compr$attrelrel$release2$coeff;
  double compr$calc$knee;
  double compr$calc$kneelower;
  double compr$calc$kneeupper;
  double compr$calc$kneewidth;
  double compr$calc$ratio;
  double compr$calc$threshold;
  double compr$feedback;
  double compratio;
  double comprelease;
  double drymix;
  double drywet;
  double filterl$a1;
  double filterl$a2;
  double filterl$a3;
  double filterl$m0;
  double filterl$m1;
  double filterl$m2;
  double filterr$a1;
  double filterr$a2;
  double filterr$a3;
  double filterr$m0;
  double filterr$m1;
  double filterr$m2;
  double gainin;
  double gainout;
  double lnkmix;
  double satmix;
  double splmix;
  double variationlevel;
  double wetdry;
  //----------------------------------------------------------------------------
  void init_slider_variables()
  {
    compattack                     = 0;
    compl$attrel$coeffatt          = 0;
    compl$attrel$coeffrel          = 0;
    compl$attrelrel$coeffatt       = 0;
    compl$attrelrel$coeffrel       = 0;
    compl$attrelrel$release2$coeff = 0;
    compl$calc$knee                = 0;
    compl$calc$kneelower           = 0;
    compl$calc$kneeupper           = 0;
    compl$calc$kneewidth           = 0;
    compl$calc$ratio               = 0;
    compl$calc$threshold           = 0;
    compl$feedback                 = 0;
    compr$attrel$coeffatt          = 0;
    compr$attrel$coeffrel          = 0;
    compr$attrelrel$coeffatt       = 0;
    compr$attrelrel$coeffrel       = 0;
    compr$attrelrel$release2$coeff = 0;
    compr$calc$knee                = 0;
    compr$calc$kneelower           = 0;
    compr$calc$kneeupper           = 0;
    compr$calc$kneewidth           = 0;
    compr$calc$ratio               = 0;
    compr$calc$threshold           = 0;
    compr$feedback                 = 0;
    compratio                      = 0;
    comprelease                    = 0;
    drymix                         = 0;
    drywet                         = 0;
    filterl$a1                     = 0;
    filterl$a2                     = 0;
    filterl$a3                     = 0;
    filterl$m0                     = 0;
    filterl$m1                     = 0;
    filterl$m2                     = 0;
    filterr$a1                     = 0;
    filterr$a2                     = 0;
    filterr$a3                     = 0;
    filterr$m0                     = 0;
    filterr$m1                     = 0;
    filterr$m2                     = 0;
    gainin                         = 0;
    gainout                        = 0;
    lnkmix                         = 0;
    satmix                         = 0;
    splmix                         = 0;
    variationlevel                 = 0;
    wetdry                         = 0;
  }
  //----------------------------------------------------------------------------
  // global/stateful variables for section "block"
private:
  double compl$attrel$envelope;
  double compl$attrelrel$envelope;
  double compl$gr;
  double compr$attrel$envelope;
  double compr$attrelrel$envelope;
  double compr$gr;
  double filterl$ic1eq;
  double filterl$ic2eq;
  double filterl$v1;
  double filterl$v2;
  double filterl$v3;
  double filterr$ic1eq;
  double filterr$ic2eq;
  double filterr$v1;
  double filterr$v2;
  double filterr$v3;
  double keyl;
  double keyr;
  double satl$envelope;
  double satr$envelope;
  double spl0$statein;
  double spl0$stateout;
  double spl1$statein;
  double spl1$stateout;
  double spl2;
  double spl3;
  //----------------------------------------------------------------------------
  void init_block_variables()
  {
    compl$attrel$envelope    = 0;
    compl$attrelrel$envelope = 0;
    compl$gr                 = 0;
    compr$attrel$envelope    = 0;
    compr$attrelrel$envelope = 0;
    compr$gr                 = 0;
    filterl$ic1eq            = 0;
    filterl$ic2eq            = 0;
    filterl$v1               = 0;
    filterl$v2               = 0;
    filterl$v3               = 0;
    filterr$ic1eq            = 0;
    filterr$ic2eq            = 0;
    filterr$v1               = 0;
    filterr$v2               = 0;
    filterr$v3               = 0;
    keyl                     = 0;
    keyr                     = 0;
    satl$envelope            = 0;
    satr$envelope            = 0;
    spl0$statein             = 0;
    spl0$stateout            = 0;
    spl1$statein             = 0;
    spl1$stateout            = 0;
    spl2                     = 0;
    spl3                     = 0;
  }
  plugin_context* plugcontext;

public:
  void reset (plugin_context& pc)
  {
    plugcontext = &pc;
    init_init_variables();
    init_block_variables();
    init_slider_variables();

    heap_reset (6 * 4);

    dbgain       = 0.0;
    compthresh   = 0.0;
    rawratio     = 3.0;
    rawattack    = 4.0;
    rawrelease   = 6.0;
    sidechain    = 0.0;
    scfreq       = 75.0;
    midside      = 0.0;
    linkamount   = 100.0;
    instability  = 100.0;
    saturation   = 100.0;
    dbtrim       = 0.0;
    clip         = 0.0;
    pctmix       = 100.0;
    m_ln10_20    = 8.68588963806503655302257837833210164588794011607333;
    floatfloor   = 0.0000000630957;
    noisefloor   = 0.00001258925412;
    halfpi       = 3.141592653589793 * 0.5;
    satspeed     = 50.0;
    rcpsqrt2     = 0.7071067812;
    compfeedback = 0.15;
    noisestate   = 10000.;
    ;
    init$satsetup (satspeed, satl$satenv$coeff);
    init$satsetup (satspeed, satr$satenv$coeff);
    slider();
  }
  //----------------------------------------------------------------------------
private:
  void slider()
  {
    double compknee = 0.;
    if (eel2_eq (rawratio, 0.)) {
      compratio = 1.5;
    }
    if (eel2_eq (rawratio, 1.)) {
      compratio = 2.;
    }
    if (eel2_eq (rawratio, 2.)) {
      compratio = 3.;
    }
    if (eel2_eq (rawratio, 3.)) {
      compratio = 4.;
    }
    if (eel2_eq (rawratio, 4.)) {
      compratio = 5.;
    }
    if (eel2_eq (rawratio, 5.)) {
      compratio = 10.;
    }
    if (eel2_eq (rawratio, 6.)) {
      compratio = 20.;
    }
    if (eel2_eq (rawattack, 0.)) {
      compattack = 0.1;
    }
    if (eel2_eq (rawattack, 1.)) {
      compattack = 0.3;
    }
    if (eel2_eq (rawattack, 2.)) {
      compattack = 1.;
    }
    if (eel2_eq (rawattack, 3.)) {
      compattack = 3.;
    }
    if (eel2_eq (rawattack, 4.)) {
      compattack = 10.;
    }
    if (eel2_eq (rawattack, 5.)) {
      compattack = 30.;
    }
    if (eel2_eq (rawrelease, 0.)) {
      comprelease = 100.;
    }
    if (eel2_eq (rawrelease, 1.)) {
      comprelease = 200.;
    }
    if (eel2_eq (rawrelease, 2.)) {
      comprelease = 400.;
    }
    if (eel2_eq (rawrelease, 3.)) {
      comprelease = 800.;
    }
    if (eel2_eq (rawrelease, 4.)) {
      comprelease = 1600.;
    }
    if (eel2_eq (rawrelease, 5.)) {
      comprelease = 3200.;
    }
    if (eel2_eq (rawrelease, 6.)) {
      comprelease = 2400.;
    }
    variationlevel = instability * 0.01;
    compknee       = 20.0 * init$fastreciprocal (compratio);
    init$compsetup (
      compattack,
      comprelease,
      compthresh,
      compratio,
      compknee,
      compfeedback,
      compl$feedback,
      compl$attrel$coeffatt,
      compl$attrel$coeffrel,
      compl$attrelrel$coeffatt,
      compl$attrelrel$coeffrel,
      compl$attrelrel$release2$coeff,
      compl$calc$threshold,
      compl$calc$ratio,
      compl$calc$knee,
      compl$calc$kneewidth,
      compl$calc$kneeupper,
      compl$calc$kneelower);
    init$compsetup (
      compattack,
      comprelease,
      compthresh,
      compratio,
      compknee,
      compfeedback,
      compr$feedback,
      compr$attrel$coeffatt,
      compr$attrel$coeffrel,
      compr$attrelrel$coeffatt,
      compr$attrelrel$coeffrel,
      compr$attrelrel$release2$coeff,
      compr$calc$threshold,
      compr$calc$ratio,
      compr$calc$knee,
      compr$calc$kneewidth,
      compr$calc$kneeupper,
      compr$calc$kneelower);
    lnkmix = linkamount * 0.01;
    splmix = 1.0 - lnkmix;
    init$eqhp (
      scfreq,
      1.5,
      filterl$a1,
      filterl$a2,
      filterl$a3,
      filterl$m0,
      filterl$m1,
      filterl$m2);
    init$eqhp (
      scfreq,
      1.5,
      filterr$a1,
      filterr$a2,
      filterr$a3,
      filterr$m0,
      filterr$m1,
      filterr$m2);
    gainin  = init$dbtogain (dbgain);
    gainout = init$dbtogain (dbtrim);
    satmix  = saturation * 0.01;
    drymix  = 1.0 - satmix;
    wetdry  = pctmix * 0.01;
    drywet  = 1.0 - wetdry;
    ;
  }
  //----------------------------------------------------------------------------
public:
  template <class T>
  void process_block_replacing (std::array<T*, 2> chnls, uint samples)
  {
    double dryl        = 0.;
    double dryr        = 0.;
    double keyl        = 0.;
    double keyr        = 0.;
    double linked      = 0.;
    double noise1      = 0.;
    double noise2      = 0.;
    double noise3      = 0.;
    double noise4      = 0.;
    double saturationl = 0.;
    double saturationr = 0.;
    double scexternal  = 0.;

    for (uint $$i = 0; $$i < samples; ++$$i) {
      auto& spl0 = chnls[0][$$i];
      auto& spl1 = chnls[1][$$i];

      dryl = spl0;
      dryr = spl1;
      spl0 *= gainin;
      spl1 *= gainin;
      if (eel2_eq (midside, 1.)) {
        keyl = init$lrtom (spl0, spl1);
        keyr = init$lrtos (spl0, spl1);
        spl0 = keyl;
        spl1 = keyr;
      }
      scexternal = eel2_eq (sidechain, 1.);
      keyl       = !scexternal * spl0 + scexternal * spl2;
      keyr       = !scexternal * spl1 + scexternal * spl3;
      if (instability > 0.) {
        noise1 = init$variation (0.);
        noise2 = init$variation (1.);
        noise3 = init$variation (2.);
        noise4 = init$variation (3.);
        spl0 += eel2_ne (spl0, 0.) * noise1;
        spl1 += eel2_ne (spl1, 0.) * noise2;
        keyl += eel2_ne (keyl, 0.) * noise3;
        keyr += eel2_ne (keyr, 0.) * noise4;
      }
      keyl = std::abs (init$eqtick (
        keyl,
        filterl$v3,
        filterl$ic2eq,
        filterl$v1,
        filterl$a1,
        filterl$ic1eq,
        filterl$a2,
        filterl$v2,
        filterl$a3,
        filterl$m0,
        filterl$m1,
        filterl$m2));
      keyr = std::abs (init$eqtick (
        keyr,
        filterr$v3,
        filterr$ic2eq,
        filterr$v1,
        filterr$a1,
        filterr$ic1eq,
        filterr$a2,
        filterr$v2,
        filterr$a3,
        filterr$m0,
        filterr$m1,
        filterr$m2));
      if (lnkmix > 0.) {
        linked = std::sqrt (jsfx_sqr (keyl) + jsfx_sqr (keyr)) * lnkmix;
        keyl *= splmix;
        keyr *= splmix;
        keyl += linked;
        keyr += linked;
      }
      spl0 *= init$comptick (
        keyl,
        compl$gr,
        compl$feedback,
        compl$attrel$envelope,
        compl$attrelrel$envelope,
        compl$attrel$coeffatt,
        compl$attrel$coeffrel,
        compl$attrelrel$coeffatt,
        compl$attrelrel$coeffrel,
        compl$attrelrel$release2$coeff,
        compl$calc$ratio,
        compl$calc$knee,
        compl$calc$kneelower,
        compl$calc$kneeupper,
        compl$calc$threshold);
      spl1 *= init$comptick (
        keyr,
        compr$gr,
        compr$feedback,
        compr$attrel$envelope,
        compr$attrelrel$envelope,
        compr$attrel$coeffatt,
        compr$attrel$coeffrel,
        compr$attrelrel$coeffatt,
        compr$attrelrel$coeffrel,
        compr$attrelrel$release2$coeff,
        compr$calc$ratio,
        compr$calc$knee,
        compr$calc$kneelower,
        compr$calc$kneeupper,
        compr$calc$threshold);
      if ((saturation > 0.)) {
        saturationl = init$sattick (compl$gr, satl$envelope, satl$satenv$coeff);
        saturationr = init$sattick (compr$gr, satr$envelope, satr$satenv$coeff);
        init$saturate (saturationl, spl0);
        init$saturate (saturationr, spl1);
        init$dcblocker (spl0$stateout, spl0, spl0$statein);
        init$dcblocker (spl1$stateout, spl1, spl1$statein);
      }
      if (eel2_eq (midside, 1.)) {
        keyl = spl0;
        keyr = spl1;
        spl0 = init$mstol (keyl, keyr);
        spl1 = init$mstor (keyl, keyr);
      }
      spl0 *= gainout;
      spl1 *= gainout;
      if (eel2_eq (clip, 1.)) {
        init$hardclip (spl0);
        init$hardclip (spl1);
      }
      if (wetdry < 1.) {
        spl0 = drywet * dryl + wetdry * spl0;
        spl1 = drywet * dryr + wetdry * spl1;
      };
    }
  }
  // functions for section "init"
private:
  //----------------------------------------------------------------------------
  double init$attrelrelsetup (
    double  msattack,
    double  msrelease1,
    double  msrelease2,
    double& $coeffatt,
    double& $coeffrel,
    double& $release2$coeff)
  {
    $coeffatt = std::exp (
      -1000. * init$fastreciprocal (msattack * jsfx_specialvar_get_srate()));
    $coeffrel = std::exp (
      -1000. * init$fastreciprocal (msrelease1 * jsfx_specialvar_get_srate()));
    return init$envsetup (msrelease2, $release2$coeff);
  }
  //----------------------------------------------------------------------------
  double init$attrelreltick (
    double  dbsample,
    double& $envelope,
    double& $coeffatt,
    double& $coeffrel,
    double& $release2$coeff)
  {
    double above  = 0.;
    double change = 0.;
    above         = (dbsample > $envelope);
    change        = $envelope - dbsample;
    $envelope     = (above * (dbsample + $coeffatt * change))
      + (!above * (dbsample + $coeffrel * change));
    return [&] {
      if (!above) {
        $envelope = init$envtick ($envelope, $envelope, $release2$coeff);
        return $envelope;
      }
      else {
        return 0. / 0.;
      }
    }();
  }
  //----------------------------------------------------------------------------
  double init$attrelsetup (
    double  msattack,
    double  msrelease,
    double& $coeffatt,
    double& $coeffrel)
  {
    $coeffatt = std::exp (
      -1000. * init$fastreciprocal (msattack * jsfx_specialvar_get_srate()));
    $coeffrel = std::exp (
      -1000. * init$fastreciprocal (msrelease * jsfx_specialvar_get_srate()));
    return $coeffrel;
  }
  //----------------------------------------------------------------------------
  double init$attreltick (
    double  dbsample,
    double& $envelope,
    double& $coeffatt,
    double& $coeffrel)
  {
    double above  = 0.;
    double change = 0.;
    above         = (dbsample > $envelope);
    change        = $envelope - dbsample;
    $envelope     = (above * (dbsample + $coeffatt * change))
      + (!above * (dbsample + $coeffrel * change));
    return $envelope;
  }
  //----------------------------------------------------------------------------
  double init$compsetup (
    double  msattack,
    double  msrelease,
    double  dbthreshold,
    double  fullratio,
    double  dbknee,
    double  pctfeedback,
    double& $feedback,
    double& $attrel$coeffatt,
    double& $attrel$coeffrel,
    double& $attrelrel$coeffatt,
    double& $attrelrel$coeffrel,
    double& $attrelrel$release2$coeff,
    double& $calc$threshold,
    double& $calc$ratio,
    double& $calc$knee,
    double& $calc$kneewidth,
    double& $calc$kneeupper,
    double& $calc$kneelower)
  {
    init$attrelsetup (msattack, msrelease, $attrel$coeffatt, $attrel$coeffrel);
    init$attrelrelsetup (
      msattack,
      msrelease,
      100.,
      $attrelrel$coeffatt,
      $attrelrel$coeffrel,
      $attrelrel$release2$coeff);
    init$gaincalcsetup (
      dbthreshold,
      fullratio,
      dbknee,
      $calc$threshold,
      $calc$ratio,
      $calc$knee,
      $calc$kneewidth,
      $calc$kneeupper,
      $calc$kneelower);
    $feedback = pctfeedback * 0.01;
    return $feedback;
  }
  //----------------------------------------------------------------------------
  double init$comptick (
    double  sample,
    double& $gr,
    double& $feedback,
    double& $attrel$envelope,
    double& $attrelrel$envelope,
    double& $attrel$coeffatt,
    double& $attrel$coeffrel,
    double& $attrelrel$coeffatt,
    double& $attrelrel$coeffrel,
    double& $attrelrel$release2$coeff,
    double& $calc$ratio,
    double& $calc$knee,
    double& $calc$kneelower,
    double& $calc$kneeupper,
    double& $calc$threshold)
  {
    double feedbackfactor = 0.;
    double keydecibels    = 0.;
    double keygain        = 0.;
    feedbackfactor        = 1.0 - ((1.0 - $gr) * $feedback);
    keygain               = sample * feedbackfactor;
    keydecibels           = init$gaintodb (keygain);
    init$attreltick (
      keydecibels, $attrel$envelope, $attrel$coeffatt, $attrel$coeffrel);
    init$attrelreltick (
      keydecibels,
      $attrelrel$envelope,
      $attrelrel$coeffatt,
      $attrelrel$coeffrel,
      $attrelrel$release2$coeff);
    $gr = init$gaincalctick (
      [&] {
        if (rawrelease < 6.) {
          return $attrel$envelope;
        }
        else {
          return $attrelrel$envelope;
        }
      }(),
      $calc$ratio,
      $calc$knee,
      $calc$kneelower,
      $calc$kneeupper,
      $calc$threshold);
    return $gr;
  }
  //----------------------------------------------------------------------------
  double init$dbtogain (double decibels)
  {
    return eel2_pow (10.0, (decibels / 20.0));
  }
  //----------------------------------------------------------------------------
  double init$dcblocker (double& $stateout, double& this$, double& $statein)
  {
    $stateout *= 0.99988487;
    $stateout += this$ - $statein;
    $statein = this$;
    this$    = $stateout;
    return this$;
  }
  //----------------------------------------------------------------------------
  double init$envsetup (double mstime, double& $coeff)
  {
#if 1
    if (mstime == 0.) {
      $coeff = 0.f;
      return $coeff;
    }
#endif
    $coeff = std::exp (
      -1000. * init$fastreciprocal (mstime * jsfx_specialvar_get_srate()));
    return $coeff;
  }
  //----------------------------------------------------------------------------
  double init$envtick (double dbsample, double envelope, double& $coeff)
  {
    double active = 0.;
    active        = eel2_ne ($coeff, 0.);
    return (!active * dbsample)
      + (active * (dbsample + $coeff * (envelope - dbsample)));
  }
  //----------------------------------------------------------------------------
  double init$eqhp (
    double  hz,
    double  q,
    double& $a1,
    double& $a2,
    double& $a3,
    double& $m0,
    double& $m1,
    double& $m2)
  {
    double g = 0.;
    double k = 0.;
    g        = std::tan (halfpi * (hz / jsfx_specialvar_get_srate()));
    k        = init$fastreciprocal (q);
    $a1      = init$fastreciprocal (1.0 + g * (g + k));
    $a2      = $a1 * g;
    $a3      = $a2 * g;
    $m0      = 1.0;
    $m1      = -k;
    $m2      = -1.0;
    return $m2;
  }
  //----------------------------------------------------------------------------
  double init$eqtick (
    double  sample,
    double& $v3,
    double& $ic2eq,
    double& $v1,
    double& $a1,
    double& $ic1eq,
    double& $a2,
    double& $v2,
    double& $a3,
    double& $m0,
    double& $m1,
    double& $m2)
  {
    $v3    = sample - $ic2eq;
    $v1    = $a1 * $ic1eq + $a2 * $v3;
    $v2    = $ic2eq + $a2 * $ic1eq + $a3 * $v3;
    $ic1eq = 2.0 * $v1 - $ic1eq;
    $ic2eq = 2.0 * $v2 - $ic2eq;
    return ($m0 * sample + $m1 * $v1 + $m2 * $v2);
  }
  //----------------------------------------------------------------------------
  double init$fastreciprocal (double value)
  {
    return jsfx_sqr (jsfx_invsqrt (value));
  }
  //----------------------------------------------------------------------------
  double init$gaincalcsetup (
    double  dbthreshold,
    double  fullratio,
    double  dbknee,
    double& $threshold,
    double& $ratio,
    double& $knee,
    double& $kneewidth,
    double& $kneeupper,
    double& $kneelower)
  {
    $threshold = dbthreshold;
    $ratio     = init$fastreciprocal (fullratio);
    $knee      = dbknee;
    $kneewidth = $knee * 0.5;
    $kneeupper = $threshold + $kneewidth;
    $kneelower = $threshold - $kneewidth;
    return $kneelower;
  }
  //----------------------------------------------------------------------------
  double init$gaincalctick (
    double  dbsample,
    double& $ratio,
    double& $knee,
    double& $kneelower,
    double& $kneeupper,
    double& $threshold)
  {
    double dbreduction = 0.;
    double slope       = 0.;
    dbreduction        = dbsample;
    slope              = 1.0 - $ratio;
    if (($knee > 0.0) && (dbsample > $kneelower) && (dbsample < $kneeupper)) {
      slope *= ((dbsample - $kneelower) / $knee) * 0.5;
      dbreduction = slope * ($kneelower - dbsample);
    }
    else {
      (dbreduction = std::min (0.0, slope * ($threshold - dbsample)));
    }
    return init$dbtogain (dbreduction);
  }
  //----------------------------------------------------------------------------
  double init$gaintodb (double float_)
  {
    double below = 0.;
    float_       = std::abs (float_);
    below        = float_ < floatfloor;
    float_       = below * floatfloor + !(below) *float_;
    return (std::log (float_) * m_ln10_20);
  }
  //----------------------------------------------------------------------------
  double init$hardclip (double& this$)
  {
    this$ = std::max (-1., std::min (1., this$));
    return this$;
  }
  //----------------------------------------------------------------------------
  double init$lrtom (double sampleleft, double sampleright)
  {
    return (sampleleft + sampleright) * rcpsqrt2;
  }
  //----------------------------------------------------------------------------
  double init$lrtos (double sampleleft, double sampleright)
  {
    return (sampleleft - sampleright) * rcpsqrt2;
  }
  //----------------------------------------------------------------------------
  double init$mstol (double samplemid, double sampleside)
  {
    return (samplemid + sampleside) * rcpsqrt2;
  }
  //----------------------------------------------------------------------------
  double init$mstor (double samplemid, double sampleside)
  {
    return (samplemid - sampleside) * rcpsqrt2;
  }
  //----------------------------------------------------------------------------
  double init$random (double limit)
  {
    return jsfx_rand() * 2.0 * limit - limit;
  }
  //----------------------------------------------------------------------------
  double init$satsetup (double msspeed, double& $satenv$coeff)
  {
    return init$envsetup (msspeed, $satenv$coeff);
  }
  //----------------------------------------------------------------------------
  double init$sattick (
    double  samplegr,
    double& $envelope,
    double& $satenv$coeff)
  {
    $envelope = init$envtick (samplegr, $envelope, $satenv$coeff);
    return $envelope;
  }
  //----------------------------------------------------------------------------
  double init$saturate (double drive, double& this$)
  {
    double boost = 0.;
    boost        = 1.0 + (1.0 - drive);
    this$        = (drymix * this$) + (satmix * init$softclip (this$ * boost));
    return this$;
  }
  //----------------------------------------------------------------------------
  double init$softclip (double number)
  {
    double x4  = 0.;
    double xa  = 0.;
    double x7  = 0.;
    double x2  = 0.;
    double res = 0.;
    double x3  = 0.;
    xa         = std::abs (number);
    x2         = xa * xa;
    x3         = x2 * xa;
    x4         = x2 * x2;
    x7         = x4 * x3;
    res
      = (1.0 - 1.0 / (1.0 + xa + x2 + 0.58576695 * x3 + 0.55442112 * x4 + 0.057481508 * x7));
    return jsfx_sign (number) * res;
  }
  //----------------------------------------------------------------------------
  double init$tickpink (double channel)
  {
    double sample = 0.;
    double break_ = 0.;
    double offset = 0.;
#if 0
    offset        = channel * 50.;
#else
    offset = channel * 6.;
#endif
    break_ = 0.;
    sample = jsfx_rand();
    if (eel2_eq (break_, 0.) && sample <= 0.00198) {
      heap (noisestate + (offset + 1.)) = init$random (1.) * 3.8024;
      break_                            = 1.;
    }
    if (eel2_eq (break_, 0.) && sample <= 0.01478) {
      heap (noisestate + (offset + 2.)) = init$random (1.) * 2.9694;
      break_                            = 1.;
    }
    if (eel2_eq (break_, 0.) && sample <= 0.06378) {
      heap (noisestate + (offset + 3.)) = init$random (1.) * 2.5970;
      break_                            = 1.;
    }
    if (eel2_eq (break_, 0.) && sample <= 0.23378) {
      heap (noisestate + (offset + 4.)) = init$random (1.) * 3.0870;
      break_                            = 1.;
    }
    if (eel2_eq (break_, 0.) && sample <= 0.91578) {
      heap (noisestate + (offset + 5.)) = init$random (1.) * 3.4006;
      break_                            = 1.;
    }
    heap (noisestate + offset) = 0.;
    heap (noisestate + offset) += heap (noisestate + (offset + 1.));
    heap (noisestate + offset) += heap (noisestate + (offset + 2.));
    heap (noisestate + offset) += heap (noisestate + (offset + 3.));
    heap (noisestate + offset) += heap (noisestate + (offset + 4.));
    heap (noisestate + offset) += heap (noisestate + (offset + 5.));
    return heap (noisestate + offset) * init$dbtogain (-15.);
  }
  //----------------------------------------------------------------------------
  double init$variation (double channel)
  {
    double channel = 0.;
    noise          = init$tickpink (channel) * noisefloor * variationlevel;
    return noise;
  }
}; /* jsfx_process */

}} // namespace artv::chokehold

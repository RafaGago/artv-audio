#pragma once

#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wunused-value"
// Generated by jsfx2cpp.py. To be manually corrected.
// includes for environment function calls

#include <algorithm>
#include <cmath>
#include <cstdint>
#include <cstdlib>
#include <limits>

#include <juce_audio_processors/juce_audio_processors.h>

#include "artv-common/dsp/jsfx_engine/jsfx_engine.hpp"
#include "artv-common/dsp/own/classes/plugin_context.hpp"
#include "artv-common/dsp/types.hpp"
#include "artv-common/juce/parameter_definitions.hpp"
#include "artv-common/juce/parameter_types.hpp"
#include "artv-common/misc/bits.hpp"
#include "artv-common/misc/mp11.hpp"
#include "artv-common/misc/short_ints.hpp"
#include "artv-common/misc/util.hpp"

namespace artv { namespace witti {

struct bbd_echo {
public:
  //----------------------------------------------------------------------------
  static constexpr dsp_types dsp_type = dsp_types::delay;

private:
  // definitions for environment function calls
  static double eel2_eq (double lhs, double rhs)
  {
    return (double) (std::abs (lhs - rhs) < 0.00001);
  }
  static bool   eel2_ne (double lhs, double rhs) { return !eel2_eq (lhs, rhs); }
  static double eel2_or (double lhs, double rhs)
  {
    return (double) ((uint64_t) lhs | (uint64_t) rhs);
  }
  static double eel2_pow (double lhs, double rhs)
  {
    return std::pow (lhs, rhs);
  }
  std::vector<float> heapmem;
  inline float&      heap (std::size_t value) { return heapmem[value]; }
  void               heap_reset (std::size_t s)
  {
    heapmem.resize (s);
    std::memset (heapmem.data(), 0, heapmem.size() * sizeof heapmem[0]);
  }
  void jsfx_memset (size_t idx, int val, size_t size)
  {
    std::memset (&heapmem[idx], val, size * sizeof heapmem[0]);
  }
  static double jsfx_rand (double maxv = 1.)
  {
    return jsfx_engine::rand (maxv);
  }

  //----------------------------------------------------------------------------
  // stubs for JSFX special variables
private:
#if 0
  double jsfx_specialvar_get_samplesblock()
  {
    return 0.; /* TODO: stub for getting JSFX var "samplesblock" */
  }
#endif
  double jsfx_specialvar_get_srate() { return plugcontext->get_sample_rate(); }

  void jsfx_specialvar_set_ext_nodenorm (double val)
  {
    /* TODO: stub for setting JSFX var "ext_nodenorm" */
  }

  void jsfx_specialvar_set_ext_noinit (double val)
  {
    /* TODO: stub for setting JSFX var "ext_noinit" */
  }

  //----------------------------------------------------------------------------
public:
#if 0
  void set_slider1_slider (float v)
  {
    // Original slider line: slider1:0.8<0,1,0.01>feedback
    // Range: min:0.0, max:1.0, default: 0.8, step: 0.01
    if (v == slider1) {
      return;
    }
    slider1 = v;
    slider();
  }
#else
  // Snippet for parameter boilerplate in the authors framework....
  struct feedback_tag {};

  void set (feedback_tag, float v)
  {
    // Original slider line: slider1:0.8<0,1,0.01>feedback
    // Range: min:0.0, max:1.0, default: 0.8, step: 0.01
    v += 100.;
    v /= 200.;
    if (v == slider1) {
      return;
    }
    slider1 = v;
    slider();
  }

  static constexpr auto get_parameter (feedback_tag)
  {
    // Original slider line: slider1:0.8<0,1,0.01>feedback
    return float_param ("%", -100.0, 100., 40., 0.1);
  }

#endif
#if 0
  void set_slider2_slider (float v)
  {
    // Original slider line: slider2:0.01<0,1,0.01>lfo depth
    // Range: min:0.0, max:1.0, default: 0.01, step: 0.01
    if (v == slider2) {
      return;
    }
    slider2 = v;
    slider();
  }
#else
  // Snippet for parameter boilerplate in the authors framework....
  struct lfo_depth_tag {};

  void set (lfo_depth_tag, float v)
  {
    // Original slider line: slider2:0.01<0,1,0.01>lfo depth
    // Range: min:0.0, max:1.0, default: 0.01, step: 0.01
    if (v == slider2) {
      return;
    }
    slider2 = v;
    slider();
  }

  static constexpr auto get_parameter (lfo_depth_tag)
  {
    // Original slider line: slider2:0.01<0,1,0.01>lfo depth
    return float_param ("", 0.0, 1.0, 0.01, 0.01);
  }

#endif
#if 0
  void set_slider3_slider (float v)
  {
    // Original slider line: slider3:0.65<0,1,0.01>lfo speed
    // Range: min:0.0, max:1.0, default: 0.65, step: 0.01
    if (v == slider3) {
      return;
    }
    slider3 = v;
    slider();
  }
#else
  // Snippet for parameter boilerplate in the authors framework....
  struct lfo_speed_tag {};

  void set (lfo_speed_tag, float v)
  {
    // Original slider line: slider3:0.65<0,1,0.01>lfo speed
    // Range: min:0.0, max:1.0, default: 0.65, step: 0.01
    if (v == slider3) {
      return;
    }
    slider3 = v;
    slider();
  }

  static constexpr auto get_parameter (lfo_speed_tag)
  {
    // Original slider line: slider3:0.65<0,1,0.01>lfo speed
    return float_param ("", 0.0, 1.0, 0.65, 0.01);
  }

#endif
#if 0
  void set_slider4_slider (float v)
  {
    // Original slider line: slider4:0.45<0,1,0.01>wet mix
    // Range: min:0.0, max:1.0, default: 0.45, step: 0.01
    if (v == slider4) {
      return;
    }
    slider4 = v;
    slider();
  }
#else
  // Snippet for parameter boilerplate in the authors framework....
  struct dry_wet_tag {};

  void set (dry_wet_tag, float v)
  {
    // Original slider line: slider4:0.45<0,1,0.01>wet mix
    // Range: min:0.0, max:1.0, default: 0.45, step: 0.01
    v /= 100;
    if (v == slider4) {
      return;
    }
    slider4 = v;
    slider();
  }

  static constexpr auto get_parameter (dry_wet_tag)
  {
    // Original slider line: slider4:0.45<0,1,0.01>wet mix
    return float_param ("", 0.0, 100.0, 100., 0.1);
  }

#endif
#if 0
  void set_slider5_slider (float v)
  {
    // Original slider line: slider5:0.5<0,1,0.01>output
    // Range: min:0.0, max:1.0, default: 0.5, step: 0.01
    if (v == slider5) {
      return;
    }
    slider5 = v;
    slider();
  }
#else
  // Snippet for parameter boilerplate in the authors framework....
  struct out_tag {};

  void set (out_tag, float v)
  {
    // Original slider line: slider5:0.5<0,1,0.01>output
    // Range: min:0.0, max:1.0, default: 0.5, step: 0.01
    if (v == slider5) {
      return;
    }
    slider5 = v;
    slider();
  }

  static constexpr auto get_parameter (out_tag)
  {
    // Original slider line: slider5:0.5<0,1,0.01>output
    return float_param ("", 0.0, 1.0, 0.5, 0.01);
  }

#endif
#if 0
  void set_slider6_slider (float v)
  {
    // Original slider line:
    // slider6:9<0,10,1{64,128,256,512,1024,2048,4096,8192,16384,32768,65536}>stages
    // Range: min:0.0, max:10.0, default: 9.0, step: 1.0
    if (v == slider6) {
      return;
    }
    slider6 = v;
    slider();
  }
#else
  // Snippet for parameter boilerplate in the authors framework....
  struct stages_tag {};

  static constexpr auto get_parameter (stages_tag)
  {
    // Original slider line:
    // slider6:9<0,10,1{64,128,256,512,1024,2048,4096,8192,16384,32768,65536}>stages
    return choice_param (
      9,
      make_cstr_array (
        "64",
        "128",
        "256",
        "512",
        "1024",
        "2048",
        "4096",
        "8192",
        "16384",
        "32768",
        "65536"),
      20);
  }

  void set (stages_tag, int v)
  {
    // Original slider line:
    // slider6:9<0,10,1{64,128,256,512,1024,2048,4096,8192,16384,32768,65536}>stages
    // Range: min:0.0, max:10.0, default: 9.0, step: 1.0
    if (v == slider6 || v >= get_parameter (stages_tag {}).choices.size()) {
      return;
    }
    slider6 = v;
    slider();
  }

  uint get_stage_count() { return 1u << (((uint) slider6) + 6); }

#endif
#if 0
  void set_slider7_slider (float v)
  {
    // Original slider line: slider7:14860<4410,44100,1>delay
    // Range: min:4410.0, max:44100.0, default: 14860.0, step: 1.0
    if (v == slider7) {
      return;
    }
    slider7 = v;
    slider();
  }
#else
  // Snippet for parameter boilerplate in the authors framework....
  struct delay_tag {};

  uint delay_nosync = 0;
  void set (delay_tag, float v)
  {
    // Original slider line: slider7:14860<4410,44100,1>delay
    // Range: min:4410.0, max:44100.0, default: 14860.0, step: 1.0
    v /= 100.;
    uint srate = plugcontext->get_sample_rate();
    v *= (srate - (srate / 10));
    // delay sync always has "srate/10" samples at least, so the original range
    // is kept.
    if (((uint) v) == delay_nosync) {
      return;
    }
    delay_nosync = v;
    slider(); // on slider both "delay_sync" and "delay_nosync" are added.
  }

  static constexpr auto get_parameter (delay_tag)
  {
    // Original slider line: slider7:14860<4410,44100,1>delay
    return float_param ("%", 0., 100., 0., 0.0001);
  }

  // adding a fader that scrolls rounding to beatsinced samples

  uint synced_delay_samples = 0;
  uint delay_sync           = 0;

  uint get_synced_delay_samples()
  {
    auto bpm           = plugcontext->get_play_state().bpm;
    auto sr            = plugcontext->get_sample_rate();
    auto one_beat_spls = (bpm * sr * sr) / (60. * get_stage_count());
    // delays goes from "sr/10" to "sr". Find a divisor that at least is 16
    // times smaller than the delay.
    double div = (one_beat_spls * 16.) / sr;
    assert (div >= 1.); // won't happen given the current values
    div = 1 << (uint) std::ceil (std::log2 (div));
    return std::round (one_beat_spls / div);
  }

  struct delay_sync_tag {};

  void set (delay_sync_tag, float v)
  {
    // delay_no sync always has fs/10 samples al
    v *= 0.01f;
    uint srate = plugcontext->get_sample_rate();
    v *= (srate - (srate * 0.01));
    v += srate * 0.1;
    uint samples = v;
    // rounding to previous sync point
    samples -= (samples % synced_delay_samples);
    // slider code is caring about the totals not going out of range, so not
    // fixing here the case were we would end up under fs/10 samples.
    if (samples == delay_sync) {
      return;
    }
    delay_sync = samples;
    slider(); // on slider both "delay_sync" and "delay_nosync" are added.
  }

  static constexpr auto get_parameter (delay_sync_tag)
  {
    // Original slider line: slider7:14860<4410,44100,1>delay
    return float_param ("%", 0., 100., 50., 0.0001);
  }

#endif
#if 0
  void set_slider8_slider (float v)
  {
    // Original slider line: slider8:30<0,100,1>hp filter
    // Range: min:0.0, max:100.0, default: 30.0, step: 1.0
    if (v == slider8) {
      return;
    }
    slider8 = v;
    slider();
  }
#else
  // Snippet for parameter boilerplate in the authors framework....
  struct hp_filter_tag {};

  void set (hp_filter_tag, float v)
  {
    // Original slider line: slider8:30<0,100,1>hp filter
    // Range: min:0.0, max:100.0, default: 30.0, step: 1.0
    if (v == slider8) {
      return;
    }
    slider8 = v;
    slider();
  }

  static constexpr auto get_parameter (hp_filter_tag)
  {
    // Original slider line: slider8:30<0,100,1>hp filter
    return float_param ("", 0.0, 100.0, 30.0, 1.0);
  }

#endif
#if 0
  void set_slider9_slider (float v)
  {
    // Original slider line: slider9:0.5<0,1,0.01>hp res
    // Range: min:0.0, max:1.0, default: 0.5, step: 0.01
    if (v == slider9) {
      return;
    }
    slider9 = v;
    slider();
  }
#else
  // Snippet for parameter boilerplate in the authors framework....
  struct hp_res_tag {};

  void set (hp_res_tag, float v)
  {
    // Original slider line: slider9:0.5<0,1,0.01>hp res
    // Range: min:0.0, max:1.0, default: 0.5, step: 0.01
    if (v == slider9) {
      return;
    }
    slider9 = v;
    slider();
  }

  static constexpr auto get_parameter (hp_res_tag)
  {
    // Original slider line: slider9:0.5<0,1,0.01>hp res
    return float_param ("", 0.0, 1.0, 0.5, 0.01);
  }

#endif
#if 0
  void set_slider10_slider (float v)
  {
    // Original slider line: slider10:80<0,100,1>lp filter
    // Range: min:0.0, max:100.0, default: 80.0, step: 1.0
    if (v == slider10) {
      return;
    }
    slider10 = v;
    slider();
  }
#else
  // Snippet for parameter boilerplate in the authors framework....
  struct lp_filter_tag {};

  void set (lp_filter_tag, float v)
  {
    // Original slider line: slider10:80<0,100,1>lp filter
    // Range: min:0.0, max:100.0, default: 80.0, step: 1.0
    if (v == slider10) {
      return;
    }
    slider10 = v;
    slider();
  }

  static constexpr auto get_parameter (lp_filter_tag)
  {
    // Original slider line: slider10:80<0,100,1>lp filter
    return float_param ("", 0.0, 100.0, 80.0, 1.0);
  }

#endif
#if 0
  void set_slider11_slider (float v)
  {
    // Original slider line: slider11:0.5<0,1,0.01>lp res
    // Range: min:0.0, max:1.0, default: 0.5, step: 0.01
    if (v == slider11) {
      return;
    }
    slider11 = v;
    slider();
  }
#else
  // Snippet for parameter boilerplate in the authors framework....
  struct lp_res_tag {};

  void set (lp_res_tag, float v)
  {
    // Original slider line: slider11:0.5<0,1,0.01>lp res
    // Range: min:0.0, max:1.0, default: 0.5, step: 0.01
    if (v == slider11) {
      return;
    }
    slider11 = v;
    slider();
  }

  static constexpr auto get_parameter (lp_res_tag)
  {
    // Original slider line: slider11:0.5<0,1,0.01>lp res
    return float_param ("", 0.0, 1.0, 0.5, 0.01);
  }

#endif
#if 0
  void set_slider12_slider (float v)
  {
    // Original slider line: slider12:0<0,44100,1>clock offset
    // Range: min:0.0, max:44100.0, default: 0.0, step: 1.0
    if (v == slider12) {
      return;
    }
    slider12 = v;
    slider();
  }
#else
  // Snippet for parameter boilerplate in the authors framework....
  struct clock_offset_tag {};

  void set (clock_offset_tag, float v)
  {
    // Original slider line: slider12:0<0,44100,1>clock offset
    // Range: min:0.0, max:44100.0, default: 0.0, step: 1.0
    v *= jsfx_specialvar_get_srate() / 100.;
    if (v == slider12) {
      return;
    }
    slider12 = v;
    slider();
  }

  static constexpr auto get_parameter (clock_offset_tag)
  {
    // Original slider line: slider12:0<0,44100,1>clock offset
    return float_param ("%", 0.001, 100., 0.0, 0.001);
  }

#endif
#if 0
  void set_slider13_slider (float v)
  {
    // Original slider line: slider13:1<0,1,0.001>clock scale
    // Range: min:0.0, max:1.0, default: 1.0, step: 0.001
    if (v == slider13) {
      return;
    }
    slider13 = v;
    slider();
  }
#else
  // Snippet for parameter boilerplate in the authors framework....
  struct clock_scale_tag {};

  void set (clock_scale_tag, float v)
  {
    // Original slider line: slider13:1<0,1,0.001>clock scale
    // Range: min:0.0, max:1.0, default: 1.0, step: 0.001
    if (v == slider13) {
      return;
    }
    slider13 = v;
    slider();
  }

  static constexpr auto get_parameter (clock_scale_tag)
  {
    // Original slider line: slider13:1<0,1,0.001>clock scale
    return float_param ("", 0.017, 1.0, 1.0, 0.001, 0.5);
  }
#endif

#if 0
  void set_slider14_slider (float v)
  {
    // Original slider line: slider14:1<0.8,1.2,0.01>--clock curve
    // Range: min:0.8, max:1.2, default: 1.0, step: 0.01
    if (v == slider14) {
      return;
    }
    slider14 = v;
    slider();
  }
#else
  // Snippet for parameter boilerplate in the authors framework....
  struct clock_curve_tag {};

  void set (clock_curve_tag, float v)
  {
    // Original slider line: slider14:1<0.8,1.2,0.01>--clock curve
    // Range: min:0.8, max:1.2, default: 1.0, step: 0.01
    if (v == slider14) {
      return;
    }
    slider14 = v;
    slider();
  }

  static constexpr auto get_parameter (clock_curve_tag)
  {
    // Original slider line: slider14:1<0.8,1.2,0.01>--clock curve
    return float_param ("", 0.8, 1.2, 1.0, 0.01);
  }

#endif
#if 0
  void set_slider15_slider (float v)
  {
    // Original slider line: slider15:0<0,1,0.01>hiss
    // Range: min:0.0, max:1.0, default: 0.0, step: 0.01
    if (v == slider15) {
      return;
    }
    slider15 = v;
    slider();
  }
#else
  // Snippet for parameter boilerplate in the authors framework....
  struct hiss_tag {};

  void set (hiss_tag, float v)
  {
    // Original slider line: slider15:0<0,1,0.01>hiss
    // Range: min:0.0, max:1.0, default: 0.0, step: 0.01
    if (v == slider15) {
      return;
    }
    slider15 = v;
    slider();
  }

  static constexpr auto get_parameter (hiss_tag)
  {
    // Original slider line: slider15:0<0,1,0.01>hiss
    return float_param ("", 0.0, 1.0, 0.0, 0.01);
  }
  //----------------------------------------------------------------------------

  //----------------------------------------------------------------------------
#endif
  using parameters = mp_list<
    feedback_tag,
    lfo_depth_tag,
    lfo_speed_tag,
    dry_wet_tag,
    stages_tag,
    delay_tag,
    delay_sync_tag,
    hp_filter_tag,
    hp_res_tag,
    lp_filter_tag,
    lp_res_tag,
    clock_offset_tag,
    clock_scale_tag,
    clock_curve_tag,
    hiss_tag>;

private:
  //----------------------------------------------------------------------------
  // global/stateful variables for section "init"
  double buffer;
  double ddl;
  double dlbuf;
  double env;
  double fs;
  double ipos;
  double k;
  double mx10;
  double mx11;
  double mx20;
  double mx21;
  double my10;
  double my11;
  double my20;
  double my21;
  double nn_val;
  double phi;
  double pos;
  double size;
  double slider1;
  double slider10;
  double slider11;
  double slider12;
  double slider13;
  double slider14;
  double slider15;
  double slider2;
  double slider3;
  double slider4;
  double slider5;
  double slider6;
  double slider7;
  double slider8;
  double slider9;
  double twopi;
  double twopi2;
  //----------------------------------------------------------------------------
  void init_init_variables()
  {
    buffer   = 0;
    ddl      = 0;
    dlbuf    = 0;
    env      = 0;
    fs       = 0;
    ipos     = 0;
    k        = 0;
    mx10     = 0;
    mx11     = 0;
    mx20     = 0;
    mx21     = 0;
    my10     = 0;
    my11     = 0;
    my20     = 0;
    my21     = 0;
    nn_val   = 0;
    phi      = 0;
    pos      = 0;
    size     = 0;
    slider1  = 0;
    slider10 = 0;
    slider11 = 0;
    slider12 = 0;
    slider13 = 0;
    slider14 = 0;
    slider15 = 0;
    slider2  = 0;
    slider3  = 0;
    slider4  = 0;
    slider5  = 0;
    slider6  = 0;
    slider7  = 0;
    slider8  = 0;
    slider9  = 0;
    twopi    = 0;
    twopi2   = 0;
  }
  //----------------------------------------------------------------------------
  // global/stateful variables for section "slider"
  double del;
  double dphi;
  double dry;
  double fbk;
  double hiss;
  double ma00;
  double ma01;
  double ma10;
  double ma11;
  double ma20;
  double ma21;
  double mb10;
  double mb11;
  double mb20;
  double mb21;
  double mod;
  double old_s10;
  double old_s8;
  double rel;
  double samples;
  double wet;
  //----------------------------------------------------------------------------
  void init_slider_variables()
  {
    del     = 0;
    dphi    = 0;
    dry     = 0;
    fbk     = 0;
    hiss    = 0;
    ma00    = 0;
    ma01    = 0;
    ma10    = 0;
    ma11    = 0;
    ma20    = 0;
    ma21    = 0;
    mb10    = 0;
    mb11    = 0;
    mb20    = 0;
    mb21    = 0;
    mod     = 0;
    old_s10 = 0;
    old_s8  = 0;
    rel     = 0;
    samples = 0;
    wet     = 0;
  }
  //----------------------------------------------------------------------------
  // global/stateful variables for section "block"
  double buf;
  double lp;
  //----------------------------------------------------------------------------
  void init_block_variables()
  {
    buf = 0;
    lp  = 0;
  }
  //----------------------------------------------------------------------------
  plugin_context* plugcontext = nullptr;
  //----------------------------------------------------------------------------
public:
  void reset (plugin_context& pc)
  {
    plugcontext = &pc;
    init_init_variables();
    init_slider_variables();
    init_block_variables();
    slider1  = 0.8;
    slider2  = 0.01;
    slider3  = 0.65;
    slider4  = 0.45;
    slider5  = 0.5;
    slider6  = 9.0;
    slider7  = 14860.0;
    slider8  = 30.0;
    slider9  = 0.5;
    slider10 = 80.0;
    slider11 = 0.5;
    slider12 = 0.0;
    slider13 = 1.0;
    slider14 = 1.0;
    slider15 = 0.0;
    jsfx_specialvar_set_ext_noinit (1.);
    jsfx_specialvar_set_ext_nodenorm (1.);
    size   = 65536.;
    buffer = 4096.;
    heap_reset (buffer + size + 1);
    jsfx_memset (buffer, 0., size + 1);
    ipos   = 0.;
    env    = 0.;
    phi    = 0.;
    dlbuf  = 0.;
    ddl    = 0.;
    k      = 0.;
    twopi  = 2. * 3.141592653589793;
    twopi2 = twopi * 100.;
    fs     = jsfx_specialvar_get_srate();
    if ((fs < 8000.)) {
      fs = 44100.;
    }
    pos    = 0.;
    nn_val = 0.;
    my20   = 0.;
    my10   = my20;
    mx20   = my10;
    mx10   = mx20;
    my21   = 0.;
    my11   = my21;
    mx21   = my11;
    mx11   = mx21;
#if 1
    // I changed the defaults and ranges
    mp11::mp_for_each<parameters> ([=] (auto param) {
      set (param, get_parameter (param).defaultv);
    });
#endif
  }
  //----------------------------------------------------------------------------
private:
  void slider()
  {
#if 0
    double bits     = 0.;
#endif
    double c10      = 0.;
    double c11      = 0.;
    double c20      = 0.;
    double c21      = 0.;
    double c30      = 0.;
    double c31      = 0.;
    double clock    = 0.;
    double cutoff0  = 0.;
    double cutoff1  = 0.;
    double cx0      = 0.;
    double cx1      = 0.;
    double delay    = 0.;
    double fparam1  = 0.;
    double fparam10 = 0.;
    double fparam11 = 0.;
    double fparam12 = 0.;
    double fparam13 = 0.;
    double fparam14 = 0.;
    double fparam15 = 0.;
    double fparam2  = 0.;
    double fparam3  = 0.;
    double fparam4  = 0.;
    double fparam5  = 0.;
    double fparam6  = 0.;
    double fparam7  = 0.;
    double fparam8  = 0.;
    double fparam9  = 0.;
    double kx0      = 0.;
    double kx1      = 0.;
    double res0     = 0.;
    double res1     = 0.;
    double resx0    = 0.;
    double resx1    = 0.;
    double stages   = 0.;
    double sx0      = 0.;
    double sx1      = 0.;
#if 1
    slider7              = delay_nosync + delay_sync;
    synced_delay_samples = get_synced_delay_samples();
    // code below ensures that these values are kept in range.
#endif
#if 0
    // already rounded to integer.
    slider7  = std::floor (slider7);
#endif
    slider12 = std::floor (slider12);
    if ((eel2_ne (old_s8, slider8) && slider8 > slider10)) {
      slider10 = slider8;
    }
    if ((eel2_ne (old_s10, slider10) && slider10 < slider8)) {
      slider8 = slider10;
    }
    old_s8   = slider8;
    old_s10  = slider10;
    fparam1  = slider1;
    fparam2  = slider2;
    fparam3  = slider3;
    fparam4  = slider4;
    fparam5  = slider5;
    fparam6  = slider6;
    fparam7  = slider7;
    fparam8  = slider8;
    fparam9  = slider9;
    fparam10 = slider10;
    fparam11 = slider11;
    fparam12 = slider12;
    fparam13 = slider13;
    fparam14 = slider14;
    fparam15 = slider15;
#if 0
  // using integers for this on the slider parameter
    bits     = eel2_or (fparam6 + 2., 0.);
    if (bits < 0.) {
      bits = 0.;
    }
    else {
      if (bits > 12.) {
        bits = 12.;
      }
    }
    stages = eel2_pow (2., (bits + 4.));
#else
    stages = get_stage_count();
#endif
#if 0
    delay = std::max (std::min (fparam7, fs), eel2_or (fs * 0.1, 0.));
    del = eel2_or (, 0.);
#else
    // just using ints for this.
    delay = std::min ((uint) fparam7, plugcontext->get_sample_rate());
    delay = std::max ((uint) delay, plugcontext->get_sample_rate() / 10);
    del   = (uint) ((stages / fs) * delay);
#endif

    mod = 0.49 * fparam2 * del;
    fbk = std::abs (2.2 * fparam1 - 1.1);
    (rel = 0.8);
    if ((fparam1 > 0.5)) {
      (rel = 0.9997);
    }
    else {
      rel;
    }
    wet   = 1. - fparam4;
    wet   = fparam5 * (1. - wet * wet);
    dry   = fparam5 * 2. * (1. - fparam4 * fparam4);
    dphi  = (twopi2 * std::pow (10., 3. * fparam3 - 2.) / fs);
    clock = std::max (
      std::min (
        eel2_or (((eel2_pow (delay, fparam14) * fparam13) + fparam12), 0.), fs),
      0.);
    samples = fs / clock;
    sx0     = 16. + fparam8 * 1.20103;
    cx0     = std::floor (std::exp (sx0 * std::log (1.059)) * 8.17742);
    cutoff0 = 2. * cx0 / fs;
    resx0   = (0.5 * fparam9) - 0.25;
    res0    = std::pow (10., -resx0);
    kx0     = 0.5 * res0 * std::sin (3.141592653589793 * cutoff0);
    c10     = 0.5 * (1. - kx0) / (1. + kx0);
    c20     = (0.5 + c10) * std::cos (3.141592653589793 * cutoff0);
    c30     = (0.5 + c10 + c20) * 0.25;
    ma00    = 2. * c30;
    ma10    = -4. * c30;
    ma20    = 2. * c30;
    mb10    = -2. * c20;
    mb20    = 2. * c10;
    sx1     = 16. + fparam10 * 1.20103;
    cx1     = std::floor (std::exp (sx1 * std::log (1.059)) * 8.17742);
    cutoff1 = 2. * cx1 / fs;
    resx1   = (0.5 * fparam11) - 0.25;
    res1    = std::pow (10., -resx1);
    kx1     = 0.5 * res1 * std::sin (3.141592653589793 * cutoff1);
    c11     = 0.5 * (1. - kx1) / (1. + kx1);
    c21     = (0.5 + c11) * std::cos (3.141592653589793 * cutoff1);
    c31     = (0.5 + c11 - c21) * 0.25;
    ma01    = 2. * c31;
    ma11    = 4. * c31;
    ma21    = 2. * c31;
    mb11    = -2. * c21;
    mb21    = 2. * c11;
    hiss    = fparam15 * 0.05;
    ;
  }
  //----------------------------------------------------------------------------
public:
  template <class T>
  void process_block_replacing (std::array<T*, 2> chnls, uint block_samples)
  {
    double a     = 0.;
    double b     = 0.;
    double c     = 0.;
    double db    = 0.;
    double dl    = 0.;
    double g     = 0.;
    double i     = 0.;
    double in0   = 0.;
    double in1   = 0.;
    double l     = 0.;
    double noise = 0.;
    double ol    = 0.;
    double out0  = 0.;
    double out1  = 0.;
    double tmp   = 0.;

    for (int $$i = 0; $$i < block_samples; ++$$i) {
      auto& spl0 = chnls[0][$$i];
      auto& spl1 = chnls[1][$$i];

      dl = dlbuf;
      db = dlbuf;
      i  = ipos;
      a  = spl0;
      b  = spl1;
      c  = (spl0 + spl1) * 0.5;
      (lp += (((jsfx_rand (2.) - 1.) - lp) * 0.02));
      noise = lp * hiss;
      if ((((uint) pos) % ((uint) std::floor (samples))) > 0.) {
        c = nn_val;
        pos += 1.;
        if ((pos >= fs)) {
          (pos = 0.);
        }
      }
      else {
        nn_val = c;
        pos += 1.;
      }
      if (eel2_eq (k, 0.)) {
        db += 0.01 * (del - db - mod - mod * std::sin (phi));
        ddl = 0.01 * (db - dl);
        phi += dphi;
        if ((phi > twopi)) {
          phi -= twopi;
        }
        k = 100.;
      }
      k -= 1.;
      dl += ddl;
      i -= 1.;
      if ((i < 0.)) {
        i = size;
      }
      l   = eel2_or (dl, 0.);
      tmp = dl - l;
      l += i;
      if ((l > size)) {
        l -= (size + 1.);
      }
      ol = heap (buf + (buffer + l));
      l += 1.;
      if ((l > size)) {
        l = 0.;
      }
      ol += tmp * (heap (buf + (buffer + l)) - ol);
      ol += noise;
      tmp  = c + fbk * ol;
      in0  = tmp;
      out0 = ma00 * in0 + ma10 * mx10 + ma20 * mx20 - mb10 * my10 - mb20 * my20;
      mx20 = mx10;
      mx10 = in0;
      my20 = my10;
      my10 = out0;
      tmp  = out0;
      in1  = tmp;
      out1 = ma01 * in1 + ma11 * mx11 + ma21 * mx21 - mb11 * my11 - mb21 * my21;
      mx21 = mx11;
      mx11 = in1;
      my21 = my11;
      my11 = out1;
      tmp  = out1;
      g    = [&] {
        if ((tmp < 0.)) {
          return -tmp;
        }
        else {
          return tmp;
        }
      }();
      env *= rel;
      if ((g > env)) {
        env = g;
      }
      if ((env > 1.)) {
        tmp /= env;
      }
      heap (buf + (buffer + i)) = tmp;
      ol *= wet;
      spl0  = dry * a + ol;
      spl1  = dry * b + ol;
      ipos  = i;
      dlbuf = dl;
      ;
    }
  }
  // addon, to make the stereo version...
  template <class T>
  void process_block_replacing (std::array<T*, 1> chnls, uint block_samples)
  {
    double a     = 0.;
    double c     = 0.;
    double db    = 0.;
    double dl    = 0.;
    double g     = 0.;
    double i     = 0.;
    double in0   = 0.;
    double in1   = 0.;
    double l     = 0.;
    double noise = 0.;
    double ol    = 0.;
    double out0  = 0.;
    double out1  = 0.;
    double tmp   = 0.;

    for (int $$i = 0; $$i < block_samples; ++$$i) {
      auto& spl0 = chnls[0][$$i];

      dl = dlbuf;
      db = dlbuf;
      i  = ipos;
      a  = spl0;
      c  = spl0;
      (lp += (((jsfx_rand (2.) - 1.) - lp) * 0.02));
      noise = lp * hiss;
      if ((((uint) pos) % ((uint) std::floor (samples))) > 0.) {
        c = nn_val;
        pos += 1.;
        if ((pos >= fs)) {
          (pos = 0.);
        }
      }
      else {
        nn_val = c;
        pos += 1.;
      }
      if (eel2_eq (k, 0.)) {
        db += 0.01 * (del - db - mod - mod * std::sin (phi));
        ddl = 0.01 * (db - dl);
        phi += dphi;
        if ((phi > twopi)) {
          phi -= twopi;
        }
        k = 100.;
      }
      k -= 1.;
      dl += ddl;
      i -= 1.;
      if ((i < 0.)) {
        i = size;
      }
      l   = eel2_or (dl, 0.);
      tmp = dl - l;
      l += i;
      if ((l > size)) {
        l -= (size + 1.);
      }
      ol = heap (buf + (buffer + l));
      l += 1.;
      if ((l > size)) {
        l = 0.;
      }
      ol += tmp * (heap (buf + (buffer + l)) - ol);
      ol += noise;
      tmp  = c + fbk * ol;
      in0  = tmp;
      out0 = ma00 * in0 + ma10 * mx10 + ma20 * mx20 - mb10 * my10 - mb20 * my20;
      mx20 = mx10;
      mx10 = in0;
      my20 = my10;
      my10 = out0;
      tmp  = out0;
      in1  = tmp;
      out1 = ma01 * in1 + ma11 * mx11 + ma21 * mx21 - mb11 * my11 - mb21 * my21;
      mx21 = mx11;
      mx11 = in1;
      my21 = my11;
      my11 = out1;
      tmp  = out1;
      g    = [&] {
        if ((tmp < 0.)) {
          return -tmp;
        }
        else {
          return tmp;
        }
      }();
      env *= rel;
      if ((g > env)) {
        env = g;
      }
      if ((env > 1.)) {
        tmp /= env;
      }
      heap (buf + (buffer + i)) = tmp;
      ol *= wet;
      spl0  = dry * a + ol;
      ipos  = i;
      dlbuf = dl;
      ;
    }
  }
}; /* jsfx_process */
}} // namespace artv::witti

#pragma GCC diagnostic pop

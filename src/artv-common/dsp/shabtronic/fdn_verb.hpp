#pragma once
// Generated by jsfx2cpp.py. To be manually corrected.
// includes for environment function calls
#include <algorithm>
#include <cmath>
#include <cstdint>
#include <cstring>
#include <vector>

#include "artv-common/dsp/own/classes/plugin_context.hpp"
#include "artv-common/dsp/types.hpp"
#include "artv-common/juce/parameter_definitions.hpp"
#include "artv-common/juce/parameter_types.hpp"
#include "artv-common/misc/mp11.hpp"
#include "artv-common/misc/short_ints.hpp"
#include "artv-common/misc/util.hpp"

namespace artv { namespace shabtronic {

class fdn_verb {
public:
  static constexpr dsp_types dsp_type  = dsp_types::reverb;
  static constexpr bus_types bus_type  = bus_types::stereo;
  static constexpr uint      n_inputs  = 1;
  static constexpr uint      n_outputs = 1;

private:
  //----------------------------------------------------------------------------

  //----------------------------------------------------------------------------
  // definitions for environment function calls
  static double eel2_and (double lhs, double rhs)
  {
    return (double) ((uint64_t) lhs & (uint64_t) rhs);
  }
  static double eel2_eq (double lhs, double rhs)
  {
    return (double) (std::fabs (lhs - rhs) < 0.00001);
  }
  static bool eel2_ne (double lhs, double rhs) { return !eel2_eq (lhs, rhs); }
  std::vector<float> heapmem;
  inline float&      heap (std::size_t value) { return heapmem[value]; }
  void               heap_reset (std::size_t s) { heapmem.resize (s); }
  void               jsfx_memset (size_t idx, int val, size_t size)
  {
    std::memset (&heapmem[idx], val, size * sizeof heapmem[0]);
  }

  //----------------------------------------------------------------------------
  // stubs for JSFX special variables

  double jsfx_specialvar_get_srate() { return _plugcontext->get_sample_rate(); }

  //----------------------------------------------------------------------------
public:
#if 0
  void set_slider1_slider(float v)
  {
    // Original slider line: slider1:500<1,500>-Time
    // Range: min:1.0, max:500.0, default: 500.0, step: None
    if (v == slider1)
    {
      return;
    }
    slider1 = v;
    slider();
  }
#else
  // Snippet for parameter boilerplate in the authors framework....
  struct time_tag {};

  void set (time_tag, float v)
  {
    // Original slider line: slider1:500<1,500>-Time
    // Range: min:1.0, max:500.0, default: 500.0, step: None
    if (v == slider1) {
      return;
    }
    slider1 = v;
    slider();
  }

  static constexpr auto get_parameter (time_tag)
  {
    // Original slider line: slider1:500<1,500>-Time
    return float_param ("", 1.0, 500.0, 500.0, 0.1);
  }

#endif
#if 0
  void set_slider2_slider(float v)
  {
    // Original slider line: slider2:0.6<0,1>-Feedback
    // Range: min:0.0, max:1.0, default: 0.6, step: None
    if (v == slider2)
    {
      return;
    }
    slider2 = v;
    slider();
  }
#else
  // Snippet for parameter boilerplate in the authors framework....
  struct feedback_tag {};

  void set (feedback_tag, float v)
  {
    // Original slider line: slider2:0.6<0,1>-Feedback
    // Range: min:0.0, max:1.0, default: 0.6, step: None
    v *= 0.01;
    if (v == slider2) {
      return;
    }
    slider2 = v;
    slider();
  }

  static constexpr auto get_parameter (feedback_tag)
  {
    // Original slider line: slider2:0.6<0,1>-Feedback
    return float_param ("%", 0.0, 100.0, 60., 0.1);
  }

#endif
#if 0
  void set_slider3_slider(float v)
  {
    // Original slider line: slider3:0.6<0,1>-Density
    // Range: min:0.0, max:1.0, default: 0.6, step: None
    if (v == slider3)
    {
      return;
    }
    slider3 = v;
    slider();
  }
#else
  // Snippet for parameter boilerplate in the authors framework....
  struct density_tag {};

  void set (density_tag, float v)
  {
    // Original slider line: slider3:0.6<0,1>-Density
    // Range: min:0.0, max:1.0, default: 0.6, step: None
    v *= 0.01;
    if (v == slider3) {
      return;
    }
    slider3 = v;
    slider();
  }

  static constexpr auto get_parameter (density_tag)
  {
    // Original slider line: slider3:0.6<0,1>-Density
    return float_param ("%", 0.0, 100.0, 60., 0.1);
  }

#endif
#if 0
  void set_slider4_slider(float v)
  {
    // Original slider line: slider4:0.7<0,1>-Cascade
    // Range: min:0.0, max:1.0, default: 0.7, step: None
    if (v == slider4)
    {
      return;
    }
    slider4 = v;
    slider();
  }
#else
  // Snippet for parameter boilerplate in the authors framework....
  struct cascade_tag {};

  void set (cascade_tag, float v)
  {
    // Original slider line: slider4:0.7<0,1>-Cascade
    // Range: min:0.0, max:1.0, default: 0.7, step: None
    v *= 0.01;
    if (v == slider4) {
      return;
    }
    slider4 = v;
    slider();
  }

  static constexpr auto get_parameter (cascade_tag)
  {
    // Original slider line: slider4:0.7<0,1>-Cascade
    return float_param ("%", 0.0, 100.0, 70., 0.1);
  }

#endif
#if 0
  void set_slider5_slider(float v)
  {
    // Original slider line: slider5:0.414<0,10>-ModRate
    // Range: min:0.0, max:10.0, default: 0.414, step: None
    if (v == slider5)
    {
      return;
    }
    slider5 = v;
    slider();
  }
#else
  // Snippet for parameter boilerplate in the authors framework....
  struct mod_rate_tag {};

  void set (mod_rate_tag, float v)
  {
    // Original slider line: slider5:0.414<0,10>-ModRate
    // Range: min:0.0, max:10.0, default: 0.414, step: None
    if (v == slider5) {
      return;
    }
    slider5 = v;
    slider();
  }

  static constexpr auto get_parameter (mod_rate_tag)
  {
    // Original slider line: slider5:0.414<0,10>-ModRate
    return float_param ("", 0.0, 10.0, 0.414, 0.001);
  }

#endif
#if 0
  void set_slider6_slider(float v)
  {
    // Original slider line: slider6:0.75<0,1>-Depth
    // Range: min:0.0, max:1.0, default: 0.75, step: None
    if (v == slider6)
    {
      return;
    }
    slider6 = v;
    slider();
  }
#else
  // Snippet for parameter boilerplate in the authors framework....
  struct mod_depth_tag {};

  void set (mod_depth_tag, float v)
  {
    // Original slider line: slider6:0.75<0,1>-Depth
    // Range: min:0.0, max:1.0, default: 0.75, step: None
    v *= 0.01;
    if (v == slider6) {
      return;
    }
    slider6 = v;
    slider();
  }

  static constexpr auto get_parameter (mod_depth_tag)
  {
    // Original slider line: slider6:0.75<0,1>-Depth
    return float_param ("%", 0.0, 100.0, 75., 0.1);
  }

#endif
#if 0
  void set_slider7_slider(float v)
  {
    // Original slider line: slider7:0.25<-1,1>-Stereo
    // Range: min:-1.0, max:1.0, default: 0.25, step: None
    if (v == slider7)
    {
      return;
    }
    slider7 = v;
    slider();
  }
#else
  // Snippet for parameter boilerplate in the authors framework....
  struct stereo_tag {};

  void set (stereo_tag, float v)
  {
    // Original slider line: slider7:0.25<-1,1>-Stereo
    // Range: min:-1.0, max:1.0, default: 0.25, step: None
    v *= 0.01;
    if (v == slider7) {
      return;
    }
    slider7 = v;
    slider();
  }

  static constexpr auto get_parameter (stereo_tag)
  {
    // Original slider line: slider7:0.25<-1,1>-Stereo
    return float_param ("%", -100.0, 100.0, 25., 0.1);
  }

#endif
#if 0
  void set_slider8_slider(float v)
  {
    // Original slider line: slider8:4<3,32>-Smooth
    // Range: min:3.0, max:32.0, default: 4.0, step: None
    if (v == slider8)
    {
      return;
    }
    slider8 = v;
    slider();
  }
#else
  // Snippet for parameter boilerplate in the authors framework....
  struct smooth_tag {};

  void set (smooth_tag, float v)
  {
    // Original slider line: slider8:4<3,32>-Smooth
    // Range: min:3.0, max:32.0, default: 4.0, step: None
    if (v == slider8) {
      return;
    }
    slider8 = v;
    slider();
  }

  static constexpr auto get_parameter (smooth_tag)
  {
    // Original slider line: slider8:4<3,32>-Smooth
    return float_param ("", 3.0, 32.0, 4.0, 0.1);
  }

#endif
#if 0
  void set_slider9_slider(float v)
  {
    // Original slider line: slider9:10<10,2000>-Hipass
    // Range: min:10.0, max:2000.0, default: 10.0, step: None
    if (v == slider9)
    {
      return;
    }
    slider9 = v;
    slider();
  }
#else
  // Snippet for parameter boilerplate in the authors framework....
  struct hipass_tag {};

  void set (hipass_tag, float v)
  {
    // Original slider line: slider9:10<10,2000>-Hipass
    // Range: min:10.0, max:2000.0, default: 10.0, step: None
    v = midi_note_to_hz (v);
    if (v == slider9) {
      return;
    }
    slider9 = v;
    slider();
  }

  static constexpr auto get_parameter (hipass_tag)
  {
    // Original slider line: slider9:10<10,2000>-Hipass
    return frequency_parameter (10.0, 2000.0, 10.0);
  }

#endif
#if 0
  void set_slider10_slider(float v)
  {
    // Original slider line: slider10:20000<200,20000>-Lopass
    // Range: min:200.0, max:20000.0, default: 20000.0, step: None
    if (v == slider10)
    {
      return;
    }
    slider10 = v;
    slider();
  }
#else
  // Snippet for parameter boilerplate in the authors framework....
  struct lopass_tag {};

  void set (lopass_tag, float v)
  {
    // Original slider line: slider10:20000<200,20000>-Lopass
    // Range: min:200.0, max:20000.0, default: 20000.0, step: None
    v = midi_note_to_hz (v);
    if (v == slider10) {
      return;
    }
    slider10 = v;
    slider();
  }

  static constexpr auto get_parameter (lopass_tag)
  {
    // Original slider line: slider10:20000<200,20000>-Lopass
    return frequency_parameter (200.0, 20000.0, 20000.0);
  }

#endif
#if 0
  void set_slider11_slider(float v)
  {
    // Original slider line: slider11:0.5<0,1>-Mix
    // Range: min:0.0, max:1.0, default: 0.5, step: None
    if (v == slider11)
    {
      return;
    }
    slider11 = v;
    slider();
  }
#else
  // Snippet for parameter boilerplate in the authors framework....
  struct mix_tag {};

  void set (mix_tag, float v)
  {
    // Original slider line: slider11:0.5<0,1>-Mix
    // Range: min:0.0, max:1.0, default: 0.5, step: None
    v *= 0.01;
    if (v == slider11) {
      return;
    }
    slider11 = v;
    slider();
  }

  static constexpr auto get_parameter (mix_tag)
  {
    // Original slider line: slider11:0.5<0,1>-Mix
    return float_param ("%", 0.0, 100.0, 100., 0.1);
  }

#endif
#if 0
  void set_slider12_slider(float v)
  {
    // Original slider line: slider12:0<-12,12>-Pitch
    // Range: min:-12.0, max:12.0, default: 0.0, step: None
    if (v == slider12)
    {
      return;
    }
    slider12 = v;
    slider();
  }
#else
  // Snippet for parameter boilerplate in the authors framework....
  struct pre_shift_tag {};

  void set (pre_shift_tag, float v)
  {
    // Original slider line: slider12:0<-12,12>-Pitch
    // Range: min:-12.0, max:12.0, default: 0.0, step: None
    if (v == slider12) {
      return;
    }
    slider12 = v;
    slider();
  }

  static constexpr auto get_parameter (pre_shift_tag)
  {
    // Original slider line: slider12:0<-12,12>-Pitch
    return float_param ("Semitones", -12.0, 12.0, 0.0, 1.);
  }

#endif
#if 0
  void set_slider13_slider(float v)
  {
    // Original slider line: slider13:0<-12,12>-Post Shift
    // Range: min:-12.0, max:12.0, default: 0.0, step: None
    if (v == slider13)
    {
      return;
    }
    slider13 = v;
    slider();
  }
#else
  // Snippet for parameter boilerplate in the authors framework....
  struct post_shift_tag {};

  void set (post_shift_tag, float v)
  {
    // Original slider line: slider13:0<-12,12>-Post Shift
    // Range: min:-12.0, max:12.0, default: 0.0, step: None
    if (v == slider13) {
      return;
    }
    slider13 = v;
    slider();
  }

  static constexpr auto get_parameter (post_shift_tag)
  {
    // Original slider line: slider13:0<-12,12>-Post Shift
    return float_param ("Semitones", -12.0, 12.0, 0.0, 1.);
  }

#endif
#if 0
#else
  // Snippet for parameter boilerplate in the authors framework....
  using parameters = mp_list<
    time_tag,
    feedback_tag,
    density_tag,
    cascade_tag,
    mod_rate_tag,
    mod_depth_tag,
    stereo_tag,
    smooth_tag,
    hipass_tag,
    lopass_tag,
    mix_tag,
    pre_shift_tag,
    post_shift_tag>;
#endif
  //----------------------------------------------------------------------------
  // global/stateful variables for section "init"
private:
  double _memp;
  double _oldmemp;
  double a;
  double allpasstimes;
  double b;
  double c;
  double cstack;
  double d;
  double d1;
  double delay;
  double delaylines;
  double delaymemsize;
  double delayparams;
  double dp;
  double dsize;
  double f;
  double factor;
  double fdntempfactors;
  double fdntimes;
  double fp;
  double initcalled;
  double ip;
  double l2;
  double mask;
  double maxdelays;
  double maxdelaysize;
  double mod;
  double mp;
  double nodialvalues;
  double out;
  double outhi$a1;
  double outhi$a2;
  double outhi$b0;
  double outhi$b1;
  double outhi$b2;
  double outhi$l1;
  double outhi$l2;
  double outlo$a1;
  double outlo$a2;
  double outlo$b0;
  double outlo$b1;
  double outlo$b2;
  double outlo$l1;
  double outlo$l2;
  double pitchsize;
  double ps1;
  double ps2;
  double rp;
  double rtime;
  double sinwindow;
  double slider1;
  double slider10;
  double slider11;
  double slider12;
  double slider13;
  double slider2;
  double slider3;
  double slider4;
  double slider5;
  double slider6;
  double slider7;
  double slider8;
  double slider9;
  double stereowidth;
  double swidth;
  double warp;
  double warp2;
  double wp;
  //----------------------------------------------------------------------------
  void init_init_variables()
  {
    _memp          = 0;
    _oldmemp       = 0;
    a              = 0;
    allpasstimes   = 0;
    b              = 0;
    c              = 0;
    cstack         = 0;
    d              = 0;
    d1             = 0;
    delay          = 0;
    delaylines     = 0;
    delaymemsize   = 0;
    delayparams    = 0;
    dp             = 0;
    dsize          = 0;
    f              = 0;
    factor         = 0;
    fdntempfactors = 0;
    fdntimes       = 0;
    fp             = 0;
    initcalled     = 0;
    ip             = 0;
    l2             = 0;
    mask           = 0;
    maxdelays      = 0;
    maxdelaysize   = 0;
    mod            = 0;
    mp             = 0;
    nodialvalues   = 0;
    out            = 0;
    outhi$a1       = 0;
    outhi$a2       = 0;
    outhi$b0       = 0;
    outhi$b1       = 0;
    outhi$b2       = 0;
    outhi$l1       = 0;
    outhi$l2       = 0;
    outlo$a1       = 0;
    outlo$a2       = 0;
    outlo$b0       = 0;
    outlo$b1       = 0;
    outlo$b2       = 0;
    outlo$l1       = 0;
    outlo$l2       = 0;
    pitchsize      = 0;
    ps1            = 0;
    ps2            = 0;
    rp             = 0;
    rtime          = 0;
    sinwindow      = 0;
    slider1        = 0;
    slider10       = 0;
    slider11       = 0;
    slider12       = 0;
    slider13       = 0;
    slider2        = 0;
    slider3        = 0;
    slider4        = 0;
    slider5        = 0;
    slider6        = 0;
    slider7        = 0;
    slider8        = 0;
    slider9        = 0;
    stereowidth    = 0;
    swidth         = 0;
    warp           = 0;
    warp2          = 0;
    wp             = 0;
  }
  //----------------------------------------------------------------------------
  // global/stateful variables for section "block"
private:
  double feedback;
  double lrtime;
  double oldout;
  //----------------------------------------------------------------------------
  void init_block_variables()
  {
    feedback = 0;
    lrtime   = 0;
    oldout   = 0;
  }

  //----------------------------------------------------------------------------
  plugin_context* _plugcontext = nullptr;

public:
  //----------------------------------------------------------------------------
  void reset (plugin_context& pc)
  {
    _plugcontext = &pc;
    init_init_variables();
    init_block_variables();
    heapmem.clear();
    slider1   = 500.0;
    slider2   = 0.6;
    slider3   = 0.6;
    slider4   = 0.7;
    slider5   = 0.414;
    slider6   = 0.75;
    slider7   = 0.25;
    slider8   = 4.0;
    slider9   = 10.0;
    slider10  = 20000.0;
    slider11  = 1.0;
    slider12  = 0.0;
    slider13  = 0.0;
    cstack    = 0.;
    sinwindow = init$getmem_1 (jsfx_specialvar_get_srate());
    init$sinwindow (sinwindow, 8192.);
    nodialvalues   = 0.;
    allpasstimes   = init$getmem_1 (128.);
    fdntimes       = init$getmem_1 (128.);
    fdntempfactors = init$getmem_1 (128.);
    init$initdelaylines (64., 0.75);
    pitchsize = 8192.;
    init$sinwindow (sinwindow, pitchsize);
    initcalled = 1.;
    // jsfx_memset (delaylines, 0., 8000000. - delaylines);
    rtime       = slider1 / 1000. * jsfx_specialvar_get_srate();
    warp        = slider4;
    swidth      = 1. - slider9 * 0.2;
    stereowidth = swidth;
    init$biquadinit (
      outhi$b2, outhi$b1, outhi$b0, outhi$a2, outhi$a1, outhi$l2, outhi$l1);
    init$biquadinit (
      outlo$b2, outlo$b1, outlo$b0, outlo$a2, outlo$a1, outlo$l2, outlo$l1);
    ;
  }
  //----------------------------------------------------------------------------
private:
  void slider() {}
  //----------------------------------------------------------------------------
public:
  //----------------------------------------------------------------------------
  template <class T>
  void process (crange<T*> outs, crange<T const*> ins, uint samples)
  {
    assert (outs.size() >= (n_outputs * (uint) bus_type));
    assert (ins.size() >= (n_inputs * (uint) bus_type));
    double density          = 0.;
    double dlevel           = 0.;
    double gdepth           = 0.;
    double hifreq           = 0.;
    double housesize        = 0.;
    double housesizerecip   = 0.;
    double lofreq           = 0.;
    double mix              = 0.;
    double moddepth         = 0.;
    double modlength        = 0.;
    double modrate          = 0.;
    double outl             = 0.;
    double outr             = 0.;
    double pitchamount      = 0.;
    double pitchamount2     = 0.;
    double pitchamountrecip = 0.;
    double rate             = 0.;
    double spl0             = 0.;
    double spl1             = 0.;
    rtime                   = slider1 / 1000. * jsfx_specialvar_get_srate();
    if (eel2_ne (rtime, lrtime)) {
      init$cleardelays();
    }
    lrtime    = rtime;
    feedback  = slider2;
    dlevel    = std::pow (std::max (feedback, 0.75) + 0.5, 4.);
    density   = slider3;
    warp      = slider4;
    rate      = slider5;
    gdepth    = slider6;
    modrate   = rate / jsfx_specialvar_get_srate() * 2. * 3.141592653589793;
    modlength = jsfx_specialvar_get_srate() / 75. + 1.;
    moddepth  = std::min (1.0 / (2.0 * rate), 1.) * gdepth * modlength * 0.5;
    swidth    = slider7;
    init$calcdelaylengths (rtime, warp, swidth);
    hifreq = slider9;
    lofreq = slider10;
    init$hipass (
      hifreq, 0.25, outhi$b0, outhi$b1, outhi$b2, outhi$a1, outhi$a2);
    init$lowpass (
      lofreq, 0.25, outlo$b0, outlo$b1, outlo$b2, outlo$a1, outlo$a2);
    mix              = slider11;
    pitchamount      = std::pow (2., slider12 / 12.);
    pitchamountrecip = 1. / pitchamount;
    pitchamount2     = std::pow (2., slider13 / 12.);
    housesize        = 4.;
    housesizerecip   = -2.0 / housesize;
    ;
    for (uint $$i = 0; $$i < samples; ++$$i) {
      auto& spl0 = outs[0][$$i];
      auto& spl1 = outs[1][$$i];
      spl0       = ins[0][$$i];
      spl1       = ins[1][$$i];
      outl       = spl0;
      outr       = spl1;
      if (eel2_eq (feedback, 1.)) {
        outl = 0.;
      }
      outl += (oldout * feedback * 0.9);
      init$delayin (0., outl, modlength);
      outl = init$delayoutmod (0., modlength, modrate, moddepth);
      outl = init$allpassdelay (1., outl, heap (allpasstimes), density);
      outl = init$allpassdelay (2., outl, heap (allpasstimes + 1.), density);
      outl = init$allpassdelay (3., outl, heap (allpasstimes + 2.), density);
      outl = init$allpassdelay (4., outl, heap (allpasstimes + 3.), density);
      outl = init$allpassdelay (5., outl, heap (allpasstimes + 4.), density);
      outl = init$allpassdelay (6., outl, heap (allpasstimes + 5.), density);
      outl = init$allpassdelay (7., outl, heap (allpasstimes + 6.), density);
      outl = init$allpassdelay (8., outl, heap (allpasstimes + 7.), density);
      outl = init$biquadprocess (
        outl,
        outlo$b0,
        outlo$l1,
        outlo$b1,
        outlo$l2,
        outlo$a1,
        outlo$b2,
        outlo$a2);
      outl = init$biquadprocess (
        outl,
        outhi$b0,
        outhi$l1,
        outhi$b1,
        outhi$l2,
        outhi$a1,
        outhi$b2,
        outhi$a2);
      oldout = init$pitchshiftsynced (20., outl, pitchamount, pitchsize);
      if (eel2_eq (feedback, 1.)) {
        outl = 0.;
      }
      outr = init$householder4 (9., outl, fdntimes);
      outl = init$householder4 (13., outl, fdntimes + 12.);
      outr = init$pitchshiftfreerunning (21., outr, pitchamount2, pitchsize);
      outl = init$pitchshiftfreerunning (22., outl, pitchamount2, pitchsize);
      spl0 = spl0 * (1. - mix) + outl / dlevel * mix;
      spl1 = spl1 * (1. - mix) + outr / dlevel * mix;
      ;
    }
  }
  // functions for section "init"
private:
  //----------------------------------------------------------------------------
  double init$allpassdelay (double idx, double in, double t, double g)
  {
    double yy         = 0.;
    double out        = 0.;
    delay             = delaylines + (idx * maxdelaysize);
    dp                = heap (delayparams + (idx * 4. + 0.));
    out               = heap (delay + dp);
    yy                = in + out * -g;
    out               = yy * g + out;
    heap (delay + dp) = yy;
    dp += 1.;
    if (dp >= t) {
      dp -= t;
    }
    heap (delayparams + (idx * 4. + 0.)) = dp;
    return out;
  }
  //----------------------------------------------------------------------------
  double init$biquadinit (
    double& $b2,
    double& $b1,
    double& $b0,
    double& $a2,
    double& $a1,
    double& $l2,
    double& $l1)
  {
    $b2 = 0.;
    $b1 = $b2;
    $b0 = $b1;
    $a2 = $b0;
    $a1 = $a2;
    $l2 = $a1;
    $l1 = $l2;
    return $l1;
  }
  //----------------------------------------------------------------------------
  double init$biquadprocess (
    double  in,
    double& $b0,
    double& $l1,
    double& $b1,
    double& $l2,
    double& $a1,
    double& $b2,
    double& $a2)
  {
    double bout = 0.;
    bout        = in * $b0 + $l1;
    $l1         = in * $b1 + $l2 - $a1 * bout;
    $l2         = in * $b2 - $a2 * bout;
    return bout;
  }
  //----------------------------------------------------------------------------
  double init$calcdelaylengths (double length, double warp, double swidth)
  {
    c     = 0.;
    l2    = length;
    warp2 = warp;
    warp  = warp;
    return [&] {
      double $loop_ret_0 = {};
      while (c < 12.) {
        heap (allpasstimes + c) = std::floor (length);
        if (swidth < 0.) {
          heap (fdntimes + c) = std::floor (l2);
          heap (fdntimes + (c + 12.))
            = std::floor (l2 * (1. - -swidth * 0.005));
        }
        else {
          heap (fdntimes + c)         = std::floor (l2 * (1. - swidth * 0.005));
          heap (fdntimes + (c + 12.)) = std::floor (l2);
        }
        if (heap (allpasstimes + c) < 4.) {
          heap (allpasstimes + c) = 4.;
        }
        if (heap (fdntimes + c) < 4.) {
          heap (fdntimes + c) = 4.;
        }
        if (heap (fdntimes + (c + 12.)) < 4.) {
          heap (fdntimes + (c + 12.)) = 4.;
        }
        length *= warp;
        l2 *= warp2;
        c += 1.;
        $loop_ret_0 = c;
      }
      return $loop_ret_0;
    }();
  }
  //----------------------------------------------------------------------------
  void init$cleardelays()
  {
    if (eel2_ne (delaylines, 0.)) {
      jsfx_memset (delaylines, 0., delaymemsize);
    }
  }
  //----------------------------------------------------------------------------
  double init$delayin (double idx, double in, double t)
  {
    delay             = delaylines + (idx * maxdelaysize);
    dp                = heap (delayparams + (idx * 4. + 0.));
    out               = heap (delay + dp);
    heap (delay + dp) = in;
    dp += 1.;
    if (dp >= t) {
      dp = 0.;
    }
    heap (delayparams + (idx * 4. + 0.)) = dp;
    return out;
  }
  //----------------------------------------------------------------------------
  double init$delayout (double idx)
  {
    delay = delaylines + (idx * maxdelaysize);
    return heap (delay + (heap (delayparams + (idx * 4. + 0.))));
  }
  //----------------------------------------------------------------------------
  double init$delayoutmod (double idx, double t, double speed, double depth)
  {
    delay = delaylines + (idx * maxdelaysize);
    dp    = heap (delayparams + (idx * 4. + 0.));
    mp    = heap (delayparams + (idx * 4. + 1.));
    mod   = (std::sin (mp) + 1. + 1.0 / jsfx_specialvar_get_srate()) * depth;
    mp += speed;
    heap (delayparams + (idx * 4. + 1.)) = mp;
    dp += mod;
    if (dp >= t) {
      dp -= t;
    }
    f   = init$frac (dp);
    out = (1. - f) * heap (delay + dp);
    dp += 1.;
    if (dp >= t) {
      dp -= t;
    }
    return out + f * heap (delay + dp);
  }
  //----------------------------------------------------------------------------
  double init$frac (double x) { return x - std::floor (x); }
  //----------------------------------------------------------------------------
  double init$getmem_1 (double size)
  {
    _oldmemp = _memp;
    _memp += size;
    heap_reset (_memp);
    return _oldmemp;
  }
  //----------------------------------------------------------------------------
  double init$getmem_2 (double elements, double size)
  {
    return init$getmem_1 (elements * size);
  }
  //----------------------------------------------------------------------------
  double init$hipass (
    double  freq,
    double  q,
    double& $b0,
    double& $b1,
    double& $b2,
    double& $a1,
    double& $a2)
  {
    double norm = 0.;
    double k    = 0.;
    k    = std::tan (3.141592653589793 * freq / jsfx_specialvar_get_srate());
    norm = 1. / (1. + k / q + k * k);
    $b0  = 1. * norm;
    $b1  = -2. * $b0;
    $b2  = $b0;
    $a1  = 2. * (k * k - 1.) * norm;
    $a2  = (1. - k / q + k * k) * norm;
    return $a2;
  }
  //----------------------------------------------------------------------------
  double init$householder4 (double idx, double in, double timearray)
  {
    a      = init$delayout (idx + 0.);
    b      = init$delayout (idx + 1.);
    c      = init$delayout (idx + 2.);
    d      = init$delayout (idx + 3.);
    factor = (a + b + c + d) * -0.5;
    init$delayin (idx + 0., in + (a + factor) * feedback, heap (timearray));
    init$delayin (
      idx + 1., in + (b + factor) * feedback, heap (timearray + 1.));
    init$delayin (
      idx + 2., in + (c + factor) * feedback, heap (timearray + 2.));
    init$delayin (
      idx + 3., in + (d + factor) * feedback, heap (timearray + 3.));
    return factor;
  }
  //----------------------------------------------------------------------------
  double init$initdelaylines (double count, double maxsecs)
  {
    maxdelaysize = jsfx_specialvar_get_srate() * maxsecs;
    maxdelays    = count;
    delaymemsize = maxdelays * maxdelaysize;
    delayparams  = init$getmem_2 (maxdelays, 4.);
    delaylines   = init$getmem_2 (maxdelays, maxdelaysize);
    return delaylines;
  }
  //----------------------------------------------------------------------------
  double init$lowpass (
    double  freq,
    double  q,
    double& $b0,
    double& $b1,
    double& $b2,
    double& $a1,
    double& $a2)
  {
    double norm = 0.;
    double k    = 0.;
    k    = std::tan (3.141592653589793 * freq / jsfx_specialvar_get_srate());
    norm = 1.0 / (1. + k / q + k * k);
    $b0  = k * k * norm;
    $b1  = 2.0 * $b0;
    $b2  = $b0;
    $a1  = 2. * (k * k - 1.) * norm;
    $a2  = (1. - k / q + k * k) * norm;
    return $a2;
  }
  //----------------------------------------------------------------------------
  double init$pitchshiftfreerunning (
    double idx,
    double in,
    double shiftamount,
    double size)
  {
    dsize                                = size / 2.;
    mask                                 = size - 1.;
    delay                                = delaylines + (idx * maxdelaysize);
    wp                                   = heap (delayparams + (idx * 4. + 0.));
    heap (delay + (eel2_and (wp, mask))) = in;
    rp                                   = heap (delayparams + (idx * 4. + 1.));
    rp += shiftamount;
    wp += 1.;
    heap (delayparams + (idx * 4. + 1.)) = rp;
    heap (delayparams + (idx * 4. + 0.)) = wp;
    ip                                   = std::floor (rp);
    fp                                   = rp - ip;
    ps1 = heap (delay + (eel2_and (ip, mask))) * (1.0 - fp)
      + heap (delay + (eel2_and ((ip + 1.), mask))) * fp;
    ps2 = heap (delay + (eel2_and ((ip + dsize), mask))) * (1.0 - fp)
      + heap (delay + (eel2_and ((ip + 1. + dsize), mask))) * fp;
    d1 = std::abs (rp - wp);
    return heap (sinwindow + (eel2_and (d1, mask))) * ps1
      + heap (sinwindow + (eel2_and ((d1 + dsize), mask))) * ps2;
  }
  //----------------------------------------------------------------------------
  double init$pitchshiftsynced (
    double idx,
    double in,
    double shiftamount,
    double size)
  {
    dsize                                = size / 2.;
    mask                                 = size - 1.;
    delay                                = delaylines + (idx * maxdelaysize);
    wp                                   = heap (delayparams + (idx * 4. + 0.));
    heap (delay + (eel2_and (wp, mask))) = in;
    rp                                   = (wp * shiftamount);
    wp += 1.;
    heap (delayparams + (idx * 4. + 0.)) = wp;
    ip                                   = std::floor (rp);
    fp                                   = rp - ip;
    ps1 = heap (delay + (eel2_and (ip, mask))) * (1.0 - fp)
      + heap (delay + (eel2_and ((ip + 1.), mask))) * fp;
    ps2 = heap (delay + (eel2_and ((ip + dsize), mask))) * (1.0 - fp)
      + heap (delay + (eel2_and ((ip + 1. + dsize), mask))) * fp;
    d1 = (rp - wp);
    return heap (sinwindow + (eel2_and (d1, mask))) * ps1
      + heap (sinwindow + (eel2_and ((d1 + dsize), mask))) * ps2;
  }
  //----------------------------------------------------------------------------
  double init$sinwindow (double w, double wsize)
  {
    double x = 0.;
    x        = 0.;
    return [&] {
      double $loop_ret_0 = {};
      while (x < wsize) {
        heap (w + x) = std::sin (x / wsize * 3.141592653589793);
        x += 1.;
        $loop_ret_0 = x;
      }
      return $loop_ret_0;
    }();
  }
  //----------------------------------------------------------------------------
}; /* jsfx_process */

}} // namespace artv::shabtronic

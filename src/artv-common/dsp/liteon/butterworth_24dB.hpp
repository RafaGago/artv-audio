// Ported from https://github.com/Rcomian/jsfx-vcv
// commit sha: 65bfa7896480f3de7d424e42a6ef2b3737b43a20

#pragma once
// Generated by jsfx2cpp.py. To be manually corrected.
// includes for environment function calls
#include <algorithm>
#include <cmath>

#include <juce_audio_processors/juce_audio_processors.h>

#include "artv-common/dsp/own/classes/plugin_context.hpp"
#include "artv-common/dsp/types.hpp"
#include "artv-common/juce/parameter_definitions.hpp"
#include "artv-common/juce/parameter_types.hpp"
#include "artv-common/misc/mp11.hpp"
#include "artv-common/misc/short_ints.hpp"
#include "artv-common/misc/util.hpp"

namespace artv { namespace liteon {

class butterworth24 {
public:
  //----------------------------------------------------------------------------
  static constexpr dsp_types dsp_type = dsp_types::filter;
  //----------------------------------------------------------------------------
private:
#if 0
  /* "mempool" emulates the JSFX per instance memory pool.
  It can be removed if unused. On most cases the length of this array can be
  reduced. It is set to a very conservative (high) value matching what JSFX
  provides. */
  double mempool[8 * 1024 * 1024] = {};
#endif
  //----------------------------------------------------------------------------
  // definitions for environment function calls
  static double eel2_eq (double lhs, double rhs)
  {
    return (double) (std::abs (lhs - rhs) < 0.00001);
  }
  static double eel2_pow (double lhs, double rhs)
  {
    return std::pow (lhs, rhs);
  }

  // Parameters (call once per block) ------------------------------------------
public:
  //----------------------------------------------------------------------------
  // stubs for sliders
  //----------------------------------------------------------------------------
  // slider1:0<0,1,1{Stereo,Mono}>Processing
  double get_slider_slider1()
  {
    // TODO: stub, add code for getting "slider1"
    // Range: min:0.0, max:1.0, default: 0.0, step: 1.0
    return 0.;
  }
  //----------------------------------------------------------------------------
  // slider2:0<0,1,1{LP (24dB/oct),HP (6dB/oct)}>Filter Type
  struct type_tag {};
  static constexpr auto get_parameter (type_tag)
  {
    return choice_param (0, make_cstr_array ("Lowpass", "Highpass"), 8);
  }

  double get_slider_slider2()
  {
    // Range: min:0.0, max:1.0, default: 0.0, step: 1.0
    return filtype;
  }
  int filtype = 0;

  void set (type_tag, int v)
  {
    if (v == filtype || v >= get_parameter (type_tag {}).choices.size()) {
      return;
    }
    filtype = v;
    slider();
  }
  //----------------------------------------------------------------------------
  // slider3:100<0,100,0.05>Cutoff (Scale)
  double get_slider_slider3()
  {
    // Range: min:0.0, max:100.0, default: 100.0, step: 0.05
    return cutoff_p;
  }
  float cutoff_p = 100.;

  struct cutoff_tag {};
  void set (cutoff_tag, float v)
  {
    if (v == cutoff_p) {
      return;
    }
    cutoff_p = v;
    slider();
  }

  static constexpr auto get_parameter (cutoff_tag)
  {
    return float_param ("", 0.f, 100.f, 100.f, 0.05f);
  }
  //----------------------------------------------------------------------------
  // slider4:0<0,0.9>Resonance (Mix/Max)
  double get_slider_slider4()
  {
    // TODO: stub, add code for getting "slider4"
    // Range: min:0.0, max:0.9, default: 0.0, step: None
    return resonance_p;
  }
  struct resonance_tag {};
  void set (resonance_tag, float v)
  {
    if (v == resonance_p) {
      return;
    }
    resonance_p = v;
    slider();
  }

  float resonance_p = 100.;

  static constexpr auto get_parameter (resonance_tag)
  {
    return float_param ("", 0.f, 0.9f, 0.f, 0.001f);
  }
  //----------------------------------------------------------------------------
  // slider5:0<-25,25,0.05>Output (dB)
  double get_slider_slider5()
  {
    // TODO: stub, add code for getting "slider5"
    // Range: min:-25.0, max:25.0, default: 0.0, step: 0.05
    return 0.;
  }
  //----------------------------------------------------------------------------
  // slider6:0<0,1,1{On,Off}>Limiter
  double get_slider_slider6()
  {
    // TODO: stub, add code for getting "slider6"
    // Range: min:0.0, max:1.0, default: 0.0, step: 1.0
    return limiter_off;
  }
  int limiter_off = 0;

  struct limiter_tag {};
  void set (limiter_tag, int v)
  {
    if (v == limiter_off) {
      return;
    }
    limiter_off = v;
    slider();
  }
  static constexpr auto get_parameter (limiter_tag)
  {
    return choice_param (0, make_cstr_array ("On", "Off"));
  }
  //----------------------------------------------------------------------------
  using parameters = mp_list<type_tag, cutoff_tag, resonance_tag, limiter_tag>;

private:
  //----------------------------------------------------------------------------
  void slider()
  {
    double b1     = 0.;
    double b2     = 0.;
    double bd     = 0.;
    double bd_tmp = 0.;
    double q      = 0.;
    double res    = 0.;
    double sx     = 0.;
    double wp     = 0.;
    ftype         = get_slider_slider2();
    mono          = get_slider_slider1();
    limiter       = get_slider_slider6();
    sx            = 16. + get_slider_slider3() * 1.20103;
    cutoff        = std::floor (std::exp (sx * std::log (1.059)) * 8.17742);
    res           = get_slider_slider3();
    outgain       = eel2_pow (10., (get_slider_slider5() / 20.));
    wp            = t2 * std::tan (t3 * cutoff);
    if (cutoff > 150.) {
      (q = (get_slider_slider4() * bq) + 1.);
    }
    else {
      (q = (0.1 * bq) + 1.);
    }
    b1     = (0.765367 / q) / wp;
    b2     = 1. / (wp * wp);
    bd_tmp = t0 * b2 + 1.;
    bd     = 1. / (bd_tmp + t2 * b1);
    gain   = bd;
    coef2  = (2. - t1 * b2);
    coef0  = coef2 * bd;
    coef1  = (bd_tmp - t2 * b1) * bd;
    b1     = (1.847759 / q) / wp;
    bd     = 1. / (bd_tmp + t2 * b1);
    gain *= bd;
    coef2 *= bd;
    coef3 = (bd_tmp - t2 * b1) * bd;
  }
  //----------------------------------------------------------------------------
  // global/stateful variables for section "init"
  double bq;
  double fs;
  double history1;
  double history1l;
  double history1r;
  double history2;
  double history2l;
  double history2r;
  double history3;
  double history3l;
  double history3r;
  double history4;
  double history4l;
  double history4r;
  double mv;
  double new_hist;
  double new_histl;
  double new_histr;
  double pi;
  double t0;
  double t1;
  double t2;
  double t3;
  //----------------------------------------------------------------------------
  void init_init_variables()
  {
    bq        = 0;
    fs        = 0;
    history1  = 0;
    history1l = 0;
    history1r = 0;
    history2  = 0;
    history2l = 0;
    history2r = 0;
    history3  = 0;
    history3l = 0;
    history3r = 0;
    history4  = 0;
    history4l = 0;
    history4r = 0;
    mv        = 0;
    new_hist  = 0;
    new_histl = 0;
    new_histr = 0;
    pi        = 0;
    t0        = 0;
    t1        = 0;
    t2        = 0;
    t3        = 0;
  }
  //----------------------------------------------------------------------------
  // global/stateful variables for section "slider"
  double coef0;
  double coef1;
  double coef2;
  double coef3;
  double cutoff;
  double ftype;
  double gain;
  double limiter;
  double mono;
  double outgain;
  //----------------------------------------------------------------------------
  void init_slider_variables()
  {
    coef0   = 0;
    coef1   = 0;
    coef2   = 0;
    coef3   = 0;
    cutoff  = 0;
    ftype   = 0;
    gain    = 0;
    limiter = 0;
    mono    = 0;
    outgain = 0;
  }
  //----------------------------------------------------------------------------
public:
  void reset (plugin_context& pc)
  {
    init_init_variables();
    init_slider_variables();
    mv        = eel2_pow (2., (-0.2 / 6.));
    history4  = 0.;
    history3  = history4;
    history2  = history3;
    history1  = history2;
    history4l = 0.;
    history3l = history4l;
    history2l = history3l;
    history1l = history2l;
    history4r = 0.;
    history3r = history4r;
    history2r = history3r;
    history1r = history2r;
    new_histr = 0.;
    new_histl = new_histr;
    new_hist  = new_histl;
    bq        = 6.;
    pi        = 22. / 7.;
    fs        = pc.get_sample_rate();
    t0        = 4. * fs * fs;
    t1        = 8. * fs * fs;
    t2        = 2. * fs;
    t3        = pi / fs;
    slider();
  }
  //----------------------------------------------------------------------------
  template <class T>
  void process_block_replacing (std::array<T*, 2> chnls, uint samples)
  {
    double hp_bp   = 0.;
    double input   = 0.;
    double inputl  = 0.;
    double inputr  = 0.;
    double output  = 0.;
    double outputl = 0.;
    double outputr = 0.;
    double spl0    = 0.;
    double spl1    = 0.;

    for (uint i = 0; i < samples; ++i) {
      auto& spl0 = chnls[0][i];
      auto& spl1 = chnls[1][i];

      if (eel2_eq (mono, 0.)) {
        inputl  = spl0;
        inputr  = spl1;
        outputl = inputl * gain;
        outputr = inputr * gain;
        outputl -= history1l * coef0;
        outputr -= history1r * coef0;
        new_histl = outputl - history2l * coef1;
        new_histr = outputr - history2r * coef1;
        outputl   = new_histl + history1l * 2.;
        outputr   = new_histr + history1r * 2.;
        outputl += history2l;
        outputr += history2r;
        history2l = history1l;
        history2r = history1r;
        history1l = new_histl;
        history1r = new_histr;
        outputl -= history3l * coef2;
        outputr -= history3r * coef2;
        new_histl = outputl - history4l * coef3;
        new_histr = outputr - history4r * coef3;
        outputl   = new_histl + history3l * 2.;
        outputr   = new_histr + history3r * 2.;
        outputl += history4l;
        outputr += history4r;
        history4l = history3l;
        history4r = history3r;
        history3l = new_histl;
        history3r = new_histr;
        if (eel2_eq (ftype, 1.)) {
          outputl = inputl - outputl;
          outputr = inputr - outputr;
        }
        if (cutoff < 300.) {
          outputl = std::min (std::max (outputl, -mv), mv);
          outputr = std::min (std::max (outputr, -mv), mv);
        }
        outputl *= outgain;
        outputr *= outgain;
        if (eel2_eq (limiter, 0.)) {
          spl0 = std::min (std::max (outputl, -mv), mv);
          spl1 = std::min (std::max (outputr, -mv), mv);
        }
        else {
          spl0 = outputl;
          spl1 = outputr;
        }
      }
      else {
        input  = (spl0 + spl1) / 2.;
        hp_bp  = input * gain + history1 * coef0;
        output = input * gain;
        output -= history1 * coef0;
        new_hist = output - history2 * coef1;
        output   = new_hist + history1 * 2.;
        output += history2;
        history2 = history1;
        history1 = new_hist;
        output -= history3 * coef2;
        new_hist = output - history4 * coef3;
        output   = new_hist + history3 * 2.;
        output += history4;
        history4 = history3;
        history3 = new_hist;
        if (eel2_eq (ftype, 1.)) {
          (output = input - output);
        }
        if (cutoff < 300.) {
          (output = std::min (std::max (output, -mv), mv));
        }
        output *= outgain;
        if (eel2_eq (limiter, 0.)) {
          spl1 = std::min (std::max (output, -mv), mv);
          (spl0 = spl1);
        }
        else {
          spl1 = output;
          (spl0 = spl1);
        }
      }
    }
  }
}; /* butterworth24 */
}} // namespace artv::liteon

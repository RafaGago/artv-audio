// Ported from https://github.com/Rcomian/jsfx-vcv
// commit sha: 65bfa7896480f3de7d424e42a6ef2b3737b43a20
#pragma once
// Generated by jsfx2cpp.py. To be manually corrected.
// includes for environment function calls
#include <algorithm>
#include <cmath>
#include <cstdint>
#include <juce_audio_processors/juce_audio_processors.h>

#include "artv-common/dsp/own/classes/plugin_context.hpp"
#include "artv-common/dsp/types.hpp"
#include "artv-common/juce/parameter_definitions.hpp"
#include "artv-common/juce/parameter_types.hpp"
#include "artv-common/misc/mp11.hpp"
#include "artv-common/misc/short_ints.hpp"
#include "artv-common/misc/util.hpp"

namespace artv { namespace liteon {

struct stereo_tilt {
public:
  //----------------------------------------------------------------------------
  static constexpr dsp_types dsp_type  = dsp_types::stereo;
  static constexpr bus_types bus_type  = bus_types::stereo;
  static constexpr uint      n_inputs  = 1;
  static constexpr uint      n_outputs = 1;
  //----------------------------------------------------------------------------
private:
#if 0
  /* "mempool" emulates the JSFX per instance memory pool.
  It can be removed if unused. On most cases the length of this array can be
  reduced. It is set to a very conservative (high) value matching what JSFX
  provides. */
  double mempool[8 * 1024 * 1024] = {};
#endif
  //----------------------------------------------------------------------------
  // definitions for environment function calls
  static double eel2_or (double lhs, double rhs)
  {
    return (double) ((uint64_t) lhs | (uint64_t) rhs);
  }
  static double eel2_pow (double lhs, double rhs)
  {
    return std::pow (lhs, rhs);
  }
  double jsfx_sign (double value)
  {
    auto v = *((uint64_t*) ((void*) &value));
    return (v == 0) ? 0. : (v & (1ull << 63)) ? -1. : 1.;
  }
  //----------------------------------------------------------------------------
public:
  // stubs for sliders
  // slider1:50<0,100,0.05>Center Frequency (Scale)
  double get_slider_slider1()
  {
    // Range: min:0.0, max:100.0, default: 50.0, step: 0.05
    return frequencyp;
  }
  float frequencyp = 50.;
  struct frequency_tag {};
  void set (frequency_tag, float v)
  {
    if (v == frequencyp) {
      return;
    }
    frequencyp = v;
    slider();
  }

  static constexpr auto get_parameter (frequency_tag)
  {
    return float_param ("", 0.f, 100.f, 50.f, 0.05f);
  }
  //----------------------------------------------------------------------------
  // slider2:0<-6,6,0.05>Tilt (- / +) (dB)
  double get_slider_slider2()
  {
    // Range: min:-6.0, max:6.0, default: 0.0, step: 0.05
    return tiltp;
  }
  float tiltp = 50.;
  struct tilt_tag {};
  void set (tilt_tag, float v)
  {
    if (v == tiltp) {
      return;
    }
    tiltp = v;
    slider();
  }

  static constexpr auto get_parameter (tilt_tag)
  {
    return float_param ("dB", -6.f, 6.f, 0.f, 0.05f);
  }
  //----------------------------------------------------------------------------
  // slider3:0<-100,100,0.05>Balance (Left / Right) (%)

  double get_slider_slider3()
  {
    // Range: min:-100.0, max:100.0, default: 0.0, step: 0.05
    return balancep;
  }
  float balancep = 50.;
  struct balance_tag {};
  void set (balance_tag, float v)
  {
    if (v == balancep) {
      return;
    }
    balancep = v;
    slider();
  }

  static constexpr auto get_parameter (balance_tag)
  {
    return float_param ("L/R", -100.f, 100.f, 0.f, 0.05f);
  }
  //----------------------------------------------------------------------------
  // slider4:0<-16,16,0.05>Output Gain (dB)
  double get_slider_slider4()
  {
    // TODO: stub, add code for getting "slider4"
    // Range: min:-16.0, max:16.0, default: 0.0, step: 0.05
    return 0.;
  }
  //----------------------------------------------------------------------------
  using parameters = mp_list<frequency_tag, tilt_tag, balance_tag>;
  //----------------------------------------------------------------------------
private:
  // global/stateful variables for section "init"
  double amp;
  double denorm;
  double pi;
  double sr3;
  //----------------------------------------------------------------------------
  void init_init_variables()
  {
    amp    = 0;
    denorm = 0;
    pi     = 0;
    sr3    = 0;
  }
  //----------------------------------------------------------------------------
  // global/stateful variables for section "slider"
  double a0;
  double b1;
  double gl;
  double gr;
  double hgain0;
  double hgain1;
  double lgain0;
  double lgain1;
  double outgain;
  //----------------------------------------------------------------------------
  void init_slider_variables()
  {
    a0      = 0;
    b1      = 0;
    gl      = 0;
    gr      = 0;
    hgain0  = 0;
    hgain1  = 0;
    lgain0  = 0;
    lgain1  = 0;
    outgain = 0;
  }
  //----------------------------------------------------------------------------
  // global/stateful variables for section "block"
  double lp_out;
  double lp_out_r;
  //----------------------------------------------------------------------------
  void init_block_variables()
  {
    lp_out   = 0;
    lp_out_r = 0;
  }
  //----------------------------------------------------------------------------
public:
  void reset (plugin_context& pc)
  {
    init_init_variables();
    init_slider_variables();
    init_block_variables();
    amp    = 6. / std::log (2.);
    denorm = eel2_pow (10., -30.);
    pi     = 3.141592653589793;
    sr3    = 3. * pc.get_sample_rate();
    slider();
  }
  //----------------------------------------------------------------------------
private:
  void slider()
  {
    double f0    = 0.;
    double gain  = 0.;
    double n     = 0.;
    double omega = 0.;
    double sx    = 0.;
    gain         = get_slider_slider2();
    hgain1       = std::exp (gain / amp) - 1.;
    lgain0       = hgain1;
    lgain1       = std::exp (-gain / amp) - 1.;
    hgain0       = lgain1;
    outgain = std::exp ((get_slider_slider4() - jsfx_sign (gain) * gain) / amp);
    gl      = std::min (1., 1. - get_slider_slider3() * 0.01);
    gr      = std::min (1., 1. + get_slider_slider3() * 0.01);
    sx      = 16. + get_slider_slider1() * 1.20103;
    f0      = eel2_or (std::exp (sx * std::log (1.059)) * 8.17742, 0.);
    omega   = 2. * pi * f0;
    n       = 1. / (sr3 + omega);
    a0      = 2. * omega * n;
    b1      = (sr3 - omega) * n;
    ;
  }
  //----------------------------------------------------------------------------
public:
  template <class T>
  void process (crange<T*> outs, crange<T const*> ins, uint samples)
  {
    assert (outs.size() >= (n_outputs * (uint) bus_type));
    assert (ins.size() >= (n_inputs * (uint) bus_type));
    double output   = 0.;
    double output_r = 0.;

    for (uint i = 0; i < samples; ++i) {
      auto& spl0 = outs[0][i];
      auto& spl1 = outs[1][i];
      spl0       = ins[0][i];
      spl1       = ins[1][i];
      (lp_out = a0 * spl0 + b1 * lp_out);
      (output = spl0 + lgain0 * lp_out + hgain0 * (spl0 - lp_out));
      spl0 = output * gl * outgain + denorm;
      (lp_out_r = a0 * spl1 + b1 * lp_out_r);
      (output_r = spl1 + lgain1 * lp_out_r + hgain1 * (spl1 - lp_out_r));
      spl1 = output_r * gr * outgain + denorm;
      ;
    }
  }
}; /* stereo_tilt */
}} // namespace artv::liteon
